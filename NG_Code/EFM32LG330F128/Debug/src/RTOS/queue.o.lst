   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"queue.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.comm	xQueueRegistry,80,4
  19              		.section	.text.xQueueGenericReset,"ax",%progbits
  20              		.align	2
  21              		.global	xQueueGenericReset
  22              		.thumb
  23              		.thumb_func
  25              	xQueueGenericReset:
  26              	.LFB4:
  27              		.file 1 "../src/RTOS/queue.c"
   1:../src/RTOS/queue.c **** /*
   2:../src/RTOS/queue.c ****     FreeRTOS V9.0.0rc2 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:../src/RTOS/queue.c ****     All rights reserved
   4:../src/RTOS/queue.c **** 
   5:../src/RTOS/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../src/RTOS/queue.c **** 
   7:../src/RTOS/queue.c ****     This file is part of the FreeRTOS distribution.
   8:../src/RTOS/queue.c **** 
   9:../src/RTOS/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:../src/RTOS/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:../src/RTOS/queue.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:../src/RTOS/queue.c **** 
  13:../src/RTOS/queue.c ****     ***************************************************************************
  14:../src/RTOS/queue.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:../src/RTOS/queue.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:../src/RTOS/queue.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:../src/RTOS/queue.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:../src/RTOS/queue.c ****     ***************************************************************************
  19:../src/RTOS/queue.c **** 
  20:../src/RTOS/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:../src/RTOS/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:../src/RTOS/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:../src/RTOS/queue.c ****     link: http://www.freertos.org/a00114.html
  24:../src/RTOS/queue.c **** 
  25:../src/RTOS/queue.c ****     ***************************************************************************
  26:../src/RTOS/queue.c ****      *                                                                       *
  27:../src/RTOS/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:../src/RTOS/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:../src/RTOS/queue.c ****      *    platform software that is more than just the market leader, it     *
  30:../src/RTOS/queue.c ****      *    is the industry's de facto standard.                               *
  31:../src/RTOS/queue.c ****      *                                                                       *
  32:../src/RTOS/queue.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:../src/RTOS/queue.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:../src/RTOS/queue.c ****      *    tutorial book, reference manual, or both:                          *
  35:../src/RTOS/queue.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:../src/RTOS/queue.c ****      *                                                                       *
  37:../src/RTOS/queue.c ****     ***************************************************************************
  38:../src/RTOS/queue.c **** 
  39:../src/RTOS/queue.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:../src/RTOS/queue.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:../src/RTOS/queue.c ****     defined configASSERT()?
  42:../src/RTOS/queue.c **** 
  43:../src/RTOS/queue.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:../src/RTOS/queue.c ****     embedded software for free we request you assist our global community by
  45:../src/RTOS/queue.c ****     participating in the support forum.
  46:../src/RTOS/queue.c **** 
  47:../src/RTOS/queue.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:../src/RTOS/queue.c ****     be as productive as possible as early as possible.  Now you can receive
  49:../src/RTOS/queue.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:../src/RTOS/queue.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:../src/RTOS/queue.c **** 
  52:../src/RTOS/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:../src/RTOS/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:../src/RTOS/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:../src/RTOS/queue.c **** 
  56:../src/RTOS/queue.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:../src/RTOS/queue.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:../src/RTOS/queue.c **** 
  59:../src/RTOS/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:../src/RTOS/queue.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:../src/RTOS/queue.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:../src/RTOS/queue.c **** 
  63:../src/RTOS/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:../src/RTOS/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  65:../src/RTOS/queue.c ****     mission critical applications that require provable dependability.
  66:../src/RTOS/queue.c **** 
  67:../src/RTOS/queue.c ****     1 tab == 4 spaces!
  68:../src/RTOS/queue.c **** */
  69:../src/RTOS/queue.c **** 
  70:../src/RTOS/queue.c **** #include <stdlib.h>
  71:../src/RTOS/queue.c **** #include <string.h>
  72:../src/RTOS/queue.c **** 
  73:../src/RTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  74:../src/RTOS/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  75:../src/RTOS/queue.c **** task.h is included from an application file. */
  76:../src/RTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  77:../src/RTOS/queue.c **** 
  78:../src/RTOS/queue.c **** #include "FreeRTOS.h"
  79:../src/RTOS/queue.c **** #include "task.h"
  80:../src/RTOS/queue.c **** #include "queue.h"
  81:../src/RTOS/queue.c **** 
  82:../src/RTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  83:../src/RTOS/queue.c **** 	#include "croutine.h"
  84:../src/RTOS/queue.c **** #endif
  85:../src/RTOS/queue.c **** 
  86:../src/RTOS/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  87:../src/RTOS/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  88:../src/RTOS/queue.c **** header files above, but not in this file, in order to generate the correct
  89:../src/RTOS/queue.c **** privileged Vs unprivileged linkage and placement. */
  90:../src/RTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  91:../src/RTOS/queue.c **** 
  92:../src/RTOS/queue.c **** 
  93:../src/RTOS/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  94:../src/RTOS/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  95:../src/RTOS/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  96:../src/RTOS/queue.c **** 
  97:../src/RTOS/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  98:../src/RTOS/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  99:../src/RTOS/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
 100:../src/RTOS/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
 101:../src/RTOS/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
 102:../src/RTOS/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
 103:../src/RTOS/queue.c **** the code is maintained despite this dual use of two structure members.  An
 104:../src/RTOS/queue.c **** alternative implementation would be to use a union, but use of a union is
 105:../src/RTOS/queue.c **** against the coding standard (although an exception to the standard has been
 106:../src/RTOS/queue.c **** permitted where the dual use also significantly changes the type of the
 107:../src/RTOS/queue.c **** structure member). */
 108:../src/RTOS/queue.c **** #define pxMutexHolder					pcTail
 109:../src/RTOS/queue.c **** #define uxQueueType						pcHead
 110:../src/RTOS/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 111:../src/RTOS/queue.c **** 
 112:../src/RTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 113:../src/RTOS/queue.c **** zero. */
 114:../src/RTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
 115:../src/RTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
 116:../src/RTOS/queue.c **** 
 117:../src/RTOS/queue.c **** #if( configUSE_PREEMPTION == 0 )
 118:../src/RTOS/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 119:../src/RTOS/queue.c **** 	performed just because a higher priority task has been woken. */
 120:../src/RTOS/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
 121:../src/RTOS/queue.c **** #else
 122:../src/RTOS/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 123:../src/RTOS/queue.c **** #endif
 124:../src/RTOS/queue.c **** 
 125:../src/RTOS/queue.c **** /*
 126:../src/RTOS/queue.c ****  * Definition of the queue used by the scheduler.
 127:../src/RTOS/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
 128:../src/RTOS/queue.c ****  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
 129:../src/RTOS/queue.c ****  */
 130:../src/RTOS/queue.c **** typedef struct QueueDefinition
 131:../src/RTOS/queue.c **** {
 132:../src/RTOS/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 133:../src/RTOS/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
 134:../src/RTOS/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 135:../src/RTOS/queue.c **** 
 136:../src/RTOS/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
 137:../src/RTOS/queue.c **** 	{
 138:../src/RTOS/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
 139:../src/RTOS/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
 140:../src/RTOS/queue.c **** 	} u;
 141:../src/RTOS/queue.c **** 
 142:../src/RTOS/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 143:../src/RTOS/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 144:../src/RTOS/queue.c **** 
 145:../src/RTOS/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 146:../src/RTOS/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 147:../src/RTOS/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 148:../src/RTOS/queue.c **** 
 149:../src/RTOS/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 150:../src/RTOS/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 151:../src/RTOS/queue.c **** 
 152:../src/RTOS/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 153:../src/RTOS/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 154:../src/RTOS/queue.c **** 	#endif
 155:../src/RTOS/queue.c **** 
 156:../src/RTOS/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 157:../src/RTOS/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 158:../src/RTOS/queue.c **** 	#endif
 159:../src/RTOS/queue.c **** 
 160:../src/RTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 161:../src/RTOS/queue.c **** 		UBaseType_t uxQueueNumber;
 162:../src/RTOS/queue.c **** 		uint8_t ucQueueType;
 163:../src/RTOS/queue.c **** 	#endif
 164:../src/RTOS/queue.c **** 
 165:../src/RTOS/queue.c **** } xQUEUE;
 166:../src/RTOS/queue.c **** 
 167:../src/RTOS/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 168:../src/RTOS/queue.c **** name below to enable the use of older kernel aware debuggers. */
 169:../src/RTOS/queue.c **** typedef xQUEUE Queue_t;
 170:../src/RTOS/queue.c **** 
 171:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 172:../src/RTOS/queue.c **** 
 173:../src/RTOS/queue.c **** /*
 174:../src/RTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 175:../src/RTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 176:../src/RTOS/queue.c ****  */
 177:../src/RTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 178:../src/RTOS/queue.c **** 
 179:../src/RTOS/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 180:../src/RTOS/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 181:../src/RTOS/queue.c **** 	more user friendly. */
 182:../src/RTOS/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 183:../src/RTOS/queue.c **** 	{
 184:../src/RTOS/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 185:../src/RTOS/queue.c **** 		QueueHandle_t xHandle;
 186:../src/RTOS/queue.c **** 	} xQueueRegistryItem;
 187:../src/RTOS/queue.c **** 
 188:../src/RTOS/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 189:../src/RTOS/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 190:../src/RTOS/queue.c **** 	debuggers. */
 191:../src/RTOS/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 192:../src/RTOS/queue.c **** 
 193:../src/RTOS/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 194:../src/RTOS/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 195:../src/RTOS/queue.c **** 	array position being vacant. */
 196:../src/RTOS/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 197:../src/RTOS/queue.c **** 
 198:../src/RTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 199:../src/RTOS/queue.c **** 
 200:../src/RTOS/queue.c **** /*
 201:../src/RTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 202:../src/RTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 203:../src/RTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 204:../src/RTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 205:../src/RTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 206:../src/RTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 207:../src/RTOS/queue.c ****  */
 208:../src/RTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 209:../src/RTOS/queue.c **** 
 210:../src/RTOS/queue.c **** /*
 211:../src/RTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 212:../src/RTOS/queue.c ****  *
 213:../src/RTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 214:../src/RTOS/queue.c ****  */
 215:../src/RTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 216:../src/RTOS/queue.c **** 
 217:../src/RTOS/queue.c **** /*
 218:../src/RTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 219:../src/RTOS/queue.c ****  *
 220:../src/RTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 221:../src/RTOS/queue.c ****  */
 222:../src/RTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 223:../src/RTOS/queue.c **** 
 224:../src/RTOS/queue.c **** /*
 225:../src/RTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 226:../src/RTOS/queue.c ****  * back of the queue.
 227:../src/RTOS/queue.c ****  */
 228:../src/RTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 229:../src/RTOS/queue.c **** 
 230:../src/RTOS/queue.c **** /*
 231:../src/RTOS/queue.c ****  * Copies an item out of a queue.
 232:../src/RTOS/queue.c ****  */
 233:../src/RTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 234:../src/RTOS/queue.c **** 
 235:../src/RTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 236:../src/RTOS/queue.c **** 	/*
 237:../src/RTOS/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 238:../src/RTOS/queue.c **** 	 * the queue set that the queue contains data.
 239:../src/RTOS/queue.c **** 	 */
 240:../src/RTOS/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 241:../src/RTOS/queue.c **** #endif
 242:../src/RTOS/queue.c **** 
 243:../src/RTOS/queue.c **** /*
 244:../src/RTOS/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 245:../src/RTOS/queue.c ****  * dynamically to fill in the structure's members.
 246:../src/RTOS/queue.c ****  */
 247:../src/RTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 248:../src/RTOS/queue.c **** 
 249:../src/RTOS/queue.c **** /*
 250:../src/RTOS/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 251:../src/RTOS/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 252:../src/RTOS/queue.c ****  * as a mutex.
 253:../src/RTOS/queue.c ****  */
 254:../src/RTOS/queue.c **** static void prvInitialiseMutex( Queue_t *pxNewQueue );
 255:../src/RTOS/queue.c **** 
 256:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 257:../src/RTOS/queue.c **** 
 258:../src/RTOS/queue.c **** /*
 259:../src/RTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 260:../src/RTOS/queue.c ****  * accessing the queue event lists.
 261:../src/RTOS/queue.c ****  */
 262:../src/RTOS/queue.c **** #define prvLockQueue( pxQueue )								\
 263:../src/RTOS/queue.c **** 	taskENTER_CRITICAL();									\
 264:../src/RTOS/queue.c **** 	{														\
 265:../src/RTOS/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 266:../src/RTOS/queue.c **** 		{													\
 267:../src/RTOS/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 268:../src/RTOS/queue.c **** 		}													\
 269:../src/RTOS/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 270:../src/RTOS/queue.c **** 		{													\
 271:../src/RTOS/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 272:../src/RTOS/queue.c **** 		}													\
 273:../src/RTOS/queue.c **** 	}														\
 274:../src/RTOS/queue.c **** 	taskEXIT_CRITICAL()
 275:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 276:../src/RTOS/queue.c **** 
 277:../src/RTOS/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 278:../src/RTOS/queue.c **** {
  28              		.loc 1 278 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 16
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32 0000 80B5     		push	{r7, lr}
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 84B0     		sub	sp, sp, #16
  37              		.cfi_def_cfa_offset 24
  38 0004 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
  40 0006 7860     		str	r0, [r7, #4]
  41 0008 3960     		str	r1, [r7]
 279:../src/RTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  42              		.loc 1 279 0
  43 000a 7B68     		ldr	r3, [r7, #4]
  44 000c FB60     		str	r3, [r7, #12]
 280:../src/RTOS/queue.c **** 
 281:../src/RTOS/queue.c **** 	configASSERT( pxQueue );
  45              		.loc 1 281 0
  46 000e FB68     		ldr	r3, [r7, #12]
  47 0010 002B     		cmp	r3, #0
  48 0012 00D1     		bne	.L2
  49              	.L3:
  50              		.loc 1 281 0 is_stmt 0 discriminator 1
  51 0014 FEE7     		b	.L3
  52              	.L2:
 282:../src/RTOS/queue.c **** 
 283:../src/RTOS/queue.c **** 	taskENTER_CRITICAL();
  53              		.loc 1 283 0 is_stmt 1
  54 0016 FFF7FEFF 		bl	vPortEnterCritical
 284:../src/RTOS/queue.c **** 	{
 285:../src/RTOS/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  55              		.loc 1 285 0
  56 001a FB68     		ldr	r3, [r7, #12]
  57 001c 1A68     		ldr	r2, [r3]
  58 001e FB68     		ldr	r3, [r7, #12]
  59 0020 DB6B     		ldr	r3, [r3, #60]
  60 0022 F968     		ldr	r1, [r7, #12]
  61 0024 096C     		ldr	r1, [r1, #64]
  62 0026 01FB03F3 		mul	r3, r1, r3
  63 002a 1A44     		add	r2, r2, r3
  64 002c FB68     		ldr	r3, [r7, #12]
  65 002e 5A60     		str	r2, [r3, #4]
 286:../src/RTOS/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  66              		.loc 1 286 0
  67 0030 FB68     		ldr	r3, [r7, #12]
  68 0032 0022     		movs	r2, #0
  69 0034 9A63     		str	r2, [r3, #56]
 287:../src/RTOS/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  70              		.loc 1 287 0
  71 0036 FB68     		ldr	r3, [r7, #12]
  72 0038 1A68     		ldr	r2, [r3]
  73 003a FB68     		ldr	r3, [r7, #12]
  74 003c 9A60     		str	r2, [r3, #8]
 288:../src/RTOS/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
  75              		.loc 1 288 0
  76 003e FB68     		ldr	r3, [r7, #12]
  77 0040 1A68     		ldr	r2, [r3]
  78 0042 FB68     		ldr	r3, [r7, #12]
  79 0044 DB6B     		ldr	r3, [r3, #60]
  80 0046 013B     		subs	r3, r3, #1
  81 0048 F968     		ldr	r1, [r7, #12]
  82 004a 096C     		ldr	r1, [r1, #64]
  83 004c 01FB03F3 		mul	r3, r1, r3
  84 0050 1A44     		add	r2, r2, r3
  85 0052 FB68     		ldr	r3, [r7, #12]
  86 0054 DA60     		str	r2, [r3, #12]
 289:../src/RTOS/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
  87              		.loc 1 289 0
  88 0056 FB68     		ldr	r3, [r7, #12]
  89 0058 FF22     		movs	r2, #255
  90 005a 83F84420 		strb	r2, [r3, #68]
 290:../src/RTOS/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
  91              		.loc 1 290 0
  92 005e FB68     		ldr	r3, [r7, #12]
  93 0060 FF22     		movs	r2, #255
  94 0062 83F84520 		strb	r2, [r3, #69]
 291:../src/RTOS/queue.c **** 
 292:../src/RTOS/queue.c **** 		if( xNewQueue == pdFALSE )
  95              		.loc 1 292 0
  96 0066 3B68     		ldr	r3, [r7]
  97 0068 002B     		cmp	r3, #0
  98 006a 14D1     		bne	.L4
 293:../src/RTOS/queue.c **** 		{
 294:../src/RTOS/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 295:../src/RTOS/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 296:../src/RTOS/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 297:../src/RTOS/queue.c **** 			the queue, then one should be unblocked as after this function exits
 298:../src/RTOS/queue.c **** 			it will be possible to write to it. */
 299:../src/RTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  99              		.loc 1 299 0
 100 006c FB68     		ldr	r3, [r7, #12]
 101 006e 1B69     		ldr	r3, [r3, #16]
 102 0070 002B     		cmp	r3, #0
 103 0072 1AD0     		beq	.L5
 300:../src/RTOS/queue.c **** 			{
 301:../src/RTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 104              		.loc 1 301 0
 105 0074 FB68     		ldr	r3, [r7, #12]
 106 0076 1033     		adds	r3, r3, #16
 107 0078 1846     		mov	r0, r3
 108 007a FFF7FEFF 		bl	xTaskRemoveFromEventList
 109 007e 0346     		mov	r3, r0
 110 0080 002B     		cmp	r3, #0
 111 0082 12D0     		beq	.L5
 302:../src/RTOS/queue.c **** 				{
 303:../src/RTOS/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 112              		.loc 1 303 0
 113 0084 0C4B     		ldr	r3, .L7
 114 0086 4FF08052 		mov	r2, #268435456
 115 008a 1A60     		str	r2, [r3]
 116              	@ 303 "../src/RTOS/queue.c" 1
 117 008c BFF34F8F 		dsb
 118              	@ 0 "" 2
 119              	@ 303 "../src/RTOS/queue.c" 1
 120 0090 BFF36F8F 		isb
 121              	@ 0 "" 2
 122              		.thumb
 123 0094 09E0     		b	.L5
 124              	.L4:
 304:../src/RTOS/queue.c **** 				}
 305:../src/RTOS/queue.c **** 				else
 306:../src/RTOS/queue.c **** 				{
 307:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 308:../src/RTOS/queue.c **** 				}
 309:../src/RTOS/queue.c **** 			}
 310:../src/RTOS/queue.c **** 			else
 311:../src/RTOS/queue.c **** 			{
 312:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 313:../src/RTOS/queue.c **** 			}
 314:../src/RTOS/queue.c **** 		}
 315:../src/RTOS/queue.c **** 		else
 316:../src/RTOS/queue.c **** 		{
 317:../src/RTOS/queue.c **** 			/* Ensure the event queues start in the correct state. */
 318:../src/RTOS/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 125              		.loc 1 318 0
 126 0096 FB68     		ldr	r3, [r7, #12]
 127 0098 1033     		adds	r3, r3, #16
 128 009a 1846     		mov	r0, r3
 129 009c FFF7FEFF 		bl	vListInitialise
 319:../src/RTOS/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 130              		.loc 1 319 0
 131 00a0 FB68     		ldr	r3, [r7, #12]
 132 00a2 2433     		adds	r3, r3, #36
 133 00a4 1846     		mov	r0, r3
 134 00a6 FFF7FEFF 		bl	vListInitialise
 135              	.L5:
 320:../src/RTOS/queue.c **** 		}
 321:../src/RTOS/queue.c **** 	}
 322:../src/RTOS/queue.c **** 	taskEXIT_CRITICAL();
 136              		.loc 1 322 0
 137 00aa FFF7FEFF 		bl	vPortExitCritical
 323:../src/RTOS/queue.c **** 
 324:../src/RTOS/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 325:../src/RTOS/queue.c **** 	versions. */
 326:../src/RTOS/queue.c **** 	return pdPASS;
 138              		.loc 1 326 0
 139 00ae 0123     		movs	r3, #1
 327:../src/RTOS/queue.c **** }
 140              		.loc 1 327 0
 141 00b0 1846     		mov	r0, r3
 142 00b2 1037     		adds	r7, r7, #16
 143              		.cfi_def_cfa_offset 8
 144 00b4 BD46     		mov	sp, r7
 145              		.cfi_def_cfa_register 13
 146              		@ sp needed
 147 00b6 80BD     		pop	{r7, pc}
 148              	.L8:
 149              		.align	2
 150              	.L7:
 151 00b8 04ED00E0 		.word	-536810236
 152              		.cfi_endproc
 153              	.LFE4:
 155              		.section	.text.xQueueGenericCreate,"ax",%progbits
 156              		.align	2
 157              		.global	xQueueGenericCreate
 158              		.thumb
 159              		.thumb_func
 161              	xQueueGenericCreate:
 162              	.LFB5:
 328:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 329:../src/RTOS/queue.c **** 
 330:../src/RTOS/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 331:../src/RTOS/queue.c **** 
 332:../src/RTOS/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 333:../src/RTOS/queue.c **** 	{
 334:../src/RTOS/queue.c **** 	Queue_t *pxNewQueue;
 335:../src/RTOS/queue.c **** 
 336:../src/RTOS/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 337:../src/RTOS/queue.c **** 
 338:../src/RTOS/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 339:../src/RTOS/queue.c **** 		supplied. */
 340:../src/RTOS/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 341:../src/RTOS/queue.c **** 
 342:../src/RTOS/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 343:../src/RTOS/queue.c **** 		should not be provided if the item size is 0. */
 344:../src/RTOS/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 345:../src/RTOS/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 346:../src/RTOS/queue.c **** 
 347:../src/RTOS/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 348:../src/RTOS/queue.c **** 		{
 349:../src/RTOS/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 350:../src/RTOS/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 351:../src/RTOS/queue.c **** 			the real queue and semaphore structures. */
 352:../src/RTOS/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 353:../src/RTOS/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 354:../src/RTOS/queue.c **** 		}
 355:../src/RTOS/queue.c **** 		#endif /* configASSERT_DEFINED */
 356:../src/RTOS/queue.c **** 
 357:../src/RTOS/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 358:../src/RTOS/queue.c **** 		The address of a statically allocated storage area was also passed in
 359:../src/RTOS/queue.c **** 		but is already set. */
 360:../src/RTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are d
 361:../src/RTOS/queue.c **** 
 362:../src/RTOS/queue.c **** 		if( pxNewQueue != NULL )
 363:../src/RTOS/queue.c **** 		{
 364:../src/RTOS/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 365:../src/RTOS/queue.c **** 			{
 366:../src/RTOS/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 367:../src/RTOS/queue.c **** 				note this queue was allocated statically in case the queue is
 368:../src/RTOS/queue.c **** 				later deleted. */
 369:../src/RTOS/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 370:../src/RTOS/queue.c **** 			}
 371:../src/RTOS/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 372:../src/RTOS/queue.c **** 
 373:../src/RTOS/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 374:../src/RTOS/queue.c **** 		}
 375:../src/RTOS/queue.c **** 
 376:../src/RTOS/queue.c **** 		return pxNewQueue;
 377:../src/RTOS/queue.c **** 	}
 378:../src/RTOS/queue.c **** 
 379:../src/RTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 380:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 381:../src/RTOS/queue.c **** 
 382:../src/RTOS/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 383:../src/RTOS/queue.c **** 
 384:../src/RTOS/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 385:../src/RTOS/queue.c **** 	{
 163              		.loc 1 385 0
 164              		.cfi_startproc
 165              		@ args = 0, pretend = 0, frame = 32
 166              		@ frame_needed = 1, uses_anonymous_args = 0
 167 0000 90B5     		push	{r4, r7, lr}
 168              		.cfi_def_cfa_offset 12
 169              		.cfi_offset 4, -12
 170              		.cfi_offset 7, -8
 171              		.cfi_offset 14, -4
 172 0002 8BB0     		sub	sp, sp, #44
 173              		.cfi_def_cfa_offset 56
 174 0004 02AF     		add	r7, sp, #8
 175              		.cfi_def_cfa 7, 48
 176 0006 F860     		str	r0, [r7, #12]
 177 0008 B960     		str	r1, [r7, #8]
 178 000a 1346     		mov	r3, r2
 179 000c FB71     		strb	r3, [r7, #7]
 386:../src/RTOS/queue.c **** 	Queue_t *pxNewQueue;
 387:../src/RTOS/queue.c **** 	size_t xQueueSizeInBytes;
 388:../src/RTOS/queue.c **** 	uint8_t *pucQueueStorage;
 389:../src/RTOS/queue.c **** 
 390:../src/RTOS/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 180              		.loc 1 390 0
 181 000e FB68     		ldr	r3, [r7, #12]
 182 0010 002B     		cmp	r3, #0
 183 0012 00D1     		bne	.L10
 184              	.L11:
 185              		.loc 1 390 0 is_stmt 0 discriminator 1
 186 0014 FEE7     		b	.L11
 187              	.L10:
 391:../src/RTOS/queue.c **** 
 392:../src/RTOS/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 188              		.loc 1 392 0 is_stmt 1
 189 0016 BB68     		ldr	r3, [r7, #8]
 190 0018 002B     		cmp	r3, #0
 191 001a 02D1     		bne	.L12
 393:../src/RTOS/queue.c **** 		{
 394:../src/RTOS/queue.c **** 			/* There is not going to be a queue storage area. */
 395:../src/RTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 192              		.loc 1 395 0
 193 001c 0023     		movs	r3, #0
 194 001e FB61     		str	r3, [r7, #28]
 195 0020 04E0     		b	.L13
 196              	.L12:
 396:../src/RTOS/queue.c **** 		}
 397:../src/RTOS/queue.c **** 		else
 398:../src/RTOS/queue.c **** 		{
 399:../src/RTOS/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 400:../src/RTOS/queue.c **** 			can be in the queue at any time. */
 401:../src/RTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 197              		.loc 1 401 0
 198 0022 FB68     		ldr	r3, [r7, #12]
 199 0024 BA68     		ldr	r2, [r7, #8]
 200 0026 02FB03F3 		mul	r3, r2, r3
 201 002a FB61     		str	r3, [r7, #28]
 202              	.L13:
 402:../src/RTOS/queue.c **** 		}
 403:../src/RTOS/queue.c **** 
 404:../src/RTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 203              		.loc 1 404 0
 204 002c FB69     		ldr	r3, [r7, #28]
 205 002e 4833     		adds	r3, r3, #72
 206 0030 1846     		mov	r0, r3
 207 0032 FFF7FEFF 		bl	pvPortMalloc
 208 0036 B861     		str	r0, [r7, #24]
 405:../src/RTOS/queue.c **** 
 406:../src/RTOS/queue.c **** 		if( pxNewQueue != NULL )
 209              		.loc 1 406 0
 210 0038 BB69     		ldr	r3, [r7, #24]
 211 003a 002B     		cmp	r3, #0
 212 003c 0BD0     		beq	.L14
 407:../src/RTOS/queue.c **** 		{
 408:../src/RTOS/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 409:../src/RTOS/queue.c **** 			storage area. */
 410:../src/RTOS/queue.c **** 			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 213              		.loc 1 410 0
 214 003e BB69     		ldr	r3, [r7, #24]
 215 0040 4833     		adds	r3, r3, #72
 216 0042 7B61     		str	r3, [r7, #20]
 411:../src/RTOS/queue.c **** 
 412:../src/RTOS/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 413:../src/RTOS/queue.c **** 			{
 414:../src/RTOS/queue.c **** 				/* Queues can be created either statically or dynamically, so
 415:../src/RTOS/queue.c **** 				note this task was created dynamically in case it is later
 416:../src/RTOS/queue.c **** 				deleted. */
 417:../src/RTOS/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 418:../src/RTOS/queue.c **** 			}
 419:../src/RTOS/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 420:../src/RTOS/queue.c **** 
 421:../src/RTOS/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 217              		.loc 1 421 0
 218 0044 FC79     		ldrb	r4, [r7, #7]	@ zero_extendqisi2
 219 0046 BB69     		ldr	r3, [r7, #24]
 220 0048 0093     		str	r3, [sp]
 221 004a F868     		ldr	r0, [r7, #12]
 222 004c B968     		ldr	r1, [r7, #8]
 223 004e 7A69     		ldr	r2, [r7, #20]
 224 0050 2346     		mov	r3, r4
 225 0052 FFF7FEFF 		bl	prvInitialiseNewQueue
 226              	.L14:
 422:../src/RTOS/queue.c **** 		}
 423:../src/RTOS/queue.c **** 
 424:../src/RTOS/queue.c **** 		return pxNewQueue;
 227              		.loc 1 424 0
 228 0056 BB69     		ldr	r3, [r7, #24]
 425:../src/RTOS/queue.c **** 	}
 229              		.loc 1 425 0
 230 0058 1846     		mov	r0, r3
 231 005a 2437     		adds	r7, r7, #36
 232              		.cfi_def_cfa_offset 12
 233 005c BD46     		mov	sp, r7
 234              		.cfi_def_cfa_register 13
 235              		@ sp needed
 236 005e 90BD     		pop	{r4, r7, pc}
 237              		.cfi_endproc
 238              	.LFE5:
 240              		.section	.text.prvInitialiseNewQueue,"ax",%progbits
 241              		.align	2
 242              		.thumb
 243              		.thumb_func
 245              	prvInitialiseNewQueue:
 246              	.LFB6:
 426:../src/RTOS/queue.c **** 
 427:../src/RTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 428:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 429:../src/RTOS/queue.c **** 
 430:../src/RTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 431:../src/RTOS/queue.c **** {
 247              		.loc 1 431 0
 248              		.cfi_startproc
 249              		@ args = 4, pretend = 0, frame = 16
 250              		@ frame_needed = 1, uses_anonymous_args = 0
 251 0000 80B5     		push	{r7, lr}
 252              		.cfi_def_cfa_offset 8
 253              		.cfi_offset 7, -8
 254              		.cfi_offset 14, -4
 255 0002 84B0     		sub	sp, sp, #16
 256              		.cfi_def_cfa_offset 24
 257 0004 00AF     		add	r7, sp, #0
 258              		.cfi_def_cfa_register 7
 259 0006 F860     		str	r0, [r7, #12]
 260 0008 B960     		str	r1, [r7, #8]
 261 000a 7A60     		str	r2, [r7, #4]
 262 000c FB70     		strb	r3, [r7, #3]
 432:../src/RTOS/queue.c **** 	/* Remove compiler warnings about unused parameters should
 433:../src/RTOS/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 434:../src/RTOS/queue.c **** 	( void ) ucQueueType;
 435:../src/RTOS/queue.c **** 
 436:../src/RTOS/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 263              		.loc 1 436 0
 264 000e BB68     		ldr	r3, [r7, #8]
 265 0010 002B     		cmp	r3, #0
 266 0012 03D1     		bne	.L17
 437:../src/RTOS/queue.c **** 	{
 438:../src/RTOS/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 439:../src/RTOS/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 440:../src/RTOS/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 441:../src/RTOS/queue.c **** 		value that is known to be within the memory map. */
 442:../src/RTOS/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 267              		.loc 1 442 0
 268 0014 BB69     		ldr	r3, [r7, #24]
 269 0016 BA69     		ldr	r2, [r7, #24]
 270 0018 1A60     		str	r2, [r3]
 271 001a 02E0     		b	.L18
 272              	.L17:
 443:../src/RTOS/queue.c **** 	}
 444:../src/RTOS/queue.c **** 	else
 445:../src/RTOS/queue.c **** 	{
 446:../src/RTOS/queue.c **** 		/* Set the head to the start of the queue storage area. */
 447:../src/RTOS/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 273              		.loc 1 447 0
 274 001c BB69     		ldr	r3, [r7, #24]
 275 001e 7A68     		ldr	r2, [r7, #4]
 276 0020 1A60     		str	r2, [r3]
 277              	.L18:
 448:../src/RTOS/queue.c **** 	}
 449:../src/RTOS/queue.c **** 
 450:../src/RTOS/queue.c **** 	/* Initialise the queue members as described where the queue type is
 451:../src/RTOS/queue.c **** 	defined. */
 452:../src/RTOS/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 278              		.loc 1 452 0
 279 0022 BB69     		ldr	r3, [r7, #24]
 280 0024 FA68     		ldr	r2, [r7, #12]
 281 0026 DA63     		str	r2, [r3, #60]
 453:../src/RTOS/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 282              		.loc 1 453 0
 283 0028 BB69     		ldr	r3, [r7, #24]
 284 002a BA68     		ldr	r2, [r7, #8]
 285 002c 1A64     		str	r2, [r3, #64]
 454:../src/RTOS/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 286              		.loc 1 454 0
 287 002e B869     		ldr	r0, [r7, #24]
 288 0030 0121     		movs	r1, #1
 289 0032 FFF7FEFF 		bl	xQueueGenericReset
 455:../src/RTOS/queue.c **** 
 456:../src/RTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 457:../src/RTOS/queue.c **** 	{
 458:../src/RTOS/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 459:../src/RTOS/queue.c **** 	}
 460:../src/RTOS/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 461:../src/RTOS/queue.c **** 
 462:../src/RTOS/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 463:../src/RTOS/queue.c **** 	{
 464:../src/RTOS/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 465:../src/RTOS/queue.c **** 	}
 466:../src/RTOS/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 467:../src/RTOS/queue.c **** 
 468:../src/RTOS/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 469:../src/RTOS/queue.c **** }
 290              		.loc 1 469 0
 291 0036 1037     		adds	r7, r7, #16
 292              		.cfi_def_cfa_offset 8
 293 0038 BD46     		mov	sp, r7
 294              		.cfi_def_cfa_register 13
 295              		@ sp needed
 296 003a 80BD     		pop	{r7, pc}
 297              		.cfi_endproc
 298              	.LFE6:
 300              		.section	.text.prvInitialiseMutex,"ax",%progbits
 301              		.align	2
 302              		.thumb
 303              		.thumb_func
 305              	prvInitialiseMutex:
 306              	.LFB7:
 470:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 471:../src/RTOS/queue.c **** 
 472:../src/RTOS/queue.c **** static void prvInitialiseMutex( Queue_t *pxNewQueue )
 473:../src/RTOS/queue.c **** {
 307              		.loc 1 473 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 8
 310              		@ frame_needed = 1, uses_anonymous_args = 0
 311 0000 80B5     		push	{r7, lr}
 312              		.cfi_def_cfa_offset 8
 313              		.cfi_offset 7, -8
 314              		.cfi_offset 14, -4
 315 0002 82B0     		sub	sp, sp, #8
 316              		.cfi_def_cfa_offset 16
 317 0004 00AF     		add	r7, sp, #0
 318              		.cfi_def_cfa_register 7
 319 0006 7860     		str	r0, [r7, #4]
 474:../src/RTOS/queue.c **** 	if( pxNewQueue != NULL )
 320              		.loc 1 474 0
 321 0008 7B68     		ldr	r3, [r7, #4]
 322 000a 002B     		cmp	r3, #0
 323 000c 0ED0     		beq	.L19
 475:../src/RTOS/queue.c **** 	{
 476:../src/RTOS/queue.c **** 		/* The queue create function will set all the queue structure members
 477:../src/RTOS/queue.c **** 		correctly for a generic queue, but this function is creating a
 478:../src/RTOS/queue.c **** 		mutex.  Overwrite those members that need to be set differently -
 479:../src/RTOS/queue.c **** 		in particular the information required for priority inheritance. */
 480:../src/RTOS/queue.c **** 		pxNewQueue->pxMutexHolder = NULL;
 324              		.loc 1 480 0
 325 000e 7B68     		ldr	r3, [r7, #4]
 326 0010 0022     		movs	r2, #0
 327 0012 5A60     		str	r2, [r3, #4]
 481:../src/RTOS/queue.c **** 		pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 328              		.loc 1 481 0
 329 0014 7B68     		ldr	r3, [r7, #4]
 330 0016 0022     		movs	r2, #0
 331 0018 1A60     		str	r2, [r3]
 482:../src/RTOS/queue.c **** 
 483:../src/RTOS/queue.c **** 		/* In case this is a recursive mutex. */
 484:../src/RTOS/queue.c **** 		pxNewQueue->u.uxRecursiveCallCount = 0;
 332              		.loc 1 484 0
 333 001a 7B68     		ldr	r3, [r7, #4]
 334 001c 0022     		movs	r2, #0
 335 001e DA60     		str	r2, [r3, #12]
 485:../src/RTOS/queue.c **** 
 486:../src/RTOS/queue.c **** 		traceCREATE_MUTEX( pxNewQueue );
 487:../src/RTOS/queue.c **** 
 488:../src/RTOS/queue.c **** 		/* Start with the semaphore in the expected state. */
 489:../src/RTOS/queue.c **** 		( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 336              		.loc 1 489 0
 337 0020 7868     		ldr	r0, [r7, #4]
 338 0022 0021     		movs	r1, #0
 339 0024 0022     		movs	r2, #0
 340 0026 0023     		movs	r3, #0
 341 0028 FFF7FEFF 		bl	xQueueGenericSend
 342              	.L19:
 490:../src/RTOS/queue.c **** 	}
 491:../src/RTOS/queue.c **** 	else
 492:../src/RTOS/queue.c **** 	{
 493:../src/RTOS/queue.c **** 		traceCREATE_MUTEX_FAILED();
 494:../src/RTOS/queue.c **** 	}
 495:../src/RTOS/queue.c **** }
 343              		.loc 1 495 0
 344 002c 0837     		adds	r7, r7, #8
 345              		.cfi_def_cfa_offset 8
 346 002e BD46     		mov	sp, r7
 347              		.cfi_def_cfa_register 13
 348              		@ sp needed
 349 0030 80BD     		pop	{r7, pc}
 350              		.cfi_endproc
 351              	.LFE7:
 353 0032 00BF     		.section	.text.xQueueCreateMutex,"ax",%progbits
 354              		.align	2
 355              		.global	xQueueCreateMutex
 356              		.thumb
 357              		.thumb_func
 359              	xQueueCreateMutex:
 360              	.LFB8:
 496:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 497:../src/RTOS/queue.c **** 
 498:../src/RTOS/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 499:../src/RTOS/queue.c **** 
 500:../src/RTOS/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 501:../src/RTOS/queue.c **** 	{
 361              		.loc 1 501 0
 362              		.cfi_startproc
 363              		@ args = 0, pretend = 0, frame = 24
 364              		@ frame_needed = 1, uses_anonymous_args = 0
 365 0000 80B5     		push	{r7, lr}
 366              		.cfi_def_cfa_offset 8
 367              		.cfi_offset 7, -8
 368              		.cfi_offset 14, -4
 369 0002 86B0     		sub	sp, sp, #24
 370              		.cfi_def_cfa_offset 32
 371 0004 00AF     		add	r7, sp, #0
 372              		.cfi_def_cfa_register 7
 373 0006 0346     		mov	r3, r0
 374 0008 FB71     		strb	r3, [r7, #7]
 502:../src/RTOS/queue.c **** 	Queue_t *pxNewQueue;
 503:../src/RTOS/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 375              		.loc 1 503 0
 376 000a 0123     		movs	r3, #1
 377 000c 7B61     		str	r3, [r7, #20]
 378 000e 0023     		movs	r3, #0
 379 0010 3B61     		str	r3, [r7, #16]
 504:../src/RTOS/queue.c **** 
 505:../src/RTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 380              		.loc 1 505 0
 381 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 382 0014 7869     		ldr	r0, [r7, #20]
 383 0016 3969     		ldr	r1, [r7, #16]
 384 0018 1A46     		mov	r2, r3
 385 001a FFF7FEFF 		bl	xQueueGenericCreate
 386 001e F860     		str	r0, [r7, #12]
 506:../src/RTOS/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 387              		.loc 1 506 0
 388 0020 F868     		ldr	r0, [r7, #12]
 389 0022 FFF7FEFF 		bl	prvInitialiseMutex
 507:../src/RTOS/queue.c **** 
 508:../src/RTOS/queue.c **** 		return pxNewQueue;
 390              		.loc 1 508 0
 391 0026 FB68     		ldr	r3, [r7, #12]
 509:../src/RTOS/queue.c **** 	}
 392              		.loc 1 509 0
 393 0028 1846     		mov	r0, r3
 394 002a 1837     		adds	r7, r7, #24
 395              		.cfi_def_cfa_offset 8
 396 002c BD46     		mov	sp, r7
 397              		.cfi_def_cfa_register 13
 398              		@ sp needed
 399 002e 80BD     		pop	{r7, pc}
 400              		.cfi_endproc
 401              	.LFE8:
 403              		.section	.text.xQueueGenericSend,"ax",%progbits
 404              		.align	2
 405              		.global	xQueueGenericSend
 406              		.thumb
 407              		.thumb_func
 409              	xQueueGenericSend:
 410              	.LFB9:
 510:../src/RTOS/queue.c **** 
 511:../src/RTOS/queue.c **** #endif /* configUSE_MUTEXES */
 512:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 513:../src/RTOS/queue.c **** 
 514:../src/RTOS/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 515:../src/RTOS/queue.c **** 
 516:../src/RTOS/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 517:../src/RTOS/queue.c **** 	{
 518:../src/RTOS/queue.c **** 	Queue_t *pxNewQueue;
 519:../src/RTOS/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 520:../src/RTOS/queue.c **** 
 521:../src/RTOS/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 522:../src/RTOS/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 523:../src/RTOS/queue.c **** 		( void ) ucQueueType;
 524:../src/RTOS/queue.c **** 
 525:../src/RTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQ
 526:../src/RTOS/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 527:../src/RTOS/queue.c **** 
 528:../src/RTOS/queue.c **** 		return pxNewQueue;
 529:../src/RTOS/queue.c **** 	}
 530:../src/RTOS/queue.c **** 
 531:../src/RTOS/queue.c **** #endif /* configUSE_MUTEXES */
 532:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 533:../src/RTOS/queue.c **** 
 534:../src/RTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 535:../src/RTOS/queue.c **** 
 536:../src/RTOS/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 537:../src/RTOS/queue.c **** 	{
 538:../src/RTOS/queue.c **** 	void *pxReturn;
 539:../src/RTOS/queue.c **** 
 540:../src/RTOS/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 541:../src/RTOS/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 542:../src/RTOS/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 543:../src/RTOS/queue.c **** 		identity of the mutex holder, as the holder may change between the
 544:../src/RTOS/queue.c **** 		following critical section exiting and the function returning. */
 545:../src/RTOS/queue.c **** 		taskENTER_CRITICAL();
 546:../src/RTOS/queue.c **** 		{
 547:../src/RTOS/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 548:../src/RTOS/queue.c **** 			{
 549:../src/RTOS/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 550:../src/RTOS/queue.c **** 			}
 551:../src/RTOS/queue.c **** 			else
 552:../src/RTOS/queue.c **** 			{
 553:../src/RTOS/queue.c **** 				pxReturn = NULL;
 554:../src/RTOS/queue.c **** 			}
 555:../src/RTOS/queue.c **** 		}
 556:../src/RTOS/queue.c **** 		taskEXIT_CRITICAL();
 557:../src/RTOS/queue.c **** 
 558:../src/RTOS/queue.c **** 		return pxReturn;
 559:../src/RTOS/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 560:../src/RTOS/queue.c **** 
 561:../src/RTOS/queue.c **** #endif
 562:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 563:../src/RTOS/queue.c **** 
 564:../src/RTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 565:../src/RTOS/queue.c **** 
 566:../src/RTOS/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 567:../src/RTOS/queue.c **** 	{
 568:../src/RTOS/queue.c **** 	BaseType_t xReturn;
 569:../src/RTOS/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 570:../src/RTOS/queue.c **** 
 571:../src/RTOS/queue.c **** 		configASSERT( pxMutex );
 572:../src/RTOS/queue.c **** 
 573:../src/RTOS/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 574:../src/RTOS/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 575:../src/RTOS/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 576:../src/RTOS/queue.c **** 		this is the only condition we are interested in it does not matter if
 577:../src/RTOS/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 578:../src/RTOS/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 579:../src/RTOS/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 580:../src/RTOS/queue.c **** 		{
 581:../src/RTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 582:../src/RTOS/queue.c **** 
 583:../src/RTOS/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 584:../src/RTOS/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 585:../src/RTOS/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 586:../src/RTOS/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 587:../src/RTOS/queue.c **** 			uxRecursiveCallCount member. */
 588:../src/RTOS/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 589:../src/RTOS/queue.c **** 
 590:../src/RTOS/queue.c **** 			/* Has the recursive call count unwound to 0? */
 591:../src/RTOS/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 592:../src/RTOS/queue.c **** 			{
 593:../src/RTOS/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 594:../src/RTOS/queue.c **** 				task that might be waiting to access the mutex. */
 595:../src/RTOS/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 596:../src/RTOS/queue.c **** 			}
 597:../src/RTOS/queue.c **** 			else
 598:../src/RTOS/queue.c **** 			{
 599:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 600:../src/RTOS/queue.c **** 			}
 601:../src/RTOS/queue.c **** 
 602:../src/RTOS/queue.c **** 			xReturn = pdPASS;
 603:../src/RTOS/queue.c **** 		}
 604:../src/RTOS/queue.c **** 		else
 605:../src/RTOS/queue.c **** 		{
 606:../src/RTOS/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 607:../src/RTOS/queue.c **** 			holder. */
 608:../src/RTOS/queue.c **** 			xReturn = pdFAIL;
 609:../src/RTOS/queue.c **** 
 610:../src/RTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 611:../src/RTOS/queue.c **** 		}
 612:../src/RTOS/queue.c **** 
 613:../src/RTOS/queue.c **** 		return xReturn;
 614:../src/RTOS/queue.c **** 	}
 615:../src/RTOS/queue.c **** 
 616:../src/RTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 617:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 618:../src/RTOS/queue.c **** 
 619:../src/RTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 620:../src/RTOS/queue.c **** 
 621:../src/RTOS/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 622:../src/RTOS/queue.c **** 	{
 623:../src/RTOS/queue.c **** 	BaseType_t xReturn;
 624:../src/RTOS/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 625:../src/RTOS/queue.c **** 
 626:../src/RTOS/queue.c **** 		configASSERT( pxMutex );
 627:../src/RTOS/queue.c **** 
 628:../src/RTOS/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 629:../src/RTOS/queue.c **** 		xQueueGiveMutexRecursive(). */
 630:../src/RTOS/queue.c **** 
 631:../src/RTOS/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 632:../src/RTOS/queue.c **** 
 633:../src/RTOS/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 634:../src/RTOS/queue.c **** 		{
 635:../src/RTOS/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 636:../src/RTOS/queue.c **** 			xReturn = pdPASS;
 637:../src/RTOS/queue.c **** 		}
 638:../src/RTOS/queue.c **** 		else
 639:../src/RTOS/queue.c **** 		{
 640:../src/RTOS/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 641:../src/RTOS/queue.c **** 
 642:../src/RTOS/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 643:../src/RTOS/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 644:../src/RTOS/queue.c **** 			before reaching here. */
 645:../src/RTOS/queue.c **** 			if( xReturn != pdFAIL )
 646:../src/RTOS/queue.c **** 			{
 647:../src/RTOS/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 648:../src/RTOS/queue.c **** 			}
 649:../src/RTOS/queue.c **** 			else
 650:../src/RTOS/queue.c **** 			{
 651:../src/RTOS/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 652:../src/RTOS/queue.c **** 			}
 653:../src/RTOS/queue.c **** 		}
 654:../src/RTOS/queue.c **** 
 655:../src/RTOS/queue.c **** 		return xReturn;
 656:../src/RTOS/queue.c **** 	}
 657:../src/RTOS/queue.c **** 
 658:../src/RTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 659:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 660:../src/RTOS/queue.c **** 
 661:../src/RTOS/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 662:../src/RTOS/queue.c **** 
 663:../src/RTOS/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 664:../src/RTOS/queue.c **** 	{
 665:../src/RTOS/queue.c **** 	QueueHandle_t xHandle;
 666:../src/RTOS/queue.c **** 
 667:../src/RTOS/queue.c **** 		configASSERT( uxMaxCount != 0 );
 668:../src/RTOS/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 669:../src/RTOS/queue.c **** 
 670:../src/RTOS/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 671:../src/RTOS/queue.c **** 
 672:../src/RTOS/queue.c **** 		if( xHandle != NULL )
 673:../src/RTOS/queue.c **** 		{
 674:../src/RTOS/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 675:../src/RTOS/queue.c **** 
 676:../src/RTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 677:../src/RTOS/queue.c **** 		}
 678:../src/RTOS/queue.c **** 		else
 679:../src/RTOS/queue.c **** 		{
 680:../src/RTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 681:../src/RTOS/queue.c **** 		}
 682:../src/RTOS/queue.c **** 
 683:../src/RTOS/queue.c **** 		return xHandle;
 684:../src/RTOS/queue.c **** 	}
 685:../src/RTOS/queue.c **** 
 686:../src/RTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 687:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 688:../src/RTOS/queue.c **** 
 689:../src/RTOS/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 690:../src/RTOS/queue.c **** 
 691:../src/RTOS/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 692:../src/RTOS/queue.c **** 	{
 693:../src/RTOS/queue.c **** 	QueueHandle_t xHandle;
 694:../src/RTOS/queue.c **** 
 695:../src/RTOS/queue.c **** 		configASSERT( uxMaxCount != 0 );
 696:../src/RTOS/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 697:../src/RTOS/queue.c **** 
 698:../src/RTOS/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 699:../src/RTOS/queue.c **** 
 700:../src/RTOS/queue.c **** 		if( xHandle != NULL )
 701:../src/RTOS/queue.c **** 		{
 702:../src/RTOS/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 703:../src/RTOS/queue.c **** 
 704:../src/RTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 705:../src/RTOS/queue.c **** 		}
 706:../src/RTOS/queue.c **** 		else
 707:../src/RTOS/queue.c **** 		{
 708:../src/RTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 709:../src/RTOS/queue.c **** 		}
 710:../src/RTOS/queue.c **** 
 711:../src/RTOS/queue.c **** 		return xHandle;
 712:../src/RTOS/queue.c **** 	}
 713:../src/RTOS/queue.c **** 
 714:../src/RTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 715:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 716:../src/RTOS/queue.c **** 
 717:../src/RTOS/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 718:../src/RTOS/queue.c **** {
 411              		.loc 1 718 0
 412              		.cfi_startproc
 413              		@ args = 0, pretend = 0, frame = 40
 414              		@ frame_needed = 1, uses_anonymous_args = 0
 415 0000 80B5     		push	{r7, lr}
 416              		.cfi_def_cfa_offset 8
 417              		.cfi_offset 7, -8
 418              		.cfi_offset 14, -4
 419 0002 8AB0     		sub	sp, sp, #40
 420              		.cfi_def_cfa_offset 48
 421 0004 00AF     		add	r7, sp, #0
 422              		.cfi_def_cfa_register 7
 423 0006 F860     		str	r0, [r7, #12]
 424 0008 B960     		str	r1, [r7, #8]
 425 000a 7A60     		str	r2, [r7, #4]
 426 000c 3B60     		str	r3, [r7]
 719:../src/RTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 427              		.loc 1 719 0
 428 000e 0023     		movs	r3, #0
 429 0010 7B62     		str	r3, [r7, #36]
 720:../src/RTOS/queue.c **** TimeOut_t xTimeOut;
 721:../src/RTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 430              		.loc 1 721 0
 431 0012 FB68     		ldr	r3, [r7, #12]
 432 0014 3B62     		str	r3, [r7, #32]
 722:../src/RTOS/queue.c **** 
 723:../src/RTOS/queue.c **** 	configASSERT( pxQueue );
 433              		.loc 1 723 0
 434 0016 3B6A     		ldr	r3, [r7, #32]
 435 0018 002B     		cmp	r3, #0
 436 001a 00D1     		bne	.L24
 437              	.L25:
 438              		.loc 1 723 0 is_stmt 0 discriminator 1
 439 001c FEE7     		b	.L25
 440              	.L24:
 724:../src/RTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 441              		.loc 1 724 0 is_stmt 1
 442 001e BB68     		ldr	r3, [r7, #8]
 443 0020 002B     		cmp	r3, #0
 444 0022 03D1     		bne	.L26
 445              		.loc 1 724 0 is_stmt 0 discriminator 2
 446 0024 3B6A     		ldr	r3, [r7, #32]
 447 0026 1B6C     		ldr	r3, [r3, #64]
 448 0028 002B     		cmp	r3, #0
 449 002a 01D1     		bne	.L27
 450              	.L26:
 451              		.loc 1 724 0 discriminator 3
 452 002c 0123     		movs	r3, #1
 453 002e 00E0     		b	.L28
 454              	.L27:
 455              		.loc 1 724 0 discriminator 4
 456 0030 0023     		movs	r3, #0
 457              	.L28:
 458              		.loc 1 724 0 discriminator 6
 459 0032 002B     		cmp	r3, #0
 460 0034 00D1     		bne	.L29
 461              	.L30:
 462              		.loc 1 724 0 discriminator 2
 463 0036 FEE7     		b	.L30
 464              	.L29:
 725:../src/RTOS/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 465              		.loc 1 725 0 is_stmt 1
 466 0038 3B68     		ldr	r3, [r7]
 467 003a 022B     		cmp	r3, #2
 468 003c 03D1     		bne	.L31
 469              		.loc 1 725 0 is_stmt 0 discriminator 2
 470 003e 3B6A     		ldr	r3, [r7, #32]
 471 0040 DB6B     		ldr	r3, [r3, #60]
 472 0042 012B     		cmp	r3, #1
 473 0044 01D1     		bne	.L32
 474              	.L31:
 475              		.loc 1 725 0 discriminator 3
 476 0046 0123     		movs	r3, #1
 477 0048 00E0     		b	.L33
 478              	.L32:
 479              		.loc 1 725 0 discriminator 4
 480 004a 0023     		movs	r3, #0
 481              	.L33:
 482              		.loc 1 725 0 discriminator 6
 483 004c 002B     		cmp	r3, #0
 484 004e 00D1     		bne	.L34
 485              	.L35:
 486              		.loc 1 725 0 discriminator 3
 487 0050 FEE7     		b	.L35
 488              	.L34:
 726:../src/RTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 727:../src/RTOS/queue.c **** 	{
 728:../src/RTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 489              		.loc 1 728 0 is_stmt 1
 490 0052 FFF7FEFF 		bl	xTaskGetSchedulerState
 491 0056 0346     		mov	r3, r0
 492 0058 002B     		cmp	r3, #0
 493 005a 02D1     		bne	.L36
 494              		.loc 1 728 0 is_stmt 0 discriminator 2
 495 005c 7B68     		ldr	r3, [r7, #4]
 496 005e 002B     		cmp	r3, #0
 497 0060 01D1     		bne	.L37
 498              	.L36:
 499              		.loc 1 728 0 discriminator 3
 500 0062 0123     		movs	r3, #1
 501 0064 00E0     		b	.L38
 502              	.L37:
 503              		.loc 1 728 0 discriminator 4
 504 0066 0023     		movs	r3, #0
 505              	.L38:
 506              		.loc 1 728 0 discriminator 6
 507 0068 002B     		cmp	r3, #0
 508 006a 00D1     		bne	.L39
 509              	.L40:
 510              		.loc 1 728 0 discriminator 4
 511 006c FEE7     		b	.L40
 512              	.L39:
 729:../src/RTOS/queue.c **** 	}
 730:../src/RTOS/queue.c **** 	#endif
 731:../src/RTOS/queue.c **** 
 732:../src/RTOS/queue.c **** 
 733:../src/RTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 734:../src/RTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 735:../src/RTOS/queue.c **** 	of execution time efficiency. */
 736:../src/RTOS/queue.c **** 	for( ;; )
 737:../src/RTOS/queue.c **** 	{
 738:../src/RTOS/queue.c **** 		taskENTER_CRITICAL();
 513              		.loc 1 738 0 is_stmt 1
 514 006e FFF7FEFF 		bl	vPortEnterCritical
 739:../src/RTOS/queue.c **** 		{
 740:../src/RTOS/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 741:../src/RTOS/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 742:../src/RTOS/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 743:../src/RTOS/queue.c **** 			queue is full. */
 744:../src/RTOS/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 515              		.loc 1 744 0
 516 0072 3B6A     		ldr	r3, [r7, #32]
 517 0074 9A6B     		ldr	r2, [r3, #56]
 518 0076 3B6A     		ldr	r3, [r7, #32]
 519 0078 DB6B     		ldr	r3, [r3, #60]
 520 007a 9A42     		cmp	r2, r3
 521 007c 02D3     		bcc	.L41
 522              		.loc 1 744 0 is_stmt 0 discriminator 1
 523 007e 3B68     		ldr	r3, [r7]
 524 0080 022B     		cmp	r3, #2
 525 0082 29D1     		bne	.L42
 526              	.L41:
 745:../src/RTOS/queue.c **** 			{
 746:../src/RTOS/queue.c **** 				traceQUEUE_SEND( pxQueue );
 747:../src/RTOS/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 527              		.loc 1 747 0 is_stmt 1
 528 0084 386A     		ldr	r0, [r7, #32]
 529 0086 B968     		ldr	r1, [r7, #8]
 530 0088 3A68     		ldr	r2, [r7]
 531 008a FFF7FEFF 		bl	prvCopyDataToQueue
 532 008e F861     		str	r0, [r7, #28]
 748:../src/RTOS/queue.c **** 
 749:../src/RTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 750:../src/RTOS/queue.c **** 				{
 751:../src/RTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 752:../src/RTOS/queue.c **** 					{
 753:../src/RTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 754:../src/RTOS/queue.c **** 						{
 755:../src/RTOS/queue.c **** 							/* The queue is a member of a queue set, and posting
 756:../src/RTOS/queue.c **** 							to the queue set caused a higher priority task to
 757:../src/RTOS/queue.c **** 							unblock. A context switch is required. */
 758:../src/RTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 759:../src/RTOS/queue.c **** 						}
 760:../src/RTOS/queue.c **** 						else
 761:../src/RTOS/queue.c **** 						{
 762:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 763:../src/RTOS/queue.c **** 						}
 764:../src/RTOS/queue.c **** 					}
 765:../src/RTOS/queue.c **** 					else
 766:../src/RTOS/queue.c **** 					{
 767:../src/RTOS/queue.c **** 						/* If there was a task waiting for data to arrive on the
 768:../src/RTOS/queue.c **** 						queue then unblock it now. */
 769:../src/RTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 770:../src/RTOS/queue.c **** 						{
 771:../src/RTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 772:../src/RTOS/queue.c **** 							{
 773:../src/RTOS/queue.c **** 								/* The unblocked task has a priority higher than
 774:../src/RTOS/queue.c **** 								our own so yield immediately.  Yes it is ok to
 775:../src/RTOS/queue.c **** 								do this from within the critical section - the
 776:../src/RTOS/queue.c **** 								kernel takes care of that. */
 777:../src/RTOS/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 778:../src/RTOS/queue.c **** 							}
 779:../src/RTOS/queue.c **** 							else
 780:../src/RTOS/queue.c **** 							{
 781:../src/RTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 782:../src/RTOS/queue.c **** 							}
 783:../src/RTOS/queue.c **** 						}
 784:../src/RTOS/queue.c **** 						else if( xYieldRequired != pdFALSE )
 785:../src/RTOS/queue.c **** 						{
 786:../src/RTOS/queue.c **** 							/* This path is a special case that will only get
 787:../src/RTOS/queue.c **** 							executed if the task was holding multiple mutexes
 788:../src/RTOS/queue.c **** 							and the mutexes were given back in an order that is
 789:../src/RTOS/queue.c **** 							different to that in which they were taken. */
 790:../src/RTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 791:../src/RTOS/queue.c **** 						}
 792:../src/RTOS/queue.c **** 						else
 793:../src/RTOS/queue.c **** 						{
 794:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 795:../src/RTOS/queue.c **** 						}
 796:../src/RTOS/queue.c **** 					}
 797:../src/RTOS/queue.c **** 				}
 798:../src/RTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 799:../src/RTOS/queue.c **** 				{
 800:../src/RTOS/queue.c **** 					/* If there was a task waiting for data to arrive on the
 801:../src/RTOS/queue.c **** 					queue then unblock it now. */
 802:../src/RTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 533              		.loc 1 802 0
 534 0090 3B6A     		ldr	r3, [r7, #32]
 535 0092 5B6A     		ldr	r3, [r3, #36]
 536 0094 002B     		cmp	r3, #0
 537 0096 10D0     		beq	.L43
 803:../src/RTOS/queue.c **** 					{
 804:../src/RTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 538              		.loc 1 804 0
 539 0098 3B6A     		ldr	r3, [r7, #32]
 540 009a 2433     		adds	r3, r3, #36
 541 009c 1846     		mov	r0, r3
 542 009e FFF7FEFF 		bl	xTaskRemoveFromEventList
 543 00a2 0346     		mov	r3, r0
 544 00a4 002B     		cmp	r3, #0
 545 00a6 13D0     		beq	.L44
 805:../src/RTOS/queue.c **** 						{
 806:../src/RTOS/queue.c **** 							/* The unblocked task has a priority higher than
 807:../src/RTOS/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 808:../src/RTOS/queue.c **** 							this from within the critical section - the kernel
 809:../src/RTOS/queue.c **** 							takes care of that. */
 810:../src/RTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 546              		.loc 1 810 0
 547 00a8 414B     		ldr	r3, .L56
 548 00aa 4FF08052 		mov	r2, #268435456
 549 00ae 1A60     		str	r2, [r3]
 550              	@ 810 "../src/RTOS/queue.c" 1
 551 00b0 BFF34F8F 		dsb
 552              	@ 0 "" 2
 553              	@ 810 "../src/RTOS/queue.c" 1
 554 00b4 BFF36F8F 		isb
 555              	@ 0 "" 2
 556              		.thumb
 557 00b8 0AE0     		b	.L44
 558              	.L43:
 811:../src/RTOS/queue.c **** 						}
 812:../src/RTOS/queue.c **** 						else
 813:../src/RTOS/queue.c **** 						{
 814:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 815:../src/RTOS/queue.c **** 						}
 816:../src/RTOS/queue.c **** 					}
 817:../src/RTOS/queue.c **** 					else if( xYieldRequired != pdFALSE )
 559              		.loc 1 817 0
 560 00ba FB69     		ldr	r3, [r7, #28]
 561 00bc 002B     		cmp	r3, #0
 562 00be 07D0     		beq	.L44
 818:../src/RTOS/queue.c **** 					{
 819:../src/RTOS/queue.c **** 						/* This path is a special case that will only get
 820:../src/RTOS/queue.c **** 						executed if the task was holding multiple mutexes and
 821:../src/RTOS/queue.c **** 						the mutexes were given back in an order that is
 822:../src/RTOS/queue.c **** 						different to that in which they were taken. */
 823:../src/RTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 563              		.loc 1 823 0
 564 00c0 3B4B     		ldr	r3, .L56
 565 00c2 4FF08052 		mov	r2, #268435456
 566 00c6 1A60     		str	r2, [r3]
 567              	@ 823 "../src/RTOS/queue.c" 1
 568 00c8 BFF34F8F 		dsb
 569              	@ 0 "" 2
 570              	@ 823 "../src/RTOS/queue.c" 1
 571 00cc BFF36F8F 		isb
 572              	@ 0 "" 2
 573              		.thumb
 574              	.L44:
 824:../src/RTOS/queue.c **** 					}
 825:../src/RTOS/queue.c **** 					else
 826:../src/RTOS/queue.c **** 					{
 827:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 828:../src/RTOS/queue.c **** 					}
 829:../src/RTOS/queue.c **** 				}
 830:../src/RTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 831:../src/RTOS/queue.c **** 
 832:../src/RTOS/queue.c **** 				taskEXIT_CRITICAL();
 575              		.loc 1 832 0
 576 00d0 FFF7FEFF 		bl	vPortExitCritical
 833:../src/RTOS/queue.c **** 				return pdPASS;
 577              		.loc 1 833 0
 578 00d4 0123     		movs	r3, #1
 579 00d6 67E0     		b	.L55
 580              	.L42:
 834:../src/RTOS/queue.c **** 			}
 835:../src/RTOS/queue.c **** 			else
 836:../src/RTOS/queue.c **** 			{
 837:../src/RTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 581              		.loc 1 837 0
 582 00d8 7B68     		ldr	r3, [r7, #4]
 583 00da 002B     		cmp	r3, #0
 584 00dc 03D1     		bne	.L46
 838:../src/RTOS/queue.c **** 				{
 839:../src/RTOS/queue.c **** 					/* The queue was full and no block time is specified (or
 840:../src/RTOS/queue.c **** 					the block time has expired) so leave now. */
 841:../src/RTOS/queue.c **** 					taskEXIT_CRITICAL();
 585              		.loc 1 841 0
 586 00de FFF7FEFF 		bl	vPortExitCritical
 842:../src/RTOS/queue.c **** 
 843:../src/RTOS/queue.c **** 					/* Return to the original privilege level before exiting
 844:../src/RTOS/queue.c **** 					the function. */
 845:../src/RTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 846:../src/RTOS/queue.c **** 					return errQUEUE_FULL;
 587              		.loc 1 846 0
 588 00e2 0023     		movs	r3, #0
 589 00e4 60E0     		b	.L55
 590              	.L46:
 847:../src/RTOS/queue.c **** 				}
 848:../src/RTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 591              		.loc 1 848 0
 592 00e6 7B6A     		ldr	r3, [r7, #36]
 593 00e8 002B     		cmp	r3, #0
 594 00ea 06D1     		bne	.L47
 849:../src/RTOS/queue.c **** 				{
 850:../src/RTOS/queue.c **** 					/* The queue was full and a block time was specified so
 851:../src/RTOS/queue.c **** 					configure the timeout structure. */
 852:../src/RTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 595              		.loc 1 852 0
 596 00ec 07F11403 		add	r3, r7, #20
 597 00f0 1846     		mov	r0, r3
 598 00f2 FFF7FEFF 		bl	vTaskSetTimeOutState
 853:../src/RTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 599              		.loc 1 853 0
 600 00f6 0123     		movs	r3, #1
 601 00f8 7B62     		str	r3, [r7, #36]
 602              	.L47:
 854:../src/RTOS/queue.c **** 				}
 855:../src/RTOS/queue.c **** 				else
 856:../src/RTOS/queue.c **** 				{
 857:../src/RTOS/queue.c **** 					/* Entry time was already set. */
 858:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 859:../src/RTOS/queue.c **** 				}
 860:../src/RTOS/queue.c **** 			}
 861:../src/RTOS/queue.c **** 		}
 862:../src/RTOS/queue.c **** 		taskEXIT_CRITICAL();
 603              		.loc 1 862 0
 604 00fa FFF7FEFF 		bl	vPortExitCritical
 863:../src/RTOS/queue.c **** 
 864:../src/RTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 865:../src/RTOS/queue.c **** 		now the critical section has been exited. */
 866:../src/RTOS/queue.c **** 
 867:../src/RTOS/queue.c **** 		vTaskSuspendAll();
 605              		.loc 1 867 0
 606 00fe FFF7FEFF 		bl	vTaskSuspendAll
 868:../src/RTOS/queue.c **** 		prvLockQueue( pxQueue );
 607              		.loc 1 868 0
 608 0102 FFF7FEFF 		bl	vPortEnterCritical
 609 0106 3B6A     		ldr	r3, [r7, #32]
 610 0108 93F84430 		ldrb	r3, [r3, #68]
 611 010c DBB2     		uxtb	r3, r3
 612 010e 5BB2     		sxtb	r3, r3
 613 0110 B3F1FF3F 		cmp	r3, #-1
 614 0114 03D1     		bne	.L48
 615              		.loc 1 868 0 is_stmt 0 discriminator 1
 616 0116 3B6A     		ldr	r3, [r7, #32]
 617 0118 0022     		movs	r2, #0
 618 011a 83F84420 		strb	r2, [r3, #68]
 619              	.L48:
 620              		.loc 1 868 0 discriminator 3
 621 011e 3B6A     		ldr	r3, [r7, #32]
 622 0120 93F84530 		ldrb	r3, [r3, #69]
 623 0124 DBB2     		uxtb	r3, r3
 624 0126 5BB2     		sxtb	r3, r3
 625 0128 B3F1FF3F 		cmp	r3, #-1
 626 012c 03D1     		bne	.L49
 627              		.loc 1 868 0 discriminator 4
 628 012e 3B6A     		ldr	r3, [r7, #32]
 629 0130 0022     		movs	r2, #0
 630 0132 83F84520 		strb	r2, [r3, #69]
 631              	.L49:
 632              		.loc 1 868 0 discriminator 6
 633 0136 FFF7FEFF 		bl	vPortExitCritical
 869:../src/RTOS/queue.c **** 
 870:../src/RTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 871:../src/RTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 634              		.loc 1 871 0 is_stmt 1 discriminator 6
 635 013a 07F11402 		add	r2, r7, #20
 636 013e 3B1D     		adds	r3, r7, #4
 637 0140 1046     		mov	r0, r2
 638 0142 1946     		mov	r1, r3
 639 0144 FFF7FEFF 		bl	xTaskCheckForTimeOut
 640 0148 0346     		mov	r3, r0
 641 014a 002B     		cmp	r3, #0
 642 014c 24D1     		bne	.L50
 872:../src/RTOS/queue.c **** 		{
 873:../src/RTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 643              		.loc 1 873 0
 644 014e 386A     		ldr	r0, [r7, #32]
 645 0150 FFF7FEFF 		bl	prvIsQueueFull
 646 0154 0346     		mov	r3, r0
 647 0156 002B     		cmp	r3, #0
 648 0158 18D0     		beq	.L51
 874:../src/RTOS/queue.c **** 			{
 875:../src/RTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 876:../src/RTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 649              		.loc 1 876 0
 650 015a 3B6A     		ldr	r3, [r7, #32]
 651 015c 03F11002 		add	r2, r3, #16
 652 0160 7B68     		ldr	r3, [r7, #4]
 653 0162 1046     		mov	r0, r2
 654 0164 1946     		mov	r1, r3
 655 0166 FFF7FEFF 		bl	vTaskPlaceOnEventList
 877:../src/RTOS/queue.c **** 
 878:../src/RTOS/queue.c **** 				/* Unlocking the queue means queue events can effect the
 879:../src/RTOS/queue.c **** 				event list.  It is possible	that interrupts occurring now
 880:../src/RTOS/queue.c **** 				remove this task from the event	list again - but as the
 881:../src/RTOS/queue.c **** 				scheduler is suspended the task will go onto the pending
 882:../src/RTOS/queue.c **** 				ready last instead of the actual ready list. */
 883:../src/RTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 656              		.loc 1 883 0
 657 016a 386A     		ldr	r0, [r7, #32]
 658 016c FFF7FEFF 		bl	prvUnlockQueue
 884:../src/RTOS/queue.c **** 
 885:../src/RTOS/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 886:../src/RTOS/queue.c **** 				ready list into the ready list - so it is feasible that this
 887:../src/RTOS/queue.c **** 				task is already in a ready list before it yields - in which
 888:../src/RTOS/queue.c **** 				case the yield will not cause a context switch unless there
 889:../src/RTOS/queue.c **** 				is also a higher priority task in the pending ready list. */
 890:../src/RTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 659              		.loc 1 890 0
 660 0170 FFF7FEFF 		bl	xTaskResumeAll
 661 0174 0346     		mov	r3, r0
 662 0176 002B     		cmp	r3, #0
 663 0178 15D1     		bne	.L54
 891:../src/RTOS/queue.c **** 				{
 892:../src/RTOS/queue.c **** 					portYIELD_WITHIN_API();
 664              		.loc 1 892 0
 665 017a 0D4B     		ldr	r3, .L56
 666 017c 4FF08052 		mov	r2, #268435456
 667 0180 1A60     		str	r2, [r3]
 668              	@ 892 "../src/RTOS/queue.c" 1
 669 0182 BFF34F8F 		dsb
 670              	@ 0 "" 2
 671              	@ 892 "../src/RTOS/queue.c" 1
 672 0186 BFF36F8F 		isb
 673              	@ 0 "" 2
 674              		.thumb
 675 018a 0CE0     		b	.L54
 676              	.L51:
 893:../src/RTOS/queue.c **** 				}
 894:../src/RTOS/queue.c **** 			}
 895:../src/RTOS/queue.c **** 			else
 896:../src/RTOS/queue.c **** 			{
 897:../src/RTOS/queue.c **** 				/* Try again. */
 898:../src/RTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 677              		.loc 1 898 0
 678 018c 386A     		ldr	r0, [r7, #32]
 679 018e FFF7FEFF 		bl	prvUnlockQueue
 899:../src/RTOS/queue.c **** 				( void ) xTaskResumeAll();
 680              		.loc 1 899 0
 681 0192 FFF7FEFF 		bl	xTaskResumeAll
 682 0196 6AE7     		b	.L39
 683              	.L50:
 900:../src/RTOS/queue.c **** 			}
 901:../src/RTOS/queue.c **** 		}
 902:../src/RTOS/queue.c **** 		else
 903:../src/RTOS/queue.c **** 		{
 904:../src/RTOS/queue.c **** 			/* The timeout has expired. */
 905:../src/RTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 684              		.loc 1 905 0
 685 0198 386A     		ldr	r0, [r7, #32]
 686 019a FFF7FEFF 		bl	prvUnlockQueue
 906:../src/RTOS/queue.c **** 			( void ) xTaskResumeAll();
 687              		.loc 1 906 0
 688 019e FFF7FEFF 		bl	xTaskResumeAll
 907:../src/RTOS/queue.c **** 
 908:../src/RTOS/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 909:../src/RTOS/queue.c **** 			return errQUEUE_FULL;
 689              		.loc 1 909 0
 690 01a2 0023     		movs	r3, #0
 691 01a4 00E0     		b	.L55
 692              	.L54:
 910:../src/RTOS/queue.c **** 		}
 911:../src/RTOS/queue.c **** 	}
 693              		.loc 1 911 0 discriminator 6
 694 01a6 62E7     		b	.L39
 695              	.L55:
 912:../src/RTOS/queue.c **** }
 696              		.loc 1 912 0 discriminator 7
 697 01a8 1846     		mov	r0, r3
 698 01aa 2837     		adds	r7, r7, #40
 699              		.cfi_def_cfa_offset 8
 700 01ac BD46     		mov	sp, r7
 701              		.cfi_def_cfa_register 13
 702              		@ sp needed
 703 01ae 80BD     		pop	{r7, pc}
 704              	.L57:
 705              		.align	2
 706              	.L56:
 707 01b0 04ED00E0 		.word	-536810236
 708              		.cfi_endproc
 709              	.LFE9:
 711              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 712              		.align	2
 713              		.global	xQueueGenericSendFromISR
 714              		.thumb
 715              		.thumb_func
 717              	xQueueGenericSendFromISR:
 718              	.LFB10:
 913:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
 914:../src/RTOS/queue.c **** 
 915:../src/RTOS/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 916:../src/RTOS/queue.c **** {
 719              		.loc 1 916 0
 720              		.cfi_startproc
 721              		@ args = 0, pretend = 0, frame = 48
 722              		@ frame_needed = 1, uses_anonymous_args = 0
 723 0000 80B5     		push	{r7, lr}
 724              		.cfi_def_cfa_offset 8
 725              		.cfi_offset 7, -8
 726              		.cfi_offset 14, -4
 727 0002 8CB0     		sub	sp, sp, #48
 728              		.cfi_def_cfa_offset 56
 729 0004 00AF     		add	r7, sp, #0
 730              		.cfi_def_cfa_register 7
 731 0006 F860     		str	r0, [r7, #12]
 732 0008 B960     		str	r1, [r7, #8]
 733 000a 7A60     		str	r2, [r7, #4]
 734 000c 3B60     		str	r3, [r7]
 917:../src/RTOS/queue.c **** BaseType_t xReturn;
 918:../src/RTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
 919:../src/RTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 735              		.loc 1 919 0
 736 000e FB68     		ldr	r3, [r7, #12]
 737 0010 BB62     		str	r3, [r7, #40]
 920:../src/RTOS/queue.c **** 
 921:../src/RTOS/queue.c **** 	configASSERT( pxQueue );
 738              		.loc 1 921 0
 739 0012 BB6A     		ldr	r3, [r7, #40]
 740 0014 002B     		cmp	r3, #0
 741 0016 00D1     		bne	.L59
 742              	.L60:
 743              		.loc 1 921 0 is_stmt 0 discriminator 1
 744 0018 FEE7     		b	.L60
 745              	.L59:
 922:../src/RTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 746              		.loc 1 922 0 is_stmt 1
 747 001a BB68     		ldr	r3, [r7, #8]
 748 001c 002B     		cmp	r3, #0
 749 001e 03D1     		bne	.L61
 750              		.loc 1 922 0 is_stmt 0 discriminator 2
 751 0020 BB6A     		ldr	r3, [r7, #40]
 752 0022 1B6C     		ldr	r3, [r3, #64]
 753 0024 002B     		cmp	r3, #0
 754 0026 01D1     		bne	.L62
 755              	.L61:
 756              		.loc 1 922 0 discriminator 3
 757 0028 0123     		movs	r3, #1
 758 002a 00E0     		b	.L63
 759              	.L62:
 760              		.loc 1 922 0 discriminator 4
 761 002c 0023     		movs	r3, #0
 762              	.L63:
 763              		.loc 1 922 0 discriminator 6
 764 002e 002B     		cmp	r3, #0
 765 0030 00D1     		bne	.L64
 766              	.L65:
 767              		.loc 1 922 0 discriminator 2
 768 0032 FEE7     		b	.L65
 769              	.L64:
 923:../src/RTOS/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 770              		.loc 1 923 0 is_stmt 1
 771 0034 3B68     		ldr	r3, [r7]
 772 0036 022B     		cmp	r3, #2
 773 0038 03D1     		bne	.L66
 774              		.loc 1 923 0 is_stmt 0 discriminator 2
 775 003a BB6A     		ldr	r3, [r7, #40]
 776 003c DB6B     		ldr	r3, [r3, #60]
 777 003e 012B     		cmp	r3, #1
 778 0040 01D1     		bne	.L67
 779              	.L66:
 780              		.loc 1 923 0 discriminator 3
 781 0042 0123     		movs	r3, #1
 782 0044 00E0     		b	.L68
 783              	.L67:
 784              		.loc 1 923 0 discriminator 4
 785 0046 0023     		movs	r3, #0
 786              	.L68:
 787              		.loc 1 923 0 discriminator 6
 788 0048 002B     		cmp	r3, #0
 789 004a 00D1     		bne	.L69
 790              	.L70:
 791              		.loc 1 923 0 discriminator 3
 792 004c FEE7     		b	.L70
 793              	.L69:
 924:../src/RTOS/queue.c **** 
 925:../src/RTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 926:../src/RTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 927:../src/RTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 928:../src/RTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 929:../src/RTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 930:../src/RTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 931:../src/RTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 932:../src/RTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
 933:../src/RTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 934:../src/RTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 935:../src/RTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 936:../src/RTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 937:../src/RTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 938:../src/RTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 939:../src/RTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 794              		.loc 1 939 0 is_stmt 1
 795 004e FFF7FEFF 		bl	vPortValidateInterruptPriority
 796              	.LBB23:
 797              	.LBB24:
 798              		.file 2 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h"
   1:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*
   2:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     FreeRTOS V9.0.0rc2 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     All rights reserved
   4:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
   5:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
   7:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     This file is part of the FreeRTOS distribution.
   8:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
   9:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     the terms of the GNU General Public License (version 2) as published by the
  11:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  13:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     ***************************************************************************
  14:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     ***************************************************************************
  19:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  20:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     link: http://www.freertos.org/a00114.html
  24:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  25:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     ***************************************************************************
  26:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *                                                                       *
  27:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    robust, strictly quality controlled, supported, and cross          *
  29:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    platform software that is more than just the market leader, it     *
  30:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    is the industry's de facto standard.                               *
  31:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *                                                                       *
  32:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    Help yourself get started quickly while simultaneously helping     *
  33:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    tutorial book, reference manual, or both:                          *
  35:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *                                                                       *
  37:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     ***************************************************************************
  38:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  39:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     defined configASSERT()?
  42:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  43:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     embedded software for free we request you assist our global community by
  45:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     participating in the support forum.
  46:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  47:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     be as productive as possible as early as possible.  Now you can receive
  49:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  52:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  56:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  59:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  63:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     engineered and independently SIL3 certified version for use in safety and
  65:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     mission critical applications that require provable dependability.
  66:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  67:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     1 tab == 4 spaces!
  68:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** */
  69:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  70:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  71:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifndef PORTMACRO_H
  72:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define PORTMACRO_H
  73:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  74:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifdef __cplusplus
  75:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** extern "C" {
  76:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
  77:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  78:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------
  79:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  * Port specific definitions.
  80:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  *
  81:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  82:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  * given hardware and compiler.
  83:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  *
  84:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  * These settings should not be altered.
  85:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  *-----------------------------------------------------------
  86:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  */
  87:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  88:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Type definitions. */
  89:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portCHAR		char
  90:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portFLOAT		float
  91:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portDOUBLE		double
  92:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portLONG		long
  93:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portSHORT		short
  94:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portSTACK_TYPE	uint32_t
  95:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portBASE_TYPE	long
  96:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  97:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** typedef portSTACK_TYPE StackType_t;
  98:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** typedef long BaseType_t;
  99:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** typedef unsigned long UBaseType_t;
 100:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 101:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
 102:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	typedef uint16_t TickType_t;
 103:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
 104:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #else
 105:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	typedef uint32_t TickType_t;
 106:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
 107:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 108:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
 109:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	not need to be guarded with a critical section. */
 110:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
 111:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
 112:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 113:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 114:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Architecture specifics. */
 115:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portSTACK_GROWTH			( -1 )
 116:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
 117:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portBYTE_ALIGNMENT			8
 118:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 119:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 120:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Scheduler utilities. */
 121:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portYIELD() 															\
 122:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** {																				\
 123:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
 124:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
 125:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 																				\
 126:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
 127:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	within the specified behaviour for the architecture. */						\
 128:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile( "dsb" );													\
 129:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile( "isb" );													\
 130:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 131:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 132:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
 133:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
 134:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
 135:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
 136:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 137:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 138:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Critical section management. */
 139:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** extern void vPortEnterCritical( void );
 140:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** extern void vPortExitCritical( void );
 141:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 142:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 143:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 144:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 145:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 146:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 147:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 148:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 149:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 150:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 151:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 152:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** (which build with all the ports) will build. */
 153:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 154:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 155:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 156:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 157:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Tickless idle/low power functionality. */
 158:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 159:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 160:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 161:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
 162:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 163:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 164:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Architecture specific optimisations. */
 165:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 166:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 167:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
 168:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 169:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 170:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 171:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Generic helper function. */
 172:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 173:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	{
 174:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	uint8_t ucReturn;
 175:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 176:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 177:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		return ucReturn;
 178:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	}
 179:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 180:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Check the configuration. */
 181:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 182:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 183:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#endif
 184:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 185:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 186:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 187:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 188:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 189:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/*-----------------------------------------------------------*/
 190:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 191:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 192:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 193:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 194:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 195:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 196:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 197:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifdef configASSERT
 198:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	void vPortValidateInterruptPriority( void );
 199:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 200:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
 201:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 202:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* portNOP() is not required by this port. */
 203:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portNOP()
 204:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 205:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portINLINE	__inline
 206:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 207:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifndef portFORCE_INLINE
 208:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 209:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
 210:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 211:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 212:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** {
 213:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** uint32_t ulCurrentInterrupt;
 214:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** BaseType_t xReturn;
 215:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 216:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 217:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 218:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 219:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 220:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	{
 221:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		xReturn = pdFALSE;
 222:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	}
 223:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	else
 224:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	{
 225:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		xReturn = pdTRUE;
 226:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	}
 227:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 228:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	return xReturn;
 229:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 230:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 231:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 232:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 233:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 234:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** {
 235:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** uint32_t ulNewBASEPRI;
 236:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 237:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile
 238:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 239:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	mov %0, %1												\n"	\
 240:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	msr basepri, %0											\n" \
 241:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	isb														\n" \
 242:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	dsb														\n" \
 243:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 244:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	);
 245:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 246:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 247:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 248:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 249:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 250:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** {
 251:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 252:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 253:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile
 799              		.loc 2 253 0
 800              	@ 253 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 801 0052 EFF31182 			mrs r2, basepri											
 802 0056 4FF0BF03 		mov r3, #191												
 803 005a 83F31188 		msr basepri, r3											
 804 005e BFF36F8F 		isb														
 805 0062 BFF34F8F 		dsb														
 806              	
 807              	@ 0 "" 2
 808              		.thumb
 809 0066 FA61     		str	r2, [r7, #28]
 810 0068 BB61     		str	r3, [r7, #24]
 254:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 255:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	mrs %0, basepri											\n" \
 256:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	mov %1, %2												\n"	\
 257:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	msr basepri, %1											\n" \
 258:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	isb														\n" \
 259:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	dsb														\n" \
 260:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 261:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	);
 262:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 263:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 264:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	warnings. */
 265:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	return ulOriginalBASEPRI;
 811              		.loc 2 265 0
 812 006a FB69     		ldr	r3, [r7, #28]
 813              	.LBE24:
 814              	.LBE23:
 940:../src/RTOS/queue.c **** 
 941:../src/RTOS/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 942:../src/RTOS/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 943:../src/RTOS/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 944:../src/RTOS/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 945:../src/RTOS/queue.c **** 	post). */
 946:../src/RTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 815              		.loc 1 946 0
 816 006c 7B62     		str	r3, [r7, #36]
 947:../src/RTOS/queue.c **** 	{
 948:../src/RTOS/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 817              		.loc 1 948 0
 818 006e BB6A     		ldr	r3, [r7, #40]
 819 0070 9A6B     		ldr	r2, [r3, #56]
 820 0072 BB6A     		ldr	r3, [r7, #40]
 821 0074 DB6B     		ldr	r3, [r3, #60]
 822 0076 9A42     		cmp	r2, r3
 823 0078 02D3     		bcc	.L72
 824              		.loc 1 948 0 is_stmt 0 discriminator 1
 825 007a 3B68     		ldr	r3, [r7]
 826 007c 022B     		cmp	r3, #2
 827 007e 2CD1     		bne	.L73
 828              	.L72:
 829              	.LBB25:
 949:../src/RTOS/queue.c **** 		{
 950:../src/RTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 830              		.loc 1 950 0 is_stmt 1
 831 0080 BB6A     		ldr	r3, [r7, #40]
 832 0082 93F84530 		ldrb	r3, [r3, #69]
 833 0086 87F82330 		strb	r3, [r7, #35]
 951:../src/RTOS/queue.c **** 
 952:../src/RTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 953:../src/RTOS/queue.c **** 
 954:../src/RTOS/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 955:../src/RTOS/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 956:../src/RTOS/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 957:../src/RTOS/queue.c **** 			called here even though the disinherit function does not check if
 958:../src/RTOS/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 959:../src/RTOS/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 834              		.loc 1 959 0
 835 008a B86A     		ldr	r0, [r7, #40]
 836 008c B968     		ldr	r1, [r7, #8]
 837 008e 3A68     		ldr	r2, [r7]
 838 0090 FFF7FEFF 		bl	prvCopyDataToQueue
 960:../src/RTOS/queue.c **** 
 961:../src/RTOS/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 962:../src/RTOS/queue.c **** 			be done when the queue is unlocked later. */
 963:../src/RTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 839              		.loc 1 963 0
 840 0094 97F92330 		ldrsb	r3, [r7, #35]
 841 0098 B3F1FF3F 		cmp	r3, #-1
 842 009c 12D1     		bne	.L74
 964:../src/RTOS/queue.c **** 			{
 965:../src/RTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 966:../src/RTOS/queue.c **** 				{
 967:../src/RTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 968:../src/RTOS/queue.c **** 					{
 969:../src/RTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 970:../src/RTOS/queue.c **** 						{
 971:../src/RTOS/queue.c **** 							/* The queue is a member of a queue set, and posting
 972:../src/RTOS/queue.c **** 							to the queue set caused a higher priority task to
 973:../src/RTOS/queue.c **** 							unblock.  A context switch is required. */
 974:../src/RTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 975:../src/RTOS/queue.c **** 							{
 976:../src/RTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 977:../src/RTOS/queue.c **** 							}
 978:../src/RTOS/queue.c **** 							else
 979:../src/RTOS/queue.c **** 							{
 980:../src/RTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 981:../src/RTOS/queue.c **** 							}
 982:../src/RTOS/queue.c **** 						}
 983:../src/RTOS/queue.c **** 						else
 984:../src/RTOS/queue.c **** 						{
 985:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 986:../src/RTOS/queue.c **** 						}
 987:../src/RTOS/queue.c **** 					}
 988:../src/RTOS/queue.c **** 					else
 989:../src/RTOS/queue.c **** 					{
 990:../src/RTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 991:../src/RTOS/queue.c **** 						{
 992:../src/RTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 993:../src/RTOS/queue.c **** 							{
 994:../src/RTOS/queue.c **** 								/* The task waiting has a higher priority so
 995:../src/RTOS/queue.c **** 								record that a context switch is required. */
 996:../src/RTOS/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
 997:../src/RTOS/queue.c **** 								{
 998:../src/RTOS/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
 999:../src/RTOS/queue.c **** 								}
1000:../src/RTOS/queue.c **** 								else
1001:../src/RTOS/queue.c **** 								{
1002:../src/RTOS/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1003:../src/RTOS/queue.c **** 								}
1004:../src/RTOS/queue.c **** 							}
1005:../src/RTOS/queue.c **** 							else
1006:../src/RTOS/queue.c **** 							{
1007:../src/RTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1008:../src/RTOS/queue.c **** 							}
1009:../src/RTOS/queue.c **** 						}
1010:../src/RTOS/queue.c **** 						else
1011:../src/RTOS/queue.c **** 						{
1012:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1013:../src/RTOS/queue.c **** 						}
1014:../src/RTOS/queue.c **** 					}
1015:../src/RTOS/queue.c **** 				}
1016:../src/RTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1017:../src/RTOS/queue.c **** 				{
1018:../src/RTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 843              		.loc 1 1018 0
 844 009e BB6A     		ldr	r3, [r7, #40]
 845 00a0 5B6A     		ldr	r3, [r3, #36]
 846 00a2 002B     		cmp	r3, #0
 847 00a4 16D0     		beq	.L75
1019:../src/RTOS/queue.c **** 					{
1020:../src/RTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 848              		.loc 1 1020 0
 849 00a6 BB6A     		ldr	r3, [r7, #40]
 850 00a8 2433     		adds	r3, r3, #36
 851 00aa 1846     		mov	r0, r3
 852 00ac FFF7FEFF 		bl	xTaskRemoveFromEventList
 853 00b0 0346     		mov	r3, r0
 854 00b2 002B     		cmp	r3, #0
 855 00b4 0ED0     		beq	.L75
1021:../src/RTOS/queue.c **** 						{
1022:../src/RTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1023:../src/RTOS/queue.c **** 							context	switch is required. */
1024:../src/RTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 856              		.loc 1 1024 0
 857 00b6 7B68     		ldr	r3, [r7, #4]
 858 00b8 002B     		cmp	r3, #0
 859 00ba 0BD0     		beq	.L75
1025:../src/RTOS/queue.c **** 							{
1026:../src/RTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 860              		.loc 1 1026 0
 861 00bc 7B68     		ldr	r3, [r7, #4]
 862 00be 0122     		movs	r2, #1
 863 00c0 1A60     		str	r2, [r3]
 864 00c2 07E0     		b	.L75
 865              	.L74:
1027:../src/RTOS/queue.c **** 							}
1028:../src/RTOS/queue.c **** 							else
1029:../src/RTOS/queue.c **** 							{
1030:../src/RTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1031:../src/RTOS/queue.c **** 							}
1032:../src/RTOS/queue.c **** 						}
1033:../src/RTOS/queue.c **** 						else
1034:../src/RTOS/queue.c **** 						{
1035:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1036:../src/RTOS/queue.c **** 						}
1037:../src/RTOS/queue.c **** 					}
1038:../src/RTOS/queue.c **** 					else
1039:../src/RTOS/queue.c **** 					{
1040:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1041:../src/RTOS/queue.c **** 					}
1042:../src/RTOS/queue.c **** 				}
1043:../src/RTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1044:../src/RTOS/queue.c **** 			}
1045:../src/RTOS/queue.c **** 			else
1046:../src/RTOS/queue.c **** 			{
1047:../src/RTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1048:../src/RTOS/queue.c **** 				knows that data was posted while it was locked. */
1049:../src/RTOS/queue.c **** 				pxQueue->cTxLock = cTxLock + 1;
 866              		.loc 1 1049 0
 867 00c4 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 868 00c8 0133     		adds	r3, r3, #1
 869 00ca DBB2     		uxtb	r3, r3
 870 00cc DAB2     		uxtb	r2, r3
 871 00ce BB6A     		ldr	r3, [r7, #40]
 872 00d0 83F84520 		strb	r2, [r3, #69]
 873              	.L75:
1050:../src/RTOS/queue.c **** 			}
1051:../src/RTOS/queue.c **** 
1052:../src/RTOS/queue.c **** 			xReturn = pdPASS;
 874              		.loc 1 1052 0
 875 00d4 0123     		movs	r3, #1
 876 00d6 FB62     		str	r3, [r7, #44]
 877              	.LBE25:
 949:../src/RTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 878              		.loc 1 949 0
 879 00d8 01E0     		b	.L76
 880              	.L73:
1053:../src/RTOS/queue.c **** 		}
1054:../src/RTOS/queue.c **** 		else
1055:../src/RTOS/queue.c **** 		{
1056:../src/RTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1057:../src/RTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 881              		.loc 1 1057 0
 882 00da 0023     		movs	r3, #0
 883 00dc FB62     		str	r3, [r7, #44]
 884              	.L76:
 885 00de 7B6A     		ldr	r3, [r7, #36]
 886 00e0 7B61     		str	r3, [r7, #20]
 887              	.LBB26:
 888              	.LBB27:
 266:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 267:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 268:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 269:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 270:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** {
 271:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile
 889              		.loc 2 271 0
 890 00e2 7B69     		ldr	r3, [r7, #20]
 891              	@ 271 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 892 00e4 83F31188 			msr basepri, r3	
 893              	@ 0 "" 2
 894              		.thumb
 895              	.LBE27:
 896              	.LBE26:
1058:../src/RTOS/queue.c **** 		}
1059:../src/RTOS/queue.c **** 	}
1060:../src/RTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1061:../src/RTOS/queue.c **** 
1062:../src/RTOS/queue.c **** 	return xReturn;
 897              		.loc 1 1062 0
 898 00e8 FB6A     		ldr	r3, [r7, #44]
1063:../src/RTOS/queue.c **** }
 899              		.loc 1 1063 0
 900 00ea 1846     		mov	r0, r3
 901 00ec 3037     		adds	r7, r7, #48
 902              		.cfi_def_cfa_offset 8
 903 00ee BD46     		mov	sp, r7
 904              		.cfi_def_cfa_register 13
 905              		@ sp needed
 906 00f0 80BD     		pop	{r7, pc}
 907              		.cfi_endproc
 908              	.LFE10:
 910 00f2 00BF     		.section	.text.xQueueGiveFromISR,"ax",%progbits
 911              		.align	2
 912              		.global	xQueueGiveFromISR
 913              		.thumb
 914              		.thumb_func
 916              	xQueueGiveFromISR:
 917              	.LFB11:
1064:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1065:../src/RTOS/queue.c **** 
1066:../src/RTOS/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1067:../src/RTOS/queue.c **** {
 918              		.loc 1 1067 0
 919              		.cfi_startproc
 920              		@ args = 0, pretend = 0, frame = 40
 921              		@ frame_needed = 1, uses_anonymous_args = 0
 922 0000 80B5     		push	{r7, lr}
 923              		.cfi_def_cfa_offset 8
 924              		.cfi_offset 7, -8
 925              		.cfi_offset 14, -4
 926 0002 8AB0     		sub	sp, sp, #40
 927              		.cfi_def_cfa_offset 48
 928 0004 00AF     		add	r7, sp, #0
 929              		.cfi_def_cfa_register 7
 930 0006 7860     		str	r0, [r7, #4]
 931 0008 3960     		str	r1, [r7]
1068:../src/RTOS/queue.c **** BaseType_t xReturn;
1069:../src/RTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1070:../src/RTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 932              		.loc 1 1070 0
 933 000a 7B68     		ldr	r3, [r7, #4]
 934 000c 3B62     		str	r3, [r7, #32]
1071:../src/RTOS/queue.c **** 
1072:../src/RTOS/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1073:../src/RTOS/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1074:../src/RTOS/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1075:../src/RTOS/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1076:../src/RTOS/queue.c **** 	post). */
1077:../src/RTOS/queue.c **** 
1078:../src/RTOS/queue.c **** 	configASSERT( pxQueue );
 935              		.loc 1 1078 0
 936 000e 3B6A     		ldr	r3, [r7, #32]
 937 0010 002B     		cmp	r3, #0
 938 0012 00D1     		bne	.L79
 939              	.L80:
 940              		.loc 1 1078 0 is_stmt 0 discriminator 1
 941 0014 FEE7     		b	.L80
 942              	.L79:
1079:../src/RTOS/queue.c **** 
1080:../src/RTOS/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1081:../src/RTOS/queue.c **** 	if the item size is not 0. */
1082:../src/RTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
 943              		.loc 1 1082 0 is_stmt 1
 944 0016 3B6A     		ldr	r3, [r7, #32]
 945 0018 1B6C     		ldr	r3, [r3, #64]
 946 001a 002B     		cmp	r3, #0
 947 001c 00D0     		beq	.L81
 948              	.L82:
 949              		.loc 1 1082 0 is_stmt 0 discriminator 2
 950 001e FEE7     		b	.L82
 951              	.L81:
1083:../src/RTOS/queue.c **** 
1084:../src/RTOS/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1085:../src/RTOS/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1086:../src/RTOS/queue.c **** 	interrupts, only tasks. */
1087:../src/RTOS/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NU
 952              		.loc 1 1087 0 is_stmt 1
 953 0020 3B6A     		ldr	r3, [r7, #32]
 954 0022 1B68     		ldr	r3, [r3]
 955 0024 002B     		cmp	r3, #0
 956 0026 03D1     		bne	.L83
 957              		.loc 1 1087 0 is_stmt 0 discriminator 2
 958 0028 3B6A     		ldr	r3, [r7, #32]
 959 002a 5B68     		ldr	r3, [r3, #4]
 960 002c 002B     		cmp	r3, #0
 961 002e 01D1     		bne	.L84
 962              	.L83:
 963              		.loc 1 1087 0 discriminator 3
 964 0030 0123     		movs	r3, #1
 965 0032 00E0     		b	.L85
 966              	.L84:
 967              		.loc 1 1087 0 discriminator 4
 968 0034 0023     		movs	r3, #0
 969              	.L85:
 970              		.loc 1 1087 0 discriminator 6
 971 0036 002B     		cmp	r3, #0
 972 0038 00D1     		bne	.L86
 973              	.L87:
 974              		.loc 1 1087 0 discriminator 3
 975 003a FEE7     		b	.L87
 976              	.L86:
1088:../src/RTOS/queue.c **** 
1089:../src/RTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1090:../src/RTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1091:../src/RTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1092:../src/RTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1093:../src/RTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1094:../src/RTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1095:../src/RTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1096:../src/RTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1097:../src/RTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1098:../src/RTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1099:../src/RTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1100:../src/RTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1101:../src/RTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1102:../src/RTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1103:../src/RTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 977              		.loc 1 1103 0 is_stmt 1
 978 003c FFF7FEFF 		bl	vPortValidateInterruptPriority
 979              	.LBB28:
 980              	.LBB29:
 253:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 981              		.loc 2 253 0
 982              	@ 253 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 983 0040 EFF31182 			mrs r2, basepri											
 984 0044 4FF0BF03 		mov r3, #191												
 985 0048 83F31188 		msr basepri, r3											
 986 004c BFF36F8F 		isb														
 987 0050 BFF34F8F 		dsb														
 988              	
 989              	@ 0 "" 2
 990              		.thumb
 991 0054 3A61     		str	r2, [r7, #16]
 992 0056 FB60     		str	r3, [r7, #12]
 265:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 993              		.loc 2 265 0
 994 0058 3B69     		ldr	r3, [r7, #16]
 995              	.LBE29:
 996              	.LBE28:
1104:../src/RTOS/queue.c **** 
1105:../src/RTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 997              		.loc 1 1105 0
 998 005a FB61     		str	r3, [r7, #28]
 999              	.LBB30:
1106:../src/RTOS/queue.c **** 	{
1107:../src/RTOS/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1000              		.loc 1 1107 0
 1001 005c 3B6A     		ldr	r3, [r7, #32]
 1002 005e 9B6B     		ldr	r3, [r3, #56]
 1003 0060 BB61     		str	r3, [r7, #24]
1108:../src/RTOS/queue.c **** 
1109:../src/RTOS/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1110:../src/RTOS/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1111:../src/RTOS/queue.c **** 		space'. */
1112:../src/RTOS/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
 1004              		.loc 1 1112 0
 1005 0062 3B6A     		ldr	r3, [r7, #32]
 1006 0064 DA6B     		ldr	r2, [r3, #60]
 1007 0066 BB69     		ldr	r3, [r7, #24]
 1008 0068 9A42     		cmp	r2, r3
 1009 006a 29D9     		bls	.L89
 1010              	.LBB31:
1113:../src/RTOS/queue.c **** 		{
1114:../src/RTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1011              		.loc 1 1114 0
 1012 006c 3B6A     		ldr	r3, [r7, #32]
 1013 006e 93F84530 		ldrb	r3, [r3, #69]
 1014 0072 FB75     		strb	r3, [r7, #23]
1115:../src/RTOS/queue.c **** 
1116:../src/RTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1117:../src/RTOS/queue.c **** 
1118:../src/RTOS/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1119:../src/RTOS/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1120:../src/RTOS/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1121:../src/RTOS/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1122:../src/RTOS/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1123:../src/RTOS/queue.c **** 			messages (semaphores) available. */
1124:../src/RTOS/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 1015              		.loc 1 1124 0
 1016 0074 BB69     		ldr	r3, [r7, #24]
 1017 0076 5A1C     		adds	r2, r3, #1
 1018 0078 3B6A     		ldr	r3, [r7, #32]
 1019 007a 9A63     		str	r2, [r3, #56]
1125:../src/RTOS/queue.c **** 
1126:../src/RTOS/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1127:../src/RTOS/queue.c **** 			be done when the queue is unlocked later. */
1128:../src/RTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1020              		.loc 1 1128 0
 1021 007c 97F91730 		ldrsb	r3, [r7, #23]
 1022 0080 B3F1FF3F 		cmp	r3, #-1
 1023 0084 12D1     		bne	.L90
1129:../src/RTOS/queue.c **** 			{
1130:../src/RTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1131:../src/RTOS/queue.c **** 				{
1132:../src/RTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1133:../src/RTOS/queue.c **** 					{
1134:../src/RTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1135:../src/RTOS/queue.c **** 						{
1136:../src/RTOS/queue.c **** 							/* The semaphore is a member of a queue set, and
1137:../src/RTOS/queue.c **** 							posting	to the queue set caused a higher priority
1138:../src/RTOS/queue.c **** 							task to	unblock.  A context switch is required. */
1139:../src/RTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1140:../src/RTOS/queue.c **** 							{
1141:../src/RTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1142:../src/RTOS/queue.c **** 							}
1143:../src/RTOS/queue.c **** 							else
1144:../src/RTOS/queue.c **** 							{
1145:../src/RTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1146:../src/RTOS/queue.c **** 							}
1147:../src/RTOS/queue.c **** 						}
1148:../src/RTOS/queue.c **** 						else
1149:../src/RTOS/queue.c **** 						{
1150:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1151:../src/RTOS/queue.c **** 						}
1152:../src/RTOS/queue.c **** 					}
1153:../src/RTOS/queue.c **** 					else
1154:../src/RTOS/queue.c **** 					{
1155:../src/RTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1156:../src/RTOS/queue.c **** 						{
1157:../src/RTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1158:../src/RTOS/queue.c **** 							{
1159:../src/RTOS/queue.c **** 								/* The task waiting has a higher priority so
1160:../src/RTOS/queue.c **** 								record that a context switch is required. */
1161:../src/RTOS/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1162:../src/RTOS/queue.c **** 								{
1163:../src/RTOS/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1164:../src/RTOS/queue.c **** 								}
1165:../src/RTOS/queue.c **** 								else
1166:../src/RTOS/queue.c **** 								{
1167:../src/RTOS/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1168:../src/RTOS/queue.c **** 								}
1169:../src/RTOS/queue.c **** 							}
1170:../src/RTOS/queue.c **** 							else
1171:../src/RTOS/queue.c **** 							{
1172:../src/RTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1173:../src/RTOS/queue.c **** 							}
1174:../src/RTOS/queue.c **** 						}
1175:../src/RTOS/queue.c **** 						else
1176:../src/RTOS/queue.c **** 						{
1177:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1178:../src/RTOS/queue.c **** 						}
1179:../src/RTOS/queue.c **** 					}
1180:../src/RTOS/queue.c **** 				}
1181:../src/RTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1182:../src/RTOS/queue.c **** 				{
1183:../src/RTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1024              		.loc 1 1183 0
 1025 0086 3B6A     		ldr	r3, [r7, #32]
 1026 0088 5B6A     		ldr	r3, [r3, #36]
 1027 008a 002B     		cmp	r3, #0
 1028 008c 15D0     		beq	.L91
1184:../src/RTOS/queue.c **** 					{
1185:../src/RTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1029              		.loc 1 1185 0
 1030 008e 3B6A     		ldr	r3, [r7, #32]
 1031 0090 2433     		adds	r3, r3, #36
 1032 0092 1846     		mov	r0, r3
 1033 0094 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1034 0098 0346     		mov	r3, r0
 1035 009a 002B     		cmp	r3, #0
 1036 009c 0DD0     		beq	.L91
1186:../src/RTOS/queue.c **** 						{
1187:../src/RTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1188:../src/RTOS/queue.c **** 							context	switch is required. */
1189:../src/RTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1037              		.loc 1 1189 0
 1038 009e 3B68     		ldr	r3, [r7]
 1039 00a0 002B     		cmp	r3, #0
 1040 00a2 0AD0     		beq	.L91
1190:../src/RTOS/queue.c **** 							{
1191:../src/RTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1041              		.loc 1 1191 0
 1042 00a4 3B68     		ldr	r3, [r7]
 1043 00a6 0122     		movs	r2, #1
 1044 00a8 1A60     		str	r2, [r3]
 1045 00aa 06E0     		b	.L91
 1046              	.L90:
1192:../src/RTOS/queue.c **** 							}
1193:../src/RTOS/queue.c **** 							else
1194:../src/RTOS/queue.c **** 							{
1195:../src/RTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1196:../src/RTOS/queue.c **** 							}
1197:../src/RTOS/queue.c **** 						}
1198:../src/RTOS/queue.c **** 						else
1199:../src/RTOS/queue.c **** 						{
1200:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1201:../src/RTOS/queue.c **** 						}
1202:../src/RTOS/queue.c **** 					}
1203:../src/RTOS/queue.c **** 					else
1204:../src/RTOS/queue.c **** 					{
1205:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1206:../src/RTOS/queue.c **** 					}
1207:../src/RTOS/queue.c **** 				}
1208:../src/RTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1209:../src/RTOS/queue.c **** 			}
1210:../src/RTOS/queue.c **** 			else
1211:../src/RTOS/queue.c **** 			{
1212:../src/RTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1213:../src/RTOS/queue.c **** 				knows that data was posted while it was locked. */
1214:../src/RTOS/queue.c **** 				pxQueue->cTxLock = cTxLock + 1;
 1047              		.loc 1 1214 0
 1048 00ac FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1049 00ae 0133     		adds	r3, r3, #1
 1050 00b0 DBB2     		uxtb	r3, r3
 1051 00b2 DAB2     		uxtb	r2, r3
 1052 00b4 3B6A     		ldr	r3, [r7, #32]
 1053 00b6 83F84520 		strb	r2, [r3, #69]
 1054              	.L91:
1215:../src/RTOS/queue.c **** 			}
1216:../src/RTOS/queue.c **** 
1217:../src/RTOS/queue.c **** 			xReturn = pdPASS;
 1055              		.loc 1 1217 0
 1056 00ba 0123     		movs	r3, #1
 1057 00bc 7B62     		str	r3, [r7, #36]
 1058              	.LBE31:
 1059 00be 01E0     		b	.L92
 1060              	.L89:
1218:../src/RTOS/queue.c **** 		}
1219:../src/RTOS/queue.c **** 		else
1220:../src/RTOS/queue.c **** 		{
1221:../src/RTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1222:../src/RTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 1061              		.loc 1 1222 0
 1062 00c0 0023     		movs	r3, #0
 1063 00c2 7B62     		str	r3, [r7, #36]
 1064              	.L92:
 1065 00c4 FB69     		ldr	r3, [r7, #28]
 1066 00c6 BB60     		str	r3, [r7, #8]
 1067              	.LBE30:
 1068              	.LBB32:
 1069              	.LBB33:
 1070              		.loc 2 271 0
 1071 00c8 BB68     		ldr	r3, [r7, #8]
 1072              	@ 271 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 1073 00ca 83F31188 			msr basepri, r3	
 1074              	@ 0 "" 2
 1075              		.thumb
 1076              	.LBE33:
 1077              	.LBE32:
1223:../src/RTOS/queue.c **** 		}
1224:../src/RTOS/queue.c **** 	}
1225:../src/RTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1226:../src/RTOS/queue.c **** 
1227:../src/RTOS/queue.c **** 	return xReturn;
 1078              		.loc 1 1227 0
 1079 00ce 7B6A     		ldr	r3, [r7, #36]
1228:../src/RTOS/queue.c **** }
 1080              		.loc 1 1228 0
 1081 00d0 1846     		mov	r0, r3
 1082 00d2 2837     		adds	r7, r7, #40
 1083              		.cfi_def_cfa_offset 8
 1084 00d4 BD46     		mov	sp, r7
 1085              		.cfi_def_cfa_register 13
 1086              		@ sp needed
 1087 00d6 80BD     		pop	{r7, pc}
 1088              		.cfi_endproc
 1089              	.LFE11:
 1091              		.section	.text.xQueueGenericReceive,"ax",%progbits
 1092              		.align	2
 1093              		.global	xQueueGenericReceive
 1094              		.thumb
 1095              		.thumb_func
 1097              	xQueueGenericReceive:
 1098              	.LFB12:
1229:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1230:../src/RTOS/queue.c **** 
1231:../src/RTOS/queue.c **** BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWa
1232:../src/RTOS/queue.c **** {
 1099              		.loc 1 1232 0
 1100              		.cfi_startproc
 1101              		@ args = 0, pretend = 0, frame = 40
 1102              		@ frame_needed = 1, uses_anonymous_args = 0
 1103 0000 80B5     		push	{r7, lr}
 1104              		.cfi_def_cfa_offset 8
 1105              		.cfi_offset 7, -8
 1106              		.cfi_offset 14, -4
 1107 0002 8AB0     		sub	sp, sp, #40
 1108              		.cfi_def_cfa_offset 48
 1109 0004 00AF     		add	r7, sp, #0
 1110              		.cfi_def_cfa_register 7
 1111 0006 F860     		str	r0, [r7, #12]
 1112 0008 B960     		str	r1, [r7, #8]
 1113 000a 7A60     		str	r2, [r7, #4]
 1114 000c 3B60     		str	r3, [r7]
1233:../src/RTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1115              		.loc 1 1233 0
 1116 000e 0023     		movs	r3, #0
 1117 0010 7B62     		str	r3, [r7, #36]
1234:../src/RTOS/queue.c **** TimeOut_t xTimeOut;
1235:../src/RTOS/queue.c **** int8_t *pcOriginalReadPosition;
1236:../src/RTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1118              		.loc 1 1236 0
 1119 0012 FB68     		ldr	r3, [r7, #12]
 1120 0014 3B62     		str	r3, [r7, #32]
1237:../src/RTOS/queue.c **** 
1238:../src/RTOS/queue.c **** 	configASSERT( pxQueue );
 1121              		.loc 1 1238 0
 1122 0016 3B6A     		ldr	r3, [r7, #32]
 1123 0018 002B     		cmp	r3, #0
 1124 001a 00D1     		bne	.L95
 1125              	.L96:
 1126              		.loc 1 1238 0 is_stmt 0 discriminator 1
 1127 001c FEE7     		b	.L96
 1128              	.L95:
1239:../src/RTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1129              		.loc 1 1239 0 is_stmt 1
 1130 001e BB68     		ldr	r3, [r7, #8]
 1131 0020 002B     		cmp	r3, #0
 1132 0022 03D1     		bne	.L97
 1133              		.loc 1 1239 0 is_stmt 0 discriminator 2
 1134 0024 3B6A     		ldr	r3, [r7, #32]
 1135 0026 1B6C     		ldr	r3, [r3, #64]
 1136 0028 002B     		cmp	r3, #0
 1137 002a 01D1     		bne	.L98
 1138              	.L97:
 1139              		.loc 1 1239 0 discriminator 3
 1140 002c 0123     		movs	r3, #1
 1141 002e 00E0     		b	.L99
 1142              	.L98:
 1143              		.loc 1 1239 0 discriminator 4
 1144 0030 0023     		movs	r3, #0
 1145              	.L99:
 1146              		.loc 1 1239 0 discriminator 6
 1147 0032 002B     		cmp	r3, #0
 1148 0034 00D1     		bne	.L100
 1149              	.L101:
 1150              		.loc 1 1239 0 discriminator 2
 1151 0036 FEE7     		b	.L101
 1152              	.L100:
1240:../src/RTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1241:../src/RTOS/queue.c **** 	{
1242:../src/RTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 1153              		.loc 1 1242 0 is_stmt 1
 1154 0038 FFF7FEFF 		bl	xTaskGetSchedulerState
 1155 003c 0346     		mov	r3, r0
 1156 003e 002B     		cmp	r3, #0
 1157 0040 02D1     		bne	.L102
 1158              		.loc 1 1242 0 is_stmt 0 discriminator 2
 1159 0042 7B68     		ldr	r3, [r7, #4]
 1160 0044 002B     		cmp	r3, #0
 1161 0046 01D1     		bne	.L103
 1162              	.L102:
 1163              		.loc 1 1242 0 discriminator 3
 1164 0048 0123     		movs	r3, #1
 1165 004a 00E0     		b	.L104
 1166              	.L103:
 1167              		.loc 1 1242 0 discriminator 4
 1168 004c 0023     		movs	r3, #0
 1169              	.L104:
 1170              		.loc 1 1242 0 discriminator 6
 1171 004e 002B     		cmp	r3, #0
 1172 0050 00D1     		bne	.L105
 1173              	.L106:
 1174              		.loc 1 1242 0 discriminator 3
 1175 0052 FEE7     		b	.L106
 1176              	.L105:
1243:../src/RTOS/queue.c **** 	}
1244:../src/RTOS/queue.c **** 	#endif
1245:../src/RTOS/queue.c **** 
1246:../src/RTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1247:../src/RTOS/queue.c **** 	statements within the function itself.  This is done in the interest
1248:../src/RTOS/queue.c **** 	of execution time efficiency. */
1249:../src/RTOS/queue.c **** 
1250:../src/RTOS/queue.c **** 	for( ;; )
1251:../src/RTOS/queue.c **** 	{
1252:../src/RTOS/queue.c **** 		taskENTER_CRITICAL();
 1177              		.loc 1 1252 0 is_stmt 1
 1178 0054 FFF7FEFF 		bl	vPortEnterCritical
 1179              	.LBB34:
1253:../src/RTOS/queue.c **** 		{
1254:../src/RTOS/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1180              		.loc 1 1254 0
 1181 0058 3B6A     		ldr	r3, [r7, #32]
 1182 005a 9B6B     		ldr	r3, [r3, #56]
 1183 005c FB61     		str	r3, [r7, #28]
1255:../src/RTOS/queue.c **** 
1256:../src/RTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1257:../src/RTOS/queue.c **** 			must be the highest priority task wanting to access the queue. */
1258:../src/RTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1184              		.loc 1 1258 0
 1185 005e FB69     		ldr	r3, [r7, #28]
 1186 0060 002B     		cmp	r3, #0
 1187 0062 46D0     		beq	.L107
1259:../src/RTOS/queue.c **** 			{
1260:../src/RTOS/queue.c **** 				/* Remember the read position in case the queue is only being
1261:../src/RTOS/queue.c **** 				peeked. */
1262:../src/RTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1188              		.loc 1 1262 0
 1189 0064 3B6A     		ldr	r3, [r7, #32]
 1190 0066 DB68     		ldr	r3, [r3, #12]
 1191 0068 BB61     		str	r3, [r7, #24]
1263:../src/RTOS/queue.c **** 
1264:../src/RTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1192              		.loc 1 1264 0
 1193 006a 386A     		ldr	r0, [r7, #32]
 1194 006c B968     		ldr	r1, [r7, #8]
 1195 006e FFF7FEFF 		bl	prvCopyDataFromQueue
1265:../src/RTOS/queue.c **** 
1266:../src/RTOS/queue.c **** 				if( xJustPeeking == pdFALSE )
 1196              		.loc 1 1266 0
 1197 0072 3B68     		ldr	r3, [r7]
 1198 0074 002B     		cmp	r3, #0
 1199 0076 21D1     		bne	.L108
1267:../src/RTOS/queue.c **** 				{
1268:../src/RTOS/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1269:../src/RTOS/queue.c **** 
1270:../src/RTOS/queue.c **** 					/* Actually removing data, not just peeking. */
1271:../src/RTOS/queue.c **** 					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 1200              		.loc 1 1271 0
 1201 0078 FB69     		ldr	r3, [r7, #28]
 1202 007a 5A1E     		subs	r2, r3, #1
 1203 007c 3B6A     		ldr	r3, [r7, #32]
 1204 007e 9A63     		str	r2, [r3, #56]
1272:../src/RTOS/queue.c **** 
1273:../src/RTOS/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1274:../src/RTOS/queue.c **** 					{
1275:../src/RTOS/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1205              		.loc 1 1275 0
 1206 0080 3B6A     		ldr	r3, [r7, #32]
 1207 0082 1B68     		ldr	r3, [r3]
 1208 0084 002B     		cmp	r3, #0
 1209 0086 04D1     		bne	.L109
1276:../src/RTOS/queue.c **** 						{
1277:../src/RTOS/queue.c **** 							/* Record the information required to implement
1278:../src/RTOS/queue.c **** 							priority inheritance should it become necessary. */
1279:../src/RTOS/queue.c **** 							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is 
 1210              		.loc 1 1279 0
 1211 0088 FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 1212 008c 0246     		mov	r2, r0
 1213 008e 3B6A     		ldr	r3, [r7, #32]
 1214 0090 5A60     		str	r2, [r3, #4]
 1215              	.L109:
1280:../src/RTOS/queue.c **** 						}
1281:../src/RTOS/queue.c **** 						else
1282:../src/RTOS/queue.c **** 						{
1283:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1284:../src/RTOS/queue.c **** 						}
1285:../src/RTOS/queue.c **** 					}
1286:../src/RTOS/queue.c **** 					#endif /* configUSE_MUTEXES */
1287:../src/RTOS/queue.c **** 
1288:../src/RTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1216              		.loc 1 1288 0
 1217 0092 3B6A     		ldr	r3, [r7, #32]
 1218 0094 1B69     		ldr	r3, [r3, #16]
 1219 0096 002B     		cmp	r3, #0
 1220 0098 27D0     		beq	.L110
1289:../src/RTOS/queue.c **** 					{
1290:../src/RTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1221              		.loc 1 1290 0
 1222 009a 3B6A     		ldr	r3, [r7, #32]
 1223 009c 1033     		adds	r3, r3, #16
 1224 009e 1846     		mov	r0, r3
 1225 00a0 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1226 00a4 0346     		mov	r3, r0
 1227 00a6 002B     		cmp	r3, #0
 1228 00a8 1FD0     		beq	.L110
1291:../src/RTOS/queue.c **** 						{
1292:../src/RTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1229              		.loc 1 1292 0
 1230 00aa 514B     		ldr	r3, .L122
 1231 00ac 4FF08052 		mov	r2, #268435456
 1232 00b0 1A60     		str	r2, [r3]
 1233              	@ 1292 "../src/RTOS/queue.c" 1
 1234 00b2 BFF34F8F 		dsb
 1235              	@ 0 "" 2
 1236              	@ 1292 "../src/RTOS/queue.c" 1
 1237 00b6 BFF36F8F 		isb
 1238              	@ 0 "" 2
 1239              		.thumb
 1240 00ba 16E0     		b	.L110
 1241              	.L108:
1293:../src/RTOS/queue.c **** 						}
1294:../src/RTOS/queue.c **** 						else
1295:../src/RTOS/queue.c **** 						{
1296:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1297:../src/RTOS/queue.c **** 						}
1298:../src/RTOS/queue.c **** 					}
1299:../src/RTOS/queue.c **** 					else
1300:../src/RTOS/queue.c **** 					{
1301:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1302:../src/RTOS/queue.c **** 					}
1303:../src/RTOS/queue.c **** 				}
1304:../src/RTOS/queue.c **** 				else
1305:../src/RTOS/queue.c **** 				{
1306:../src/RTOS/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1307:../src/RTOS/queue.c **** 
1308:../src/RTOS/queue.c **** 					/* The data is not being removed, so reset the read
1309:../src/RTOS/queue.c **** 					pointer. */
1310:../src/RTOS/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1242              		.loc 1 1310 0
 1243 00bc 3B6A     		ldr	r3, [r7, #32]
 1244 00be BA69     		ldr	r2, [r7, #24]
 1245 00c0 DA60     		str	r2, [r3, #12]
1311:../src/RTOS/queue.c **** 
1312:../src/RTOS/queue.c **** 					/* The data is being left in the queue, so see if there are
1313:../src/RTOS/queue.c **** 					any other tasks waiting for the data. */
1314:../src/RTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1246              		.loc 1 1314 0
 1247 00c2 3B6A     		ldr	r3, [r7, #32]
 1248 00c4 5B6A     		ldr	r3, [r3, #36]
 1249 00c6 002B     		cmp	r3, #0
 1250 00c8 0FD0     		beq	.L110
1315:../src/RTOS/queue.c **** 					{
1316:../src/RTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1251              		.loc 1 1316 0
 1252 00ca 3B6A     		ldr	r3, [r7, #32]
 1253 00cc 2433     		adds	r3, r3, #36
 1254 00ce 1846     		mov	r0, r3
 1255 00d0 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1256 00d4 0346     		mov	r3, r0
 1257 00d6 002B     		cmp	r3, #0
 1258 00d8 07D0     		beq	.L110
1317:../src/RTOS/queue.c **** 						{
1318:../src/RTOS/queue.c **** 							/* The task waiting has a higher priority than this task. */
1319:../src/RTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1259              		.loc 1 1319 0
 1260 00da 454B     		ldr	r3, .L122
 1261 00dc 4FF08052 		mov	r2, #268435456
 1262 00e0 1A60     		str	r2, [r3]
 1263              	@ 1319 "../src/RTOS/queue.c" 1
 1264 00e2 BFF34F8F 		dsb
 1265              	@ 0 "" 2
 1266              	@ 1319 "../src/RTOS/queue.c" 1
 1267 00e6 BFF36F8F 		isb
 1268              	@ 0 "" 2
 1269              		.thumb
 1270              	.L110:
1320:../src/RTOS/queue.c **** 						}
1321:../src/RTOS/queue.c **** 						else
1322:../src/RTOS/queue.c **** 						{
1323:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1324:../src/RTOS/queue.c **** 						}
1325:../src/RTOS/queue.c **** 					}
1326:../src/RTOS/queue.c **** 					else
1327:../src/RTOS/queue.c **** 					{
1328:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1329:../src/RTOS/queue.c **** 					}
1330:../src/RTOS/queue.c **** 				}
1331:../src/RTOS/queue.c **** 
1332:../src/RTOS/queue.c **** 				taskEXIT_CRITICAL();
 1271              		.loc 1 1332 0
 1272 00ea FFF7FEFF 		bl	vPortExitCritical
1333:../src/RTOS/queue.c **** 				return pdPASS;
 1273              		.loc 1 1333 0
 1274 00ee 0123     		movs	r3, #1
 1275 00f0 7AE0     		b	.L121
 1276              	.L107:
1334:../src/RTOS/queue.c **** 			}
1335:../src/RTOS/queue.c **** 			else
1336:../src/RTOS/queue.c **** 			{
1337:../src/RTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1277              		.loc 1 1337 0
 1278 00f2 7B68     		ldr	r3, [r7, #4]
 1279 00f4 002B     		cmp	r3, #0
 1280 00f6 03D1     		bne	.L112
1338:../src/RTOS/queue.c **** 				{
1339:../src/RTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
1340:../src/RTOS/queue.c **** 					the block time has expired) so leave now. */
1341:../src/RTOS/queue.c **** 					taskEXIT_CRITICAL();
 1281              		.loc 1 1341 0
 1282 00f8 FFF7FEFF 		bl	vPortExitCritical
1342:../src/RTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1343:../src/RTOS/queue.c **** 					return errQUEUE_EMPTY;
 1283              		.loc 1 1343 0
 1284 00fc 0023     		movs	r3, #0
 1285 00fe 73E0     		b	.L121
 1286              	.L112:
1344:../src/RTOS/queue.c **** 				}
1345:../src/RTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1287              		.loc 1 1345 0
 1288 0100 7B6A     		ldr	r3, [r7, #36]
 1289 0102 002B     		cmp	r3, #0
 1290 0104 06D1     		bne	.L113
1346:../src/RTOS/queue.c **** 				{
1347:../src/RTOS/queue.c **** 					/* The queue was empty and a block time was specified so
1348:../src/RTOS/queue.c **** 					configure the timeout structure. */
1349:../src/RTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1291              		.loc 1 1349 0
 1292 0106 07F11003 		add	r3, r7, #16
 1293 010a 1846     		mov	r0, r3
 1294 010c FFF7FEFF 		bl	vTaskSetTimeOutState
1350:../src/RTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 1295              		.loc 1 1350 0
 1296 0110 0123     		movs	r3, #1
 1297 0112 7B62     		str	r3, [r7, #36]
 1298              	.L113:
 1299              	.LBE34:
1351:../src/RTOS/queue.c **** 				}
1352:../src/RTOS/queue.c **** 				else
1353:../src/RTOS/queue.c **** 				{
1354:../src/RTOS/queue.c **** 					/* Entry time was already set. */
1355:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1356:../src/RTOS/queue.c **** 				}
1357:../src/RTOS/queue.c **** 			}
1358:../src/RTOS/queue.c **** 		}
1359:../src/RTOS/queue.c **** 		taskEXIT_CRITICAL();
 1300              		.loc 1 1359 0
 1301 0114 FFF7FEFF 		bl	vPortExitCritical
1360:../src/RTOS/queue.c **** 
1361:../src/RTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1362:../src/RTOS/queue.c **** 		now the critical section has been exited. */
1363:../src/RTOS/queue.c **** 
1364:../src/RTOS/queue.c **** 		vTaskSuspendAll();
 1302              		.loc 1 1364 0
 1303 0118 FFF7FEFF 		bl	vTaskSuspendAll
1365:../src/RTOS/queue.c **** 		prvLockQueue( pxQueue );
 1304              		.loc 1 1365 0
 1305 011c FFF7FEFF 		bl	vPortEnterCritical
 1306 0120 3B6A     		ldr	r3, [r7, #32]
 1307 0122 93F84430 		ldrb	r3, [r3, #68]
 1308 0126 DBB2     		uxtb	r3, r3
 1309 0128 5BB2     		sxtb	r3, r3
 1310 012a B3F1FF3F 		cmp	r3, #-1
 1311 012e 03D1     		bne	.L114
 1312              		.loc 1 1365 0 is_stmt 0 discriminator 1
 1313 0130 3B6A     		ldr	r3, [r7, #32]
 1314 0132 0022     		movs	r2, #0
 1315 0134 83F84420 		strb	r2, [r3, #68]
 1316              	.L114:
 1317              		.loc 1 1365 0 discriminator 3
 1318 0138 3B6A     		ldr	r3, [r7, #32]
 1319 013a 93F84530 		ldrb	r3, [r3, #69]
 1320 013e DBB2     		uxtb	r3, r3
 1321 0140 5BB2     		sxtb	r3, r3
 1322 0142 B3F1FF3F 		cmp	r3, #-1
 1323 0146 03D1     		bne	.L115
 1324              		.loc 1 1365 0 discriminator 4
 1325 0148 3B6A     		ldr	r3, [r7, #32]
 1326 014a 0022     		movs	r2, #0
 1327 014c 83F84520 		strb	r2, [r3, #69]
 1328              	.L115:
 1329              		.loc 1 1365 0 discriminator 6
 1330 0150 FFF7FEFF 		bl	vPortExitCritical
1366:../src/RTOS/queue.c **** 
1367:../src/RTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1368:../src/RTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1331              		.loc 1 1368 0 is_stmt 1 discriminator 6
 1332 0154 07F11002 		add	r2, r7, #16
 1333 0158 3B1D     		adds	r3, r7, #4
 1334 015a 1046     		mov	r0, r2
 1335 015c 1946     		mov	r1, r3
 1336 015e FFF7FEFF 		bl	xTaskCheckForTimeOut
 1337 0162 0346     		mov	r3, r0
 1338 0164 002B     		cmp	r3, #0
 1339 0166 31D1     		bne	.L116
1369:../src/RTOS/queue.c **** 		{
1370:../src/RTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1340              		.loc 1 1370 0
 1341 0168 386A     		ldr	r0, [r7, #32]
 1342 016a FFF7FEFF 		bl	prvIsQueueEmpty
 1343 016e 0346     		mov	r3, r0
 1344 0170 002B     		cmp	r3, #0
 1345 0172 25D0     		beq	.L117
1371:../src/RTOS/queue.c **** 			{
1372:../src/RTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1373:../src/RTOS/queue.c **** 
1374:../src/RTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1375:../src/RTOS/queue.c **** 				{
1376:../src/RTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1346              		.loc 1 1376 0
 1347 0174 3B6A     		ldr	r3, [r7, #32]
 1348 0176 1B68     		ldr	r3, [r3]
 1349 0178 002B     		cmp	r3, #0
 1350 017a 08D1     		bne	.L118
1377:../src/RTOS/queue.c **** 					{
1378:../src/RTOS/queue.c **** 						taskENTER_CRITICAL();
 1351              		.loc 1 1378 0
 1352 017c FFF7FEFF 		bl	vPortEnterCritical
1379:../src/RTOS/queue.c **** 						{
1380:../src/RTOS/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 1353              		.loc 1 1380 0
 1354 0180 3B6A     		ldr	r3, [r7, #32]
 1355 0182 5B68     		ldr	r3, [r3, #4]
 1356 0184 1846     		mov	r0, r3
 1357 0186 FFF7FEFF 		bl	vTaskPriorityInherit
1381:../src/RTOS/queue.c **** 						}
1382:../src/RTOS/queue.c **** 						taskEXIT_CRITICAL();
 1358              		.loc 1 1382 0
 1359 018a FFF7FEFF 		bl	vPortExitCritical
 1360              	.L118:
1383:../src/RTOS/queue.c **** 					}
1384:../src/RTOS/queue.c **** 					else
1385:../src/RTOS/queue.c **** 					{
1386:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1387:../src/RTOS/queue.c **** 					}
1388:../src/RTOS/queue.c **** 				}
1389:../src/RTOS/queue.c **** 				#endif
1390:../src/RTOS/queue.c **** 
1391:../src/RTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1361              		.loc 1 1391 0
 1362 018e 3B6A     		ldr	r3, [r7, #32]
 1363 0190 03F12402 		add	r2, r3, #36
 1364 0194 7B68     		ldr	r3, [r7, #4]
 1365 0196 1046     		mov	r0, r2
 1366 0198 1946     		mov	r1, r3
 1367 019a FFF7FEFF 		bl	vTaskPlaceOnEventList
1392:../src/RTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1368              		.loc 1 1392 0
 1369 019e 386A     		ldr	r0, [r7, #32]
 1370 01a0 FFF7FEFF 		bl	prvUnlockQueue
1393:../src/RTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1371              		.loc 1 1393 0
 1372 01a4 FFF7FEFF 		bl	xTaskResumeAll
 1373 01a8 0346     		mov	r3, r0
 1374 01aa 002B     		cmp	r3, #0
 1375 01ac 1BD1     		bne	.L120
1394:../src/RTOS/queue.c **** 				{
1395:../src/RTOS/queue.c **** 					portYIELD_WITHIN_API();
 1376              		.loc 1 1395 0
 1377 01ae 104B     		ldr	r3, .L122
 1378 01b0 4FF08052 		mov	r2, #268435456
 1379 01b4 1A60     		str	r2, [r3]
 1380              	@ 1395 "../src/RTOS/queue.c" 1
 1381 01b6 BFF34F8F 		dsb
 1382              	@ 0 "" 2
 1383              	@ 1395 "../src/RTOS/queue.c" 1
 1384 01ba BFF36F8F 		isb
 1385              	@ 0 "" 2
 1386              		.thumb
 1387 01be 12E0     		b	.L120
 1388              	.L117:
1396:../src/RTOS/queue.c **** 				}
1397:../src/RTOS/queue.c **** 				else
1398:../src/RTOS/queue.c **** 				{
1399:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1400:../src/RTOS/queue.c **** 				}
1401:../src/RTOS/queue.c **** 			}
1402:../src/RTOS/queue.c **** 			else
1403:../src/RTOS/queue.c **** 			{
1404:../src/RTOS/queue.c **** 				/* Try again. */
1405:../src/RTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1389              		.loc 1 1405 0
 1390 01c0 386A     		ldr	r0, [r7, #32]
 1391 01c2 FFF7FEFF 		bl	prvUnlockQueue
1406:../src/RTOS/queue.c **** 				( void ) xTaskResumeAll();
 1392              		.loc 1 1406 0
 1393 01c6 FFF7FEFF 		bl	xTaskResumeAll
 1394 01ca 43E7     		b	.L105
 1395              	.L116:
1407:../src/RTOS/queue.c **** 			}
1408:../src/RTOS/queue.c **** 		}
1409:../src/RTOS/queue.c **** 		else
1410:../src/RTOS/queue.c **** 		{
1411:../src/RTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 1396              		.loc 1 1411 0
 1397 01cc 386A     		ldr	r0, [r7, #32]
 1398 01ce FFF7FEFF 		bl	prvUnlockQueue
1412:../src/RTOS/queue.c **** 			( void ) xTaskResumeAll();
 1399              		.loc 1 1412 0
 1400 01d2 FFF7FEFF 		bl	xTaskResumeAll
1413:../src/RTOS/queue.c **** 
1414:../src/RTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1401              		.loc 1 1414 0
 1402 01d6 386A     		ldr	r0, [r7, #32]
 1403 01d8 FFF7FEFF 		bl	prvIsQueueEmpty
 1404 01dc 0346     		mov	r3, r0
 1405 01de 002B     		cmp	r3, #0
 1406 01e0 01D0     		beq	.L120
1415:../src/RTOS/queue.c **** 			{
1416:../src/RTOS/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1417:../src/RTOS/queue.c **** 				return errQUEUE_EMPTY;
 1407              		.loc 1 1417 0
 1408 01e2 0023     		movs	r3, #0
 1409 01e4 00E0     		b	.L121
 1410              	.L120:
1418:../src/RTOS/queue.c **** 			}
1419:../src/RTOS/queue.c **** 			else
1420:../src/RTOS/queue.c **** 			{
1421:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1422:../src/RTOS/queue.c **** 			}
1423:../src/RTOS/queue.c **** 		}
1424:../src/RTOS/queue.c **** 	}
 1411              		.loc 1 1424 0 discriminator 6
 1412 01e6 35E7     		b	.L105
 1413              	.L121:
1425:../src/RTOS/queue.c **** }
 1414              		.loc 1 1425 0 discriminator 7
 1415 01e8 1846     		mov	r0, r3
 1416 01ea 2837     		adds	r7, r7, #40
 1417              		.cfi_def_cfa_offset 8
 1418 01ec BD46     		mov	sp, r7
 1419              		.cfi_def_cfa_register 13
 1420              		@ sp needed
 1421 01ee 80BD     		pop	{r7, pc}
 1422              	.L123:
 1423              		.align	2
 1424              	.L122:
 1425 01f0 04ED00E0 		.word	-536810236
 1426              		.cfi_endproc
 1427              	.LFE12:
 1429              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1430              		.align	2
 1431              		.global	xQueueReceiveFromISR
 1432              		.thumb
 1433              		.thumb_func
 1435              	xQueueReceiveFromISR:
 1436              	.LFB13:
1426:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1427:../src/RTOS/queue.c **** 
1428:../src/RTOS/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1429:../src/RTOS/queue.c **** {
 1437              		.loc 1 1429 0
 1438              		.cfi_startproc
 1439              		@ args = 0, pretend = 0, frame = 48
 1440              		@ frame_needed = 1, uses_anonymous_args = 0
 1441 0000 80B5     		push	{r7, lr}
 1442              		.cfi_def_cfa_offset 8
 1443              		.cfi_offset 7, -8
 1444              		.cfi_offset 14, -4
 1445 0002 8CB0     		sub	sp, sp, #48
 1446              		.cfi_def_cfa_offset 56
 1447 0004 00AF     		add	r7, sp, #0
 1448              		.cfi_def_cfa_register 7
 1449 0006 F860     		str	r0, [r7, #12]
 1450 0008 B960     		str	r1, [r7, #8]
 1451 000a 7A60     		str	r2, [r7, #4]
1430:../src/RTOS/queue.c **** BaseType_t xReturn;
1431:../src/RTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1432:../src/RTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1452              		.loc 1 1432 0
 1453 000c FB68     		ldr	r3, [r7, #12]
 1454 000e BB62     		str	r3, [r7, #40]
1433:../src/RTOS/queue.c **** 
1434:../src/RTOS/queue.c **** 	configASSERT( pxQueue );
 1455              		.loc 1 1434 0
 1456 0010 BB6A     		ldr	r3, [r7, #40]
 1457 0012 002B     		cmp	r3, #0
 1458 0014 00D1     		bne	.L125
 1459              	.L126:
 1460              		.loc 1 1434 0 is_stmt 0 discriminator 1
 1461 0016 FEE7     		b	.L126
 1462              	.L125:
1435:../src/RTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1463              		.loc 1 1435 0 is_stmt 1
 1464 0018 BB68     		ldr	r3, [r7, #8]
 1465 001a 002B     		cmp	r3, #0
 1466 001c 03D1     		bne	.L127
 1467              		.loc 1 1435 0 is_stmt 0 discriminator 2
 1468 001e BB6A     		ldr	r3, [r7, #40]
 1469 0020 1B6C     		ldr	r3, [r3, #64]
 1470 0022 002B     		cmp	r3, #0
 1471 0024 01D1     		bne	.L128
 1472              	.L127:
 1473              		.loc 1 1435 0 discriminator 3
 1474 0026 0123     		movs	r3, #1
 1475 0028 00E0     		b	.L129
 1476              	.L128:
 1477              		.loc 1 1435 0 discriminator 4
 1478 002a 0023     		movs	r3, #0
 1479              	.L129:
 1480              		.loc 1 1435 0 discriminator 6
 1481 002c 002B     		cmp	r3, #0
 1482 002e 00D1     		bne	.L130
 1483              	.L131:
 1484              		.loc 1 1435 0 discriminator 2
 1485 0030 FEE7     		b	.L131
 1486              	.L130:
1436:../src/RTOS/queue.c **** 
1437:../src/RTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1438:../src/RTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1439:../src/RTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1440:../src/RTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1441:../src/RTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1442:../src/RTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1443:../src/RTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1444:../src/RTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1445:../src/RTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1446:../src/RTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1447:../src/RTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1448:../src/RTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1449:../src/RTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1450:../src/RTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1451:../src/RTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1487              		.loc 1 1451 0 is_stmt 1
 1488 0032 FFF7FEFF 		bl	vPortValidateInterruptPriority
 1489              	.LBB35:
 1490              	.LBB36:
 253:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 1491              		.loc 2 253 0
 1492              	@ 253 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 1493 0036 EFF31182 			mrs r2, basepri											
 1494 003a 4FF0BF03 		mov r3, #191												
 1495 003e 83F31188 		msr basepri, r3											
 1496 0042 BFF36F8F 		isb														
 1497 0046 BFF34F8F 		dsb														
 1498              	
 1499              	@ 0 "" 2
 1500              		.thumb
 1501 004a BA61     		str	r2, [r7, #24]
 1502 004c 7B61     		str	r3, [r7, #20]
 265:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 1503              		.loc 2 265 0
 1504 004e BB69     		ldr	r3, [r7, #24]
 1505              	.LBE36:
 1506              	.LBE35:
1452:../src/RTOS/queue.c **** 
1453:../src/RTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1507              		.loc 1 1453 0
 1508 0050 7B62     		str	r3, [r7, #36]
 1509              	.LBB37:
1454:../src/RTOS/queue.c **** 	{
1455:../src/RTOS/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1510              		.loc 1 1455 0
 1511 0052 BB6A     		ldr	r3, [r7, #40]
 1512 0054 9B6B     		ldr	r3, [r3, #56]
 1513 0056 3B62     		str	r3, [r7, #32]
1456:../src/RTOS/queue.c **** 
1457:../src/RTOS/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1458:../src/RTOS/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1514              		.loc 1 1458 0
 1515 0058 3B6A     		ldr	r3, [r7, #32]
 1516 005a 002B     		cmp	r3, #0
 1517 005c 2DD0     		beq	.L133
 1518              	.LBB38:
1459:../src/RTOS/queue.c **** 		{
1460:../src/RTOS/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
 1519              		.loc 1 1460 0
 1520 005e BB6A     		ldr	r3, [r7, #40]
 1521 0060 93F84430 		ldrb	r3, [r3, #68]
 1522 0064 FB77     		strb	r3, [r7, #31]
1461:../src/RTOS/queue.c **** 
1462:../src/RTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1463:../src/RTOS/queue.c **** 
1464:../src/RTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1523              		.loc 1 1464 0
 1524 0066 B86A     		ldr	r0, [r7, #40]
 1525 0068 B968     		ldr	r1, [r7, #8]
 1526 006a FFF7FEFF 		bl	prvCopyDataFromQueue
1465:../src/RTOS/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 1527              		.loc 1 1465 0
 1528 006e 3B6A     		ldr	r3, [r7, #32]
 1529 0070 5A1E     		subs	r2, r3, #1
 1530 0072 BB6A     		ldr	r3, [r7, #40]
 1531 0074 9A63     		str	r2, [r3, #56]
1466:../src/RTOS/queue.c **** 
1467:../src/RTOS/queue.c **** 			/* If the queue is locked the event list will not be modified.
1468:../src/RTOS/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1469:../src/RTOS/queue.c **** 			will know that an ISR has removed data while the queue was
1470:../src/RTOS/queue.c **** 			locked. */
1471:../src/RTOS/queue.c **** 			if( cRxLock == queueUNLOCKED )
 1532              		.loc 1 1471 0
 1533 0076 97F91F30 		ldrsb	r3, [r7, #31]
 1534 007a B3F1FF3F 		cmp	r3, #-1
 1535 007e 12D1     		bne	.L134
1472:../src/RTOS/queue.c **** 			{
1473:../src/RTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1536              		.loc 1 1473 0
 1537 0080 BB6A     		ldr	r3, [r7, #40]
 1538 0082 1B69     		ldr	r3, [r3, #16]
 1539 0084 002B     		cmp	r3, #0
 1540 0086 15D0     		beq	.L135
1474:../src/RTOS/queue.c **** 				{
1475:../src/RTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1541              		.loc 1 1475 0
 1542 0088 BB6A     		ldr	r3, [r7, #40]
 1543 008a 1033     		adds	r3, r3, #16
 1544 008c 1846     		mov	r0, r3
 1545 008e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1546 0092 0346     		mov	r3, r0
 1547 0094 002B     		cmp	r3, #0
 1548 0096 0DD0     		beq	.L135
1476:../src/RTOS/queue.c **** 					{
1477:../src/RTOS/queue.c **** 						/* The task waiting has a higher priority than us so
1478:../src/RTOS/queue.c **** 						force a context switch. */
1479:../src/RTOS/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1549              		.loc 1 1479 0
 1550 0098 7B68     		ldr	r3, [r7, #4]
 1551 009a 002B     		cmp	r3, #0
 1552 009c 0AD0     		beq	.L135
1480:../src/RTOS/queue.c **** 						{
1481:../src/RTOS/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1553              		.loc 1 1481 0
 1554 009e 7B68     		ldr	r3, [r7, #4]
 1555 00a0 0122     		movs	r2, #1
 1556 00a2 1A60     		str	r2, [r3]
 1557 00a4 06E0     		b	.L135
 1558              	.L134:
1482:../src/RTOS/queue.c **** 						}
1483:../src/RTOS/queue.c **** 						else
1484:../src/RTOS/queue.c **** 						{
1485:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1486:../src/RTOS/queue.c **** 						}
1487:../src/RTOS/queue.c **** 					}
1488:../src/RTOS/queue.c **** 					else
1489:../src/RTOS/queue.c **** 					{
1490:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1491:../src/RTOS/queue.c **** 					}
1492:../src/RTOS/queue.c **** 				}
1493:../src/RTOS/queue.c **** 				else
1494:../src/RTOS/queue.c **** 				{
1495:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1496:../src/RTOS/queue.c **** 				}
1497:../src/RTOS/queue.c **** 			}
1498:../src/RTOS/queue.c **** 			else
1499:../src/RTOS/queue.c **** 			{
1500:../src/RTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1501:../src/RTOS/queue.c **** 				knows that data was removed while it was locked. */
1502:../src/RTOS/queue.c **** 				pxQueue->cRxLock = cRxLock + 1;
 1559              		.loc 1 1502 0
 1560 00a6 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 1561 00a8 0133     		adds	r3, r3, #1
 1562 00aa DBB2     		uxtb	r3, r3
 1563 00ac DAB2     		uxtb	r2, r3
 1564 00ae BB6A     		ldr	r3, [r7, #40]
 1565 00b0 83F84420 		strb	r2, [r3, #68]
 1566              	.L135:
1503:../src/RTOS/queue.c **** 			}
1504:../src/RTOS/queue.c **** 
1505:../src/RTOS/queue.c **** 			xReturn = pdPASS;
 1567              		.loc 1 1505 0
 1568 00b4 0123     		movs	r3, #1
 1569 00b6 FB62     		str	r3, [r7, #44]
 1570              	.LBE38:
 1571 00b8 01E0     		b	.L136
 1572              	.L133:
1506:../src/RTOS/queue.c **** 		}
1507:../src/RTOS/queue.c **** 		else
1508:../src/RTOS/queue.c **** 		{
1509:../src/RTOS/queue.c **** 			xReturn = pdFAIL;
 1573              		.loc 1 1509 0
 1574 00ba 0023     		movs	r3, #0
 1575 00bc FB62     		str	r3, [r7, #44]
 1576              	.L136:
 1577 00be 7B6A     		ldr	r3, [r7, #36]
 1578 00c0 3B61     		str	r3, [r7, #16]
 1579              	.LBE37:
 1580              	.LBB39:
 1581              	.LBB40:
 1582              		.loc 2 271 0
 1583 00c2 3B69     		ldr	r3, [r7, #16]
 1584              	@ 271 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 1585 00c4 83F31188 			msr basepri, r3	
 1586              	@ 0 "" 2
 1587              		.thumb
 1588              	.LBE40:
 1589              	.LBE39:
1510:../src/RTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1511:../src/RTOS/queue.c **** 		}
1512:../src/RTOS/queue.c **** 	}
1513:../src/RTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1514:../src/RTOS/queue.c **** 
1515:../src/RTOS/queue.c **** 	return xReturn;
 1590              		.loc 1 1515 0
 1591 00c8 FB6A     		ldr	r3, [r7, #44]
1516:../src/RTOS/queue.c **** }
 1592              		.loc 1 1516 0
 1593 00ca 1846     		mov	r0, r3
 1594 00cc 3037     		adds	r7, r7, #48
 1595              		.cfi_def_cfa_offset 8
 1596 00ce BD46     		mov	sp, r7
 1597              		.cfi_def_cfa_register 13
 1598              		@ sp needed
 1599 00d0 80BD     		pop	{r7, pc}
 1600              		.cfi_endproc
 1601              	.LFE13:
 1603 00d2 00BF     		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1604              		.align	2
 1605              		.global	xQueuePeekFromISR
 1606              		.thumb
 1607              		.thumb_func
 1609              	xQueuePeekFromISR:
 1610              	.LFB14:
1517:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1518:../src/RTOS/queue.c **** 
1519:../src/RTOS/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1520:../src/RTOS/queue.c **** {
 1611              		.loc 1 1520 0
 1612              		.cfi_startproc
 1613              		@ args = 0, pretend = 0, frame = 40
 1614              		@ frame_needed = 1, uses_anonymous_args = 0
 1615 0000 80B5     		push	{r7, lr}
 1616              		.cfi_def_cfa_offset 8
 1617              		.cfi_offset 7, -8
 1618              		.cfi_offset 14, -4
 1619 0002 8AB0     		sub	sp, sp, #40
 1620              		.cfi_def_cfa_offset 48
 1621 0004 00AF     		add	r7, sp, #0
 1622              		.cfi_def_cfa_register 7
 1623 0006 7860     		str	r0, [r7, #4]
 1624 0008 3960     		str	r1, [r7]
1521:../src/RTOS/queue.c **** BaseType_t xReturn;
1522:../src/RTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1523:../src/RTOS/queue.c **** int8_t *pcOriginalReadPosition;
1524:../src/RTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1625              		.loc 1 1524 0
 1626 000a 7B68     		ldr	r3, [r7, #4]
 1627 000c 3B62     		str	r3, [r7, #32]
1525:../src/RTOS/queue.c **** 
1526:../src/RTOS/queue.c **** 	configASSERT( pxQueue );
 1628              		.loc 1 1526 0
 1629 000e 3B6A     		ldr	r3, [r7, #32]
 1630 0010 002B     		cmp	r3, #0
 1631 0012 00D1     		bne	.L139
 1632              	.L140:
 1633              		.loc 1 1526 0 is_stmt 0 discriminator 1
 1634 0014 FEE7     		b	.L140
 1635              	.L139:
1527:../src/RTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1636              		.loc 1 1527 0 is_stmt 1
 1637 0016 3B68     		ldr	r3, [r7]
 1638 0018 002B     		cmp	r3, #0
 1639 001a 03D1     		bne	.L141
 1640              		.loc 1 1527 0 is_stmt 0 discriminator 2
 1641 001c 3B6A     		ldr	r3, [r7, #32]
 1642 001e 1B6C     		ldr	r3, [r3, #64]
 1643 0020 002B     		cmp	r3, #0
 1644 0022 01D1     		bne	.L142
 1645              	.L141:
 1646              		.loc 1 1527 0 discriminator 3
 1647 0024 0123     		movs	r3, #1
 1648 0026 00E0     		b	.L143
 1649              	.L142:
 1650              		.loc 1 1527 0 discriminator 4
 1651 0028 0023     		movs	r3, #0
 1652              	.L143:
 1653              		.loc 1 1527 0 discriminator 6
 1654 002a 002B     		cmp	r3, #0
 1655 002c 00D1     		bne	.L144
 1656              	.L145:
 1657              		.loc 1 1527 0 discriminator 2
 1658 002e FEE7     		b	.L145
 1659              	.L144:
1528:../src/RTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 1660              		.loc 1 1528 0 is_stmt 1
 1661 0030 3B6A     		ldr	r3, [r7, #32]
 1662 0032 1B6C     		ldr	r3, [r3, #64]
 1663 0034 002B     		cmp	r3, #0
 1664 0036 00D1     		bne	.L146
 1665              	.L147:
 1666              		.loc 1 1528 0 is_stmt 0 discriminator 3
 1667 0038 FEE7     		b	.L147
 1668              	.L146:
1529:../src/RTOS/queue.c **** 
1530:../src/RTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1531:../src/RTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1532:../src/RTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1533:../src/RTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1534:../src/RTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1535:../src/RTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1536:../src/RTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1537:../src/RTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1538:../src/RTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1539:../src/RTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1540:../src/RTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1541:../src/RTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1542:../src/RTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1543:../src/RTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1544:../src/RTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1669              		.loc 1 1544 0 is_stmt 1
 1670 003a FFF7FEFF 		bl	vPortValidateInterruptPriority
 1671              	.LBB41:
 1672              	.LBB42:
 253:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 1673              		.loc 2 253 0
 1674              	@ 253 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 1675 003e EFF31182 			mrs r2, basepri											
 1676 0042 4FF0BF03 		mov r3, #191												
 1677 0046 83F31188 		msr basepri, r3											
 1678 004a BFF36F8F 		isb														
 1679 004e BFF34F8F 		dsb														
 1680              	
 1681              	@ 0 "" 2
 1682              		.thumb
 1683 0052 7A61     		str	r2, [r7, #20]
 1684 0054 3B61     		str	r3, [r7, #16]
 265:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 1685              		.loc 2 265 0
 1686 0056 7B69     		ldr	r3, [r7, #20]
 1687              	.LBE42:
 1688              	.LBE41:
1545:../src/RTOS/queue.c **** 
1546:../src/RTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1689              		.loc 1 1546 0
 1690 0058 FB61     		str	r3, [r7, #28]
1547:../src/RTOS/queue.c **** 	{
1548:../src/RTOS/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1549:../src/RTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1691              		.loc 1 1549 0
 1692 005a 3B6A     		ldr	r3, [r7, #32]
 1693 005c 9B6B     		ldr	r3, [r3, #56]
 1694 005e 002B     		cmp	r3, #0
 1695 0060 0CD0     		beq	.L149
1550:../src/RTOS/queue.c **** 		{
1551:../src/RTOS/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1552:../src/RTOS/queue.c **** 
1553:../src/RTOS/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1554:../src/RTOS/queue.c **** 			actually being removed from the queue. */
1555:../src/RTOS/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1696              		.loc 1 1555 0
 1697 0062 3B6A     		ldr	r3, [r7, #32]
 1698 0064 DB68     		ldr	r3, [r3, #12]
 1699 0066 BB61     		str	r3, [r7, #24]
1556:../src/RTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1700              		.loc 1 1556 0
 1701 0068 386A     		ldr	r0, [r7, #32]
 1702 006a 3968     		ldr	r1, [r7]
 1703 006c FFF7FEFF 		bl	prvCopyDataFromQueue
1557:../src/RTOS/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1704              		.loc 1 1557 0
 1705 0070 3B6A     		ldr	r3, [r7, #32]
 1706 0072 BA69     		ldr	r2, [r7, #24]
 1707 0074 DA60     		str	r2, [r3, #12]
1558:../src/RTOS/queue.c **** 
1559:../src/RTOS/queue.c **** 			xReturn = pdPASS;
 1708              		.loc 1 1559 0
 1709 0076 0123     		movs	r3, #1
 1710 0078 7B62     		str	r3, [r7, #36]
 1711 007a 01E0     		b	.L150
 1712              	.L149:
1560:../src/RTOS/queue.c **** 		}
1561:../src/RTOS/queue.c **** 		else
1562:../src/RTOS/queue.c **** 		{
1563:../src/RTOS/queue.c **** 			xReturn = pdFAIL;
 1713              		.loc 1 1563 0
 1714 007c 0023     		movs	r3, #0
 1715 007e 7B62     		str	r3, [r7, #36]
 1716              	.L150:
 1717 0080 FB69     		ldr	r3, [r7, #28]
 1718 0082 FB60     		str	r3, [r7, #12]
 1719              	.LBB43:
 1720              	.LBB44:
 1721              		.loc 2 271 0
 1722 0084 FB68     		ldr	r3, [r7, #12]
 1723              	@ 271 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 1724 0086 83F31188 			msr basepri, r3	
 1725              	@ 0 "" 2
 1726              		.thumb
 1727              	.LBE44:
 1728              	.LBE43:
1564:../src/RTOS/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1565:../src/RTOS/queue.c **** 		}
1566:../src/RTOS/queue.c **** 	}
1567:../src/RTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1568:../src/RTOS/queue.c **** 
1569:../src/RTOS/queue.c **** 	return xReturn;
 1729              		.loc 1 1569 0
 1730 008a 7B6A     		ldr	r3, [r7, #36]
1570:../src/RTOS/queue.c **** }
 1731              		.loc 1 1570 0
 1732 008c 1846     		mov	r0, r3
 1733 008e 2837     		adds	r7, r7, #40
 1734              		.cfi_def_cfa_offset 8
 1735 0090 BD46     		mov	sp, r7
 1736              		.cfi_def_cfa_register 13
 1737              		@ sp needed
 1738 0092 80BD     		pop	{r7, pc}
 1739              		.cfi_endproc
 1740              	.LFE14:
 1742              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1743              		.align	2
 1744              		.global	uxQueueMessagesWaiting
 1745              		.thumb
 1746              		.thumb_func
 1748              	uxQueueMessagesWaiting:
 1749              	.LFB15:
1571:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1572:../src/RTOS/queue.c **** 
1573:../src/RTOS/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1574:../src/RTOS/queue.c **** {
 1750              		.loc 1 1574 0
 1751              		.cfi_startproc
 1752              		@ args = 0, pretend = 0, frame = 16
 1753              		@ frame_needed = 1, uses_anonymous_args = 0
 1754 0000 80B5     		push	{r7, lr}
 1755              		.cfi_def_cfa_offset 8
 1756              		.cfi_offset 7, -8
 1757              		.cfi_offset 14, -4
 1758 0002 84B0     		sub	sp, sp, #16
 1759              		.cfi_def_cfa_offset 24
 1760 0004 00AF     		add	r7, sp, #0
 1761              		.cfi_def_cfa_register 7
 1762 0006 7860     		str	r0, [r7, #4]
1575:../src/RTOS/queue.c **** UBaseType_t uxReturn;
1576:../src/RTOS/queue.c **** 
1577:../src/RTOS/queue.c **** 	configASSERT( xQueue );
 1763              		.loc 1 1577 0
 1764 0008 7B68     		ldr	r3, [r7, #4]
 1765 000a 002B     		cmp	r3, #0
 1766 000c 00D1     		bne	.L153
 1767              	.L154:
 1768              		.loc 1 1577 0 is_stmt 0 discriminator 1
 1769 000e FEE7     		b	.L154
 1770              	.L153:
1578:../src/RTOS/queue.c **** 
1579:../src/RTOS/queue.c **** 	taskENTER_CRITICAL();
 1771              		.loc 1 1579 0 is_stmt 1
 1772 0010 FFF7FEFF 		bl	vPortEnterCritical
1580:../src/RTOS/queue.c **** 	{
1581:../src/RTOS/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1773              		.loc 1 1581 0
 1774 0014 7B68     		ldr	r3, [r7, #4]
 1775 0016 9B6B     		ldr	r3, [r3, #56]
 1776 0018 FB60     		str	r3, [r7, #12]
1582:../src/RTOS/queue.c **** 	}
1583:../src/RTOS/queue.c **** 	taskEXIT_CRITICAL();
 1777              		.loc 1 1583 0
 1778 001a FFF7FEFF 		bl	vPortExitCritical
1584:../src/RTOS/queue.c **** 
1585:../src/RTOS/queue.c **** 	return uxReturn;
 1779              		.loc 1 1585 0
 1780 001e FB68     		ldr	r3, [r7, #12]
1586:../src/RTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1781              		.loc 1 1586 0
 1782 0020 1846     		mov	r0, r3
 1783 0022 1037     		adds	r7, r7, #16
 1784              		.cfi_def_cfa_offset 8
 1785 0024 BD46     		mov	sp, r7
 1786              		.cfi_def_cfa_register 13
 1787              		@ sp needed
 1788 0026 80BD     		pop	{r7, pc}
 1789              		.cfi_endproc
 1790              	.LFE15:
 1792              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 1793              		.align	2
 1794              		.global	uxQueueSpacesAvailable
 1795              		.thumb
 1796              		.thumb_func
 1798              	uxQueueSpacesAvailable:
 1799              	.LFB16:
1587:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1588:../src/RTOS/queue.c **** 
1589:../src/RTOS/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1590:../src/RTOS/queue.c **** {
 1800              		.loc 1 1590 0
 1801              		.cfi_startproc
 1802              		@ args = 0, pretend = 0, frame = 16
 1803              		@ frame_needed = 1, uses_anonymous_args = 0
 1804 0000 80B5     		push	{r7, lr}
 1805              		.cfi_def_cfa_offset 8
 1806              		.cfi_offset 7, -8
 1807              		.cfi_offset 14, -4
 1808 0002 84B0     		sub	sp, sp, #16
 1809              		.cfi_def_cfa_offset 24
 1810 0004 00AF     		add	r7, sp, #0
 1811              		.cfi_def_cfa_register 7
 1812 0006 7860     		str	r0, [r7, #4]
1591:../src/RTOS/queue.c **** UBaseType_t uxReturn;
1592:../src/RTOS/queue.c **** Queue_t *pxQueue;
1593:../src/RTOS/queue.c **** 
1594:../src/RTOS/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
 1813              		.loc 1 1594 0
 1814 0008 7B68     		ldr	r3, [r7, #4]
 1815 000a FB60     		str	r3, [r7, #12]
1595:../src/RTOS/queue.c **** 	configASSERT( pxQueue );
 1816              		.loc 1 1595 0
 1817 000c FB68     		ldr	r3, [r7, #12]
 1818 000e 002B     		cmp	r3, #0
 1819 0010 00D1     		bne	.L157
 1820              	.L158:
 1821              		.loc 1 1595 0 is_stmt 0 discriminator 1
 1822 0012 FEE7     		b	.L158
 1823              	.L157:
1596:../src/RTOS/queue.c **** 
1597:../src/RTOS/queue.c **** 	taskENTER_CRITICAL();
 1824              		.loc 1 1597 0 is_stmt 1
 1825 0014 FFF7FEFF 		bl	vPortEnterCritical
1598:../src/RTOS/queue.c **** 	{
1599:../src/RTOS/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1826              		.loc 1 1599 0
 1827 0018 FB68     		ldr	r3, [r7, #12]
 1828 001a DA6B     		ldr	r2, [r3, #60]
 1829 001c FB68     		ldr	r3, [r7, #12]
 1830 001e 9B6B     		ldr	r3, [r3, #56]
 1831 0020 D31A     		subs	r3, r2, r3
 1832 0022 BB60     		str	r3, [r7, #8]
1600:../src/RTOS/queue.c **** 	}
1601:../src/RTOS/queue.c **** 	taskEXIT_CRITICAL();
 1833              		.loc 1 1601 0
 1834 0024 FFF7FEFF 		bl	vPortExitCritical
1602:../src/RTOS/queue.c **** 
1603:../src/RTOS/queue.c **** 	return uxReturn;
 1835              		.loc 1 1603 0
 1836 0028 BB68     		ldr	r3, [r7, #8]
1604:../src/RTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1837              		.loc 1 1604 0
 1838 002a 1846     		mov	r0, r3
 1839 002c 1037     		adds	r7, r7, #16
 1840              		.cfi_def_cfa_offset 8
 1841 002e BD46     		mov	sp, r7
 1842              		.cfi_def_cfa_register 13
 1843              		@ sp needed
 1844 0030 80BD     		pop	{r7, pc}
 1845              		.cfi_endproc
 1846              	.LFE16:
 1848 0032 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1849              		.align	2
 1850              		.global	uxQueueMessagesWaitingFromISR
 1851              		.thumb
 1852              		.thumb_func
 1854              	uxQueueMessagesWaitingFromISR:
 1855              	.LFB17:
1605:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1606:../src/RTOS/queue.c **** 
1607:../src/RTOS/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1608:../src/RTOS/queue.c **** {
 1856              		.loc 1 1608 0
 1857              		.cfi_startproc
 1858              		@ args = 0, pretend = 0, frame = 16
 1859              		@ frame_needed = 1, uses_anonymous_args = 0
 1860              		@ link register save eliminated.
 1861 0000 80B4     		push	{r7}
 1862              		.cfi_def_cfa_offset 4
 1863              		.cfi_offset 7, -4
 1864 0002 85B0     		sub	sp, sp, #20
 1865              		.cfi_def_cfa_offset 24
 1866 0004 00AF     		add	r7, sp, #0
 1867              		.cfi_def_cfa_register 7
 1868 0006 7860     		str	r0, [r7, #4]
1609:../src/RTOS/queue.c **** UBaseType_t uxReturn;
1610:../src/RTOS/queue.c **** 
1611:../src/RTOS/queue.c **** 	configASSERT( xQueue );
 1869              		.loc 1 1611 0
 1870 0008 7B68     		ldr	r3, [r7, #4]
 1871 000a 002B     		cmp	r3, #0
 1872 000c 00D1     		bne	.L161
 1873              	.L162:
 1874              		.loc 1 1611 0 is_stmt 0 discriminator 1
 1875 000e FEE7     		b	.L162
 1876              	.L161:
1612:../src/RTOS/queue.c **** 
1613:../src/RTOS/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1877              		.loc 1 1613 0 is_stmt 1
 1878 0010 7B68     		ldr	r3, [r7, #4]
 1879 0012 9B6B     		ldr	r3, [r3, #56]
 1880 0014 FB60     		str	r3, [r7, #12]
1614:../src/RTOS/queue.c **** 
1615:../src/RTOS/queue.c **** 	return uxReturn;
 1881              		.loc 1 1615 0
 1882 0016 FB68     		ldr	r3, [r7, #12]
1616:../src/RTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1883              		.loc 1 1616 0
 1884 0018 1846     		mov	r0, r3
 1885 001a 1437     		adds	r7, r7, #20
 1886              		.cfi_def_cfa_offset 4
 1887 001c BD46     		mov	sp, r7
 1888              		.cfi_def_cfa_register 13
 1889              		@ sp needed
 1890 001e 5DF8047B 		ldr	r7, [sp], #4
 1891              		.cfi_restore 7
 1892              		.cfi_def_cfa_offset 0
 1893 0022 7047     		bx	lr
 1894              		.cfi_endproc
 1895              	.LFE17:
 1897              		.section	.text.vQueueDelete,"ax",%progbits
 1898              		.align	2
 1899              		.global	vQueueDelete
 1900              		.thumb
 1901              		.thumb_func
 1903              	vQueueDelete:
 1904              	.LFB18:
1617:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1618:../src/RTOS/queue.c **** 
1619:../src/RTOS/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1620:../src/RTOS/queue.c **** {
 1905              		.loc 1 1620 0
 1906              		.cfi_startproc
 1907              		@ args = 0, pretend = 0, frame = 16
 1908              		@ frame_needed = 1, uses_anonymous_args = 0
 1909 0000 80B5     		push	{r7, lr}
 1910              		.cfi_def_cfa_offset 8
 1911              		.cfi_offset 7, -8
 1912              		.cfi_offset 14, -4
 1913 0002 84B0     		sub	sp, sp, #16
 1914              		.cfi_def_cfa_offset 24
 1915 0004 00AF     		add	r7, sp, #0
 1916              		.cfi_def_cfa_register 7
 1917 0006 7860     		str	r0, [r7, #4]
1621:../src/RTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1918              		.loc 1 1621 0
 1919 0008 7B68     		ldr	r3, [r7, #4]
 1920 000a FB60     		str	r3, [r7, #12]
1622:../src/RTOS/queue.c **** 
1623:../src/RTOS/queue.c **** 	configASSERT( pxQueue );
 1921              		.loc 1 1623 0
 1922 000c FB68     		ldr	r3, [r7, #12]
 1923 000e 002B     		cmp	r3, #0
 1924 0010 00D1     		bne	.L165
 1925              	.L166:
 1926              		.loc 1 1623 0 is_stmt 0 discriminator 1
 1927 0012 FEE7     		b	.L166
 1928              	.L165:
1624:../src/RTOS/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1625:../src/RTOS/queue.c **** 
1626:../src/RTOS/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1627:../src/RTOS/queue.c **** 	{
1628:../src/RTOS/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 1929              		.loc 1 1628 0 is_stmt 1
 1930 0014 F868     		ldr	r0, [r7, #12]
 1931 0016 FFF7FEFF 		bl	vQueueUnregisterQueue
1629:../src/RTOS/queue.c **** 	}
1630:../src/RTOS/queue.c **** 	#endif
1631:../src/RTOS/queue.c **** 
1632:../src/RTOS/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1633:../src/RTOS/queue.c **** 	{
1634:../src/RTOS/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1635:../src/RTOS/queue.c **** 		again. */
1636:../src/RTOS/queue.c **** 		vPortFree( pxQueue );
 1932              		.loc 1 1636 0
 1933 001a F868     		ldr	r0, [r7, #12]
 1934 001c FFF7FEFF 		bl	vPortFree
1637:../src/RTOS/queue.c **** 	}
1638:../src/RTOS/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1639:../src/RTOS/queue.c **** 	{
1640:../src/RTOS/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1641:../src/RTOS/queue.c **** 		check before attempting to free the memory. */
1642:../src/RTOS/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1643:../src/RTOS/queue.c **** 		{
1644:../src/RTOS/queue.c **** 			vPortFree( pxQueue );
1645:../src/RTOS/queue.c **** 		}
1646:../src/RTOS/queue.c **** 		else
1647:../src/RTOS/queue.c **** 		{
1648:../src/RTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1649:../src/RTOS/queue.c **** 		}
1650:../src/RTOS/queue.c **** 	}
1651:../src/RTOS/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
1652:../src/RTOS/queue.c **** }
 1935              		.loc 1 1652 0
 1936 0020 1037     		adds	r7, r7, #16
 1937              		.cfi_def_cfa_offset 8
 1938 0022 BD46     		mov	sp, r7
 1939              		.cfi_def_cfa_register 13
 1940              		@ sp needed
 1941 0024 80BD     		pop	{r7, pc}
 1942              		.cfi_endproc
 1943              	.LFE18:
 1945 0026 00BF     		.section	.text.prvCopyDataToQueue,"ax",%progbits
 1946              		.align	2
 1947              		.thumb
 1948              		.thumb_func
 1950              	prvCopyDataToQueue:
 1951              	.LFB19:
1653:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1654:../src/RTOS/queue.c **** 
1655:../src/RTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1656:../src/RTOS/queue.c **** 
1657:../src/RTOS/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1658:../src/RTOS/queue.c **** 	{
1659:../src/RTOS/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1660:../src/RTOS/queue.c **** 	}
1661:../src/RTOS/queue.c **** 
1662:../src/RTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1663:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1664:../src/RTOS/queue.c **** 
1665:../src/RTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1666:../src/RTOS/queue.c **** 
1667:../src/RTOS/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1668:../src/RTOS/queue.c **** 	{
1669:../src/RTOS/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1670:../src/RTOS/queue.c **** 	}
1671:../src/RTOS/queue.c **** 
1672:../src/RTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1673:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1674:../src/RTOS/queue.c **** 
1675:../src/RTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1676:../src/RTOS/queue.c **** 
1677:../src/RTOS/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1678:../src/RTOS/queue.c **** 	{
1679:../src/RTOS/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
1680:../src/RTOS/queue.c **** 	}
1681:../src/RTOS/queue.c **** 
1682:../src/RTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1683:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1684:../src/RTOS/queue.c **** 
1685:../src/RTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
1686:../src/RTOS/queue.c **** {
 1952              		.loc 1 1686 0
 1953              		.cfi_startproc
 1954              		@ args = 0, pretend = 0, frame = 24
 1955              		@ frame_needed = 1, uses_anonymous_args = 0
 1956 0000 80B5     		push	{r7, lr}
 1957              		.cfi_def_cfa_offset 8
 1958              		.cfi_offset 7, -8
 1959              		.cfi_offset 14, -4
 1960 0002 86B0     		sub	sp, sp, #24
 1961              		.cfi_def_cfa_offset 32
 1962 0004 00AF     		add	r7, sp, #0
 1963              		.cfi_def_cfa_register 7
 1964 0006 F860     		str	r0, [r7, #12]
 1965 0008 B960     		str	r1, [r7, #8]
 1966 000a 7A60     		str	r2, [r7, #4]
1687:../src/RTOS/queue.c **** BaseType_t xReturn = pdFALSE;
 1967              		.loc 1 1687 0
 1968 000c 0023     		movs	r3, #0
 1969 000e 7B61     		str	r3, [r7, #20]
1688:../src/RTOS/queue.c **** UBaseType_t uxMessagesWaiting;
1689:../src/RTOS/queue.c **** 
1690:../src/RTOS/queue.c **** 	/* This function is called from a critical section. */
1691:../src/RTOS/queue.c **** 
1692:../src/RTOS/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1970              		.loc 1 1692 0
 1971 0010 FB68     		ldr	r3, [r7, #12]
 1972 0012 9B6B     		ldr	r3, [r3, #56]
 1973 0014 3B61     		str	r3, [r7, #16]
1693:../src/RTOS/queue.c **** 
1694:../src/RTOS/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 1974              		.loc 1 1694 0
 1975 0016 FB68     		ldr	r3, [r7, #12]
 1976 0018 1B6C     		ldr	r3, [r3, #64]
 1977 001a 002B     		cmp	r3, #0
 1978 001c 0DD1     		bne	.L168
1695:../src/RTOS/queue.c **** 	{
1696:../src/RTOS/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1697:../src/RTOS/queue.c **** 		{
1698:../src/RTOS/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1979              		.loc 1 1698 0
 1980 001e FB68     		ldr	r3, [r7, #12]
 1981 0020 1B68     		ldr	r3, [r3]
 1982 0022 002B     		cmp	r3, #0
 1983 0024 4FD1     		bne	.L169
1699:../src/RTOS/queue.c **** 			{
1700:../src/RTOS/queue.c **** 				/* The mutex is no longer being held. */
1701:../src/RTOS/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1984              		.loc 1 1701 0
 1985 0026 FB68     		ldr	r3, [r7, #12]
 1986 0028 5B68     		ldr	r3, [r3, #4]
 1987 002a 1846     		mov	r0, r3
 1988 002c FFF7FEFF 		bl	xTaskPriorityDisinherit
 1989 0030 7861     		str	r0, [r7, #20]
1702:../src/RTOS/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1990              		.loc 1 1702 0
 1991 0032 FB68     		ldr	r3, [r7, #12]
 1992 0034 0022     		movs	r2, #0
 1993 0036 5A60     		str	r2, [r3, #4]
 1994 0038 45E0     		b	.L169
 1995              	.L168:
1703:../src/RTOS/queue.c **** 			}
1704:../src/RTOS/queue.c **** 			else
1705:../src/RTOS/queue.c **** 			{
1706:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1707:../src/RTOS/queue.c **** 			}
1708:../src/RTOS/queue.c **** 		}
1709:../src/RTOS/queue.c **** 		#endif /* configUSE_MUTEXES */
1710:../src/RTOS/queue.c **** 	}
1711:../src/RTOS/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1996              		.loc 1 1711 0
 1997 003a 7B68     		ldr	r3, [r7, #4]
 1998 003c 002B     		cmp	r3, #0
 1999 003e 1AD1     		bne	.L170
1712:../src/RTOS/queue.c **** 	{
1713:../src/RTOS/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 2000              		.loc 1 1713 0
 2001 0040 FB68     		ldr	r3, [r7, #12]
 2002 0042 9A68     		ldr	r2, [r3, #8]
 2003 0044 FB68     		ldr	r3, [r7, #12]
 2004 0046 1B6C     		ldr	r3, [r3, #64]
 2005 0048 1046     		mov	r0, r2
 2006 004a B968     		ldr	r1, [r7, #8]
 2007 004c 1A46     		mov	r2, r3
 2008 004e FFF7FEFF 		bl	memcpy
1714:../src/RTOS/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 2009              		.loc 1 1714 0
 2010 0052 FB68     		ldr	r3, [r7, #12]
 2011 0054 9A68     		ldr	r2, [r3, #8]
 2012 0056 FB68     		ldr	r3, [r7, #12]
 2013 0058 1B6C     		ldr	r3, [r3, #64]
 2014 005a 1A44     		add	r2, r2, r3
 2015 005c FB68     		ldr	r3, [r7, #12]
 2016 005e 9A60     		str	r2, [r3, #8]
1715:../src/RTOS/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 2017              		.loc 1 1715 0
 2018 0060 FB68     		ldr	r3, [r7, #12]
 2019 0062 9A68     		ldr	r2, [r3, #8]
 2020 0064 FB68     		ldr	r3, [r7, #12]
 2021 0066 5B68     		ldr	r3, [r3, #4]
 2022 0068 9A42     		cmp	r2, r3
 2023 006a 2CD3     		bcc	.L169
1716:../src/RTOS/queue.c **** 		{
1717:../src/RTOS/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 2024              		.loc 1 1717 0
 2025 006c FB68     		ldr	r3, [r7, #12]
 2026 006e 1A68     		ldr	r2, [r3]
 2027 0070 FB68     		ldr	r3, [r7, #12]
 2028 0072 9A60     		str	r2, [r3, #8]
 2029 0074 27E0     		b	.L169
 2030              	.L170:
1718:../src/RTOS/queue.c **** 		}
1719:../src/RTOS/queue.c **** 		else
1720:../src/RTOS/queue.c **** 		{
1721:../src/RTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1722:../src/RTOS/queue.c **** 		}
1723:../src/RTOS/queue.c **** 	}
1724:../src/RTOS/queue.c **** 	else
1725:../src/RTOS/queue.c **** 	{
1726:../src/RTOS/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 2031              		.loc 1 1726 0
 2032 0076 FB68     		ldr	r3, [r7, #12]
 2033 0078 DA68     		ldr	r2, [r3, #12]
 2034 007a FB68     		ldr	r3, [r7, #12]
 2035 007c 1B6C     		ldr	r3, [r3, #64]
 2036 007e 1046     		mov	r0, r2
 2037 0080 B968     		ldr	r1, [r7, #8]
 2038 0082 1A46     		mov	r2, r3
 2039 0084 FFF7FEFF 		bl	memcpy
1727:../src/RTOS/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 2040              		.loc 1 1727 0
 2041 0088 FB68     		ldr	r3, [r7, #12]
 2042 008a DA68     		ldr	r2, [r3, #12]
 2043 008c FB68     		ldr	r3, [r7, #12]
 2044 008e 1B6C     		ldr	r3, [r3, #64]
 2045 0090 5B42     		negs	r3, r3
 2046 0092 1A44     		add	r2, r2, r3
 2047 0094 FB68     		ldr	r3, [r7, #12]
 2048 0096 DA60     		str	r2, [r3, #12]
1728:../src/RTOS/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 2049              		.loc 1 1728 0
 2050 0098 FB68     		ldr	r3, [r7, #12]
 2051 009a DA68     		ldr	r2, [r3, #12]
 2052 009c FB68     		ldr	r3, [r7, #12]
 2053 009e 1B68     		ldr	r3, [r3]
 2054 00a0 9A42     		cmp	r2, r3
 2055 00a2 07D2     		bcs	.L171
1729:../src/RTOS/queue.c **** 		{
1730:../src/RTOS/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 2056              		.loc 1 1730 0
 2057 00a4 FB68     		ldr	r3, [r7, #12]
 2058 00a6 5A68     		ldr	r2, [r3, #4]
 2059 00a8 FB68     		ldr	r3, [r7, #12]
 2060 00aa 1B6C     		ldr	r3, [r3, #64]
 2061 00ac 5B42     		negs	r3, r3
 2062 00ae 1A44     		add	r2, r2, r3
 2063 00b0 FB68     		ldr	r3, [r7, #12]
 2064 00b2 DA60     		str	r2, [r3, #12]
 2065              	.L171:
1731:../src/RTOS/queue.c **** 		}
1732:../src/RTOS/queue.c **** 		else
1733:../src/RTOS/queue.c **** 		{
1734:../src/RTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1735:../src/RTOS/queue.c **** 		}
1736:../src/RTOS/queue.c **** 
1737:../src/RTOS/queue.c **** 		if( xPosition == queueOVERWRITE )
 2066              		.loc 1 1737 0
 2067 00b4 7B68     		ldr	r3, [r7, #4]
 2068 00b6 022B     		cmp	r3, #2
 2069 00b8 05D1     		bne	.L169
1738:../src/RTOS/queue.c **** 		{
1739:../src/RTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2070              		.loc 1 1739 0
 2071 00ba 3B69     		ldr	r3, [r7, #16]
 2072 00bc 002B     		cmp	r3, #0
 2073 00be 02D0     		beq	.L169
1740:../src/RTOS/queue.c **** 			{
1741:../src/RTOS/queue.c **** 				/* An item is not being added but overwritten, so subtract
1742:../src/RTOS/queue.c **** 				one from the recorded number of items in the queue so when
1743:../src/RTOS/queue.c **** 				one is added again below the number of recorded items remains
1744:../src/RTOS/queue.c **** 				correct. */
1745:../src/RTOS/queue.c **** 				--uxMessagesWaiting;
 2074              		.loc 1 1745 0
 2075 00c0 3B69     		ldr	r3, [r7, #16]
 2076 00c2 013B     		subs	r3, r3, #1
 2077 00c4 3B61     		str	r3, [r7, #16]
 2078              	.L169:
1746:../src/RTOS/queue.c **** 			}
1747:../src/RTOS/queue.c **** 			else
1748:../src/RTOS/queue.c **** 			{
1749:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1750:../src/RTOS/queue.c **** 			}
1751:../src/RTOS/queue.c **** 		}
1752:../src/RTOS/queue.c **** 		else
1753:../src/RTOS/queue.c **** 		{
1754:../src/RTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1755:../src/RTOS/queue.c **** 		}
1756:../src/RTOS/queue.c **** 	}
1757:../src/RTOS/queue.c **** 
1758:../src/RTOS/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 2079              		.loc 1 1758 0
 2080 00c6 3B69     		ldr	r3, [r7, #16]
 2081 00c8 5A1C     		adds	r2, r3, #1
 2082 00ca FB68     		ldr	r3, [r7, #12]
 2083 00cc 9A63     		str	r2, [r3, #56]
1759:../src/RTOS/queue.c **** 
1760:../src/RTOS/queue.c **** 	return xReturn;
 2084              		.loc 1 1760 0
 2085 00ce 7B69     		ldr	r3, [r7, #20]
1761:../src/RTOS/queue.c **** }
 2086              		.loc 1 1761 0
 2087 00d0 1846     		mov	r0, r3
 2088 00d2 1837     		adds	r7, r7, #24
 2089              		.cfi_def_cfa_offset 8
 2090 00d4 BD46     		mov	sp, r7
 2091              		.cfi_def_cfa_register 13
 2092              		@ sp needed
 2093 00d6 80BD     		pop	{r7, pc}
 2094              		.cfi_endproc
 2095              	.LFE19:
 2097              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 2098              		.align	2
 2099              		.thumb
 2100              		.thumb_func
 2102              	prvCopyDataFromQueue:
 2103              	.LFB20:
1762:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1763:../src/RTOS/queue.c **** 
1764:../src/RTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1765:../src/RTOS/queue.c **** {
 2104              		.loc 1 1765 0
 2105              		.cfi_startproc
 2106              		@ args = 0, pretend = 0, frame = 8
 2107              		@ frame_needed = 1, uses_anonymous_args = 0
 2108 0000 80B5     		push	{r7, lr}
 2109              		.cfi_def_cfa_offset 8
 2110              		.cfi_offset 7, -8
 2111              		.cfi_offset 14, -4
 2112 0002 82B0     		sub	sp, sp, #8
 2113              		.cfi_def_cfa_offset 16
 2114 0004 00AF     		add	r7, sp, #0
 2115              		.cfi_def_cfa_register 7
 2116 0006 7860     		str	r0, [r7, #4]
 2117 0008 3960     		str	r1, [r7]
1766:../src/RTOS/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 2118              		.loc 1 1766 0
 2119 000a 7B68     		ldr	r3, [r7, #4]
 2120 000c 1B6C     		ldr	r3, [r3, #64]
 2121 000e 002B     		cmp	r3, #0
 2122 0010 19D0     		beq	.L173
1767:../src/RTOS/queue.c **** 	{
1768:../src/RTOS/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2123              		.loc 1 1768 0
 2124 0012 7B68     		ldr	r3, [r7, #4]
 2125 0014 DA68     		ldr	r2, [r3, #12]
 2126 0016 7B68     		ldr	r3, [r7, #4]
 2127 0018 1B6C     		ldr	r3, [r3, #64]
 2128 001a 1A44     		add	r2, r2, r3
 2129 001c 7B68     		ldr	r3, [r7, #4]
 2130 001e DA60     		str	r2, [r3, #12]
1769:../src/RTOS/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 2131              		.loc 1 1769 0
 2132 0020 7B68     		ldr	r3, [r7, #4]
 2133 0022 DA68     		ldr	r2, [r3, #12]
 2134 0024 7B68     		ldr	r3, [r7, #4]
 2135 0026 5B68     		ldr	r3, [r3, #4]
 2136 0028 9A42     		cmp	r2, r3
 2137 002a 03D3     		bcc	.L175
1770:../src/RTOS/queue.c **** 		{
1771:../src/RTOS/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2138              		.loc 1 1771 0
 2139 002c 7B68     		ldr	r3, [r7, #4]
 2140 002e 1A68     		ldr	r2, [r3]
 2141 0030 7B68     		ldr	r3, [r7, #4]
 2142 0032 DA60     		str	r2, [r3, #12]
 2143              	.L175:
1772:../src/RTOS/queue.c **** 		}
1773:../src/RTOS/queue.c **** 		else
1774:../src/RTOS/queue.c **** 		{
1775:../src/RTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1776:../src/RTOS/queue.c **** 		}
1777:../src/RTOS/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 2144              		.loc 1 1777 0
 2145 0034 7B68     		ldr	r3, [r7, #4]
 2146 0036 DA68     		ldr	r2, [r3, #12]
 2147 0038 7B68     		ldr	r3, [r7, #4]
 2148 003a 1B6C     		ldr	r3, [r3, #64]
 2149 003c 3868     		ldr	r0, [r7]
 2150 003e 1146     		mov	r1, r2
 2151 0040 1A46     		mov	r2, r3
 2152 0042 FFF7FEFF 		bl	memcpy
 2153              	.L173:
1778:../src/RTOS/queue.c **** 	}
1779:../src/RTOS/queue.c **** }
 2154              		.loc 1 1779 0
 2155 0046 0837     		adds	r7, r7, #8
 2156              		.cfi_def_cfa_offset 8
 2157 0048 BD46     		mov	sp, r7
 2158              		.cfi_def_cfa_register 13
 2159              		@ sp needed
 2160 004a 80BD     		pop	{r7, pc}
 2161              		.cfi_endproc
 2162              	.LFE20:
 2164              		.section	.text.prvUnlockQueue,"ax",%progbits
 2165              		.align	2
 2166              		.thumb
 2167              		.thumb_func
 2169              	prvUnlockQueue:
 2170              	.LFB21:
1780:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1781:../src/RTOS/queue.c **** 
1782:../src/RTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
1783:../src/RTOS/queue.c **** {
 2171              		.loc 1 1783 0
 2172              		.cfi_startproc
 2173              		@ args = 0, pretend = 0, frame = 16
 2174              		@ frame_needed = 1, uses_anonymous_args = 0
 2175 0000 80B5     		push	{r7, lr}
 2176              		.cfi_def_cfa_offset 8
 2177              		.cfi_offset 7, -8
 2178              		.cfi_offset 14, -4
 2179 0002 84B0     		sub	sp, sp, #16
 2180              		.cfi_def_cfa_offset 24
 2181 0004 00AF     		add	r7, sp, #0
 2182              		.cfi_def_cfa_register 7
 2183 0006 7860     		str	r0, [r7, #4]
1784:../src/RTOS/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1785:../src/RTOS/queue.c **** 
1786:../src/RTOS/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1787:../src/RTOS/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1788:../src/RTOS/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1789:../src/RTOS/queue.c **** 	updated. */
1790:../src/RTOS/queue.c **** 	taskENTER_CRITICAL();
 2184              		.loc 1 1790 0
 2185 0008 FFF7FEFF 		bl	vPortEnterCritical
 2186              	.LBB45:
1791:../src/RTOS/queue.c **** 	{
1792:../src/RTOS/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
 2187              		.loc 1 1792 0
 2188 000c 7B68     		ldr	r3, [r7, #4]
 2189 000e 93F84530 		ldrb	r3, [r3, #69]
 2190 0012 FB73     		strb	r3, [r7, #15]
1793:../src/RTOS/queue.c **** 
1794:../src/RTOS/queue.c **** 		/* See if data was added to the queue while it was locked. */
1795:../src/RTOS/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 2191              		.loc 1 1795 0
 2192 0014 13E0     		b	.L177
 2193              	.L181:
1796:../src/RTOS/queue.c **** 		{
1797:../src/RTOS/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1798:../src/RTOS/queue.c **** 			blocked waiting for data to become available? */
1799:../src/RTOS/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1800:../src/RTOS/queue.c **** 			{
1801:../src/RTOS/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1802:../src/RTOS/queue.c **** 				{
1803:../src/RTOS/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1804:../src/RTOS/queue.c **** 					{
1805:../src/RTOS/queue.c **** 						/* The queue is a member of a queue set, and posting to
1806:../src/RTOS/queue.c **** 						the queue set caused a higher priority task to unblock.
1807:../src/RTOS/queue.c **** 						A context switch is required. */
1808:../src/RTOS/queue.c **** 						vTaskMissedYield();
1809:../src/RTOS/queue.c **** 					}
1810:../src/RTOS/queue.c **** 					else
1811:../src/RTOS/queue.c **** 					{
1812:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1813:../src/RTOS/queue.c **** 					}
1814:../src/RTOS/queue.c **** 				}
1815:../src/RTOS/queue.c **** 				else
1816:../src/RTOS/queue.c **** 				{
1817:../src/RTOS/queue.c **** 					/* Tasks that are removed from the event list will get
1818:../src/RTOS/queue.c **** 					added to the pending ready list as the scheduler is still
1819:../src/RTOS/queue.c **** 					suspended. */
1820:../src/RTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1821:../src/RTOS/queue.c **** 					{
1822:../src/RTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1823:../src/RTOS/queue.c **** 						{
1824:../src/RTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1825:../src/RTOS/queue.c **** 							context	switch is required. */
1826:../src/RTOS/queue.c **** 							vTaskMissedYield();
1827:../src/RTOS/queue.c **** 						}
1828:../src/RTOS/queue.c **** 						else
1829:../src/RTOS/queue.c **** 						{
1830:../src/RTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1831:../src/RTOS/queue.c **** 						}
1832:../src/RTOS/queue.c **** 					}
1833:../src/RTOS/queue.c **** 					else
1834:../src/RTOS/queue.c **** 					{
1835:../src/RTOS/queue.c **** 						break;
1836:../src/RTOS/queue.c **** 					}
1837:../src/RTOS/queue.c **** 				}
1838:../src/RTOS/queue.c **** 			}
1839:../src/RTOS/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1840:../src/RTOS/queue.c **** 			{
1841:../src/RTOS/queue.c **** 				/* Tasks that are removed from the event list will get added to
1842:../src/RTOS/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1843:../src/RTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2194              		.loc 1 1843 0
 2195 0016 7B68     		ldr	r3, [r7, #4]
 2196 0018 5B6A     		ldr	r3, [r3, #36]
 2197 001a 002B     		cmp	r3, #0
 2198 001c 0AD0     		beq	.L178
1844:../src/RTOS/queue.c **** 				{
1845:../src/RTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2199              		.loc 1 1845 0
 2200 001e 7B68     		ldr	r3, [r7, #4]
 2201 0020 2433     		adds	r3, r3, #36
 2202 0022 1846     		mov	r0, r3
 2203 0024 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2204 0028 0346     		mov	r3, r0
 2205 002a 002B     		cmp	r3, #0
 2206 002c 03D0     		beq	.L179
1846:../src/RTOS/queue.c **** 					{
1847:../src/RTOS/queue.c **** 						/* The task waiting has a higher priority so record that
1848:../src/RTOS/queue.c **** 						a context switch is required. */
1849:../src/RTOS/queue.c **** 						vTaskMissedYield();
 2207              		.loc 1 1849 0
 2208 002e FFF7FEFF 		bl	vTaskMissedYield
 2209 0032 00E0     		b	.L179
 2210              	.L178:
1850:../src/RTOS/queue.c **** 					}
1851:../src/RTOS/queue.c **** 					else
1852:../src/RTOS/queue.c **** 					{
1853:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1854:../src/RTOS/queue.c **** 					}
1855:../src/RTOS/queue.c **** 				}
1856:../src/RTOS/queue.c **** 				else
1857:../src/RTOS/queue.c **** 				{
1858:../src/RTOS/queue.c **** 					break;
 2211              		.loc 1 1858 0
 2212 0034 07E0     		b	.L180
 2213              	.L179:
1859:../src/RTOS/queue.c **** 				}
1860:../src/RTOS/queue.c **** 			}
1861:../src/RTOS/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1862:../src/RTOS/queue.c **** 
1863:../src/RTOS/queue.c **** 			--cTxLock;
 2214              		.loc 1 1863 0
 2215 0036 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2216 0038 013B     		subs	r3, r3, #1
 2217 003a DBB2     		uxtb	r3, r3
 2218 003c FB73     		strb	r3, [r7, #15]
 2219              	.L177:
1795:../src/RTOS/queue.c **** 		{
 2220              		.loc 1 1795 0
 2221 003e 97F90F30 		ldrsb	r3, [r7, #15]
 2222 0042 002B     		cmp	r3, #0
 2223 0044 E7DC     		bgt	.L181
 2224              	.L180:
1864:../src/RTOS/queue.c **** 		}
1865:../src/RTOS/queue.c **** 
1866:../src/RTOS/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 2225              		.loc 1 1866 0
 2226 0046 7B68     		ldr	r3, [r7, #4]
 2227 0048 FF22     		movs	r2, #255
 2228 004a 83F84520 		strb	r2, [r3, #69]
 2229              	.LBE45:
1867:../src/RTOS/queue.c **** 	}
1868:../src/RTOS/queue.c **** 	taskEXIT_CRITICAL();
 2230              		.loc 1 1868 0
 2231 004e FFF7FEFF 		bl	vPortExitCritical
1869:../src/RTOS/queue.c **** 
1870:../src/RTOS/queue.c **** 	/* Do the same for the Rx lock. */
1871:../src/RTOS/queue.c **** 	taskENTER_CRITICAL();
 2232              		.loc 1 1871 0
 2233 0052 FFF7FEFF 		bl	vPortEnterCritical
 2234              	.LBB46:
1872:../src/RTOS/queue.c **** 	{
1873:../src/RTOS/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
 2235              		.loc 1 1873 0
 2236 0056 7B68     		ldr	r3, [r7, #4]
 2237 0058 93F84430 		ldrb	r3, [r3, #68]
 2238 005c BB73     		strb	r3, [r7, #14]
1874:../src/RTOS/queue.c **** 
1875:../src/RTOS/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 2239              		.loc 1 1875 0
 2240 005e 13E0     		b	.L182
 2241              	.L186:
1876:../src/RTOS/queue.c **** 		{
1877:../src/RTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2242              		.loc 1 1877 0
 2243 0060 7B68     		ldr	r3, [r7, #4]
 2244 0062 1B69     		ldr	r3, [r3, #16]
 2245 0064 002B     		cmp	r3, #0
 2246 0066 0ED0     		beq	.L183
1878:../src/RTOS/queue.c **** 			{
1879:../src/RTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2247              		.loc 1 1879 0
 2248 0068 7B68     		ldr	r3, [r7, #4]
 2249 006a 1033     		adds	r3, r3, #16
 2250 006c 1846     		mov	r0, r3
 2251 006e FFF7FEFF 		bl	xTaskRemoveFromEventList
 2252 0072 0346     		mov	r3, r0
 2253 0074 002B     		cmp	r3, #0
 2254 0076 01D0     		beq	.L184
1880:../src/RTOS/queue.c **** 				{
1881:../src/RTOS/queue.c **** 					vTaskMissedYield();
 2255              		.loc 1 1881 0
 2256 0078 FFF7FEFF 		bl	vTaskMissedYield
 2257              	.L184:
1882:../src/RTOS/queue.c **** 				}
1883:../src/RTOS/queue.c **** 				else
1884:../src/RTOS/queue.c **** 				{
1885:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1886:../src/RTOS/queue.c **** 				}
1887:../src/RTOS/queue.c **** 
1888:../src/RTOS/queue.c **** 				--cRxLock;
 2258              		.loc 1 1888 0
 2259 007c BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 2260 007e 013B     		subs	r3, r3, #1
 2261 0080 DBB2     		uxtb	r3, r3
 2262 0082 BB73     		strb	r3, [r7, #14]
 2263 0084 00E0     		b	.L182
 2264              	.L183:
1889:../src/RTOS/queue.c **** 			}
1890:../src/RTOS/queue.c **** 			else
1891:../src/RTOS/queue.c **** 			{
1892:../src/RTOS/queue.c **** 				break;
 2265              		.loc 1 1892 0
 2266 0086 03E0     		b	.L185
 2267              	.L182:
1875:../src/RTOS/queue.c **** 		{
 2268              		.loc 1 1875 0
 2269 0088 97F90E30 		ldrsb	r3, [r7, #14]
 2270 008c 002B     		cmp	r3, #0
 2271 008e E7DC     		bgt	.L186
 2272              	.L185:
1893:../src/RTOS/queue.c **** 			}
1894:../src/RTOS/queue.c **** 		}
1895:../src/RTOS/queue.c **** 
1896:../src/RTOS/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 2273              		.loc 1 1896 0
 2274 0090 7B68     		ldr	r3, [r7, #4]
 2275 0092 FF22     		movs	r2, #255
 2276 0094 83F84420 		strb	r2, [r3, #68]
 2277              	.LBE46:
1897:../src/RTOS/queue.c **** 	}
1898:../src/RTOS/queue.c **** 	taskEXIT_CRITICAL();
 2278              		.loc 1 1898 0
 2279 0098 FFF7FEFF 		bl	vPortExitCritical
1899:../src/RTOS/queue.c **** }
 2280              		.loc 1 1899 0
 2281 009c 1037     		adds	r7, r7, #16
 2282              		.cfi_def_cfa_offset 8
 2283 009e BD46     		mov	sp, r7
 2284              		.cfi_def_cfa_register 13
 2285              		@ sp needed
 2286 00a0 80BD     		pop	{r7, pc}
 2287              		.cfi_endproc
 2288              	.LFE21:
 2290 00a2 00BF     		.section	.text.prvIsQueueEmpty,"ax",%progbits
 2291              		.align	2
 2292              		.thumb
 2293              		.thumb_func
 2295              	prvIsQueueEmpty:
 2296              	.LFB22:
1900:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1901:../src/RTOS/queue.c **** 
1902:../src/RTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1903:../src/RTOS/queue.c **** {
 2297              		.loc 1 1903 0
 2298              		.cfi_startproc
 2299              		@ args = 0, pretend = 0, frame = 16
 2300              		@ frame_needed = 1, uses_anonymous_args = 0
 2301 0000 80B5     		push	{r7, lr}
 2302              		.cfi_def_cfa_offset 8
 2303              		.cfi_offset 7, -8
 2304              		.cfi_offset 14, -4
 2305 0002 84B0     		sub	sp, sp, #16
 2306              		.cfi_def_cfa_offset 24
 2307 0004 00AF     		add	r7, sp, #0
 2308              		.cfi_def_cfa_register 7
 2309 0006 7860     		str	r0, [r7, #4]
1904:../src/RTOS/queue.c **** BaseType_t xReturn;
1905:../src/RTOS/queue.c **** 
1906:../src/RTOS/queue.c **** 	taskENTER_CRITICAL();
 2310              		.loc 1 1906 0
 2311 0008 FFF7FEFF 		bl	vPortEnterCritical
1907:../src/RTOS/queue.c **** 	{
1908:../src/RTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 2312              		.loc 1 1908 0
 2313 000c 7B68     		ldr	r3, [r7, #4]
 2314 000e 9B6B     		ldr	r3, [r3, #56]
 2315 0010 002B     		cmp	r3, #0
 2316 0012 02D1     		bne	.L188
1909:../src/RTOS/queue.c **** 		{
1910:../src/RTOS/queue.c **** 			xReturn = pdTRUE;
 2317              		.loc 1 1910 0
 2318 0014 0123     		movs	r3, #1
 2319 0016 FB60     		str	r3, [r7, #12]
 2320 0018 01E0     		b	.L189
 2321              	.L188:
1911:../src/RTOS/queue.c **** 		}
1912:../src/RTOS/queue.c **** 		else
1913:../src/RTOS/queue.c **** 		{
1914:../src/RTOS/queue.c **** 			xReturn = pdFALSE;
 2322              		.loc 1 1914 0
 2323 001a 0023     		movs	r3, #0
 2324 001c FB60     		str	r3, [r7, #12]
 2325              	.L189:
1915:../src/RTOS/queue.c **** 		}
1916:../src/RTOS/queue.c **** 	}
1917:../src/RTOS/queue.c **** 	taskEXIT_CRITICAL();
 2326              		.loc 1 1917 0
 2327 001e FFF7FEFF 		bl	vPortExitCritical
1918:../src/RTOS/queue.c **** 
1919:../src/RTOS/queue.c **** 	return xReturn;
 2328              		.loc 1 1919 0
 2329 0022 FB68     		ldr	r3, [r7, #12]
1920:../src/RTOS/queue.c **** }
 2330              		.loc 1 1920 0
 2331 0024 1846     		mov	r0, r3
 2332 0026 1037     		adds	r7, r7, #16
 2333              		.cfi_def_cfa_offset 8
 2334 0028 BD46     		mov	sp, r7
 2335              		.cfi_def_cfa_register 13
 2336              		@ sp needed
 2337 002a 80BD     		pop	{r7, pc}
 2338              		.cfi_endproc
 2339              	.LFE22:
 2341              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2342              		.align	2
 2343              		.global	xQueueIsQueueEmptyFromISR
 2344              		.thumb
 2345              		.thumb_func
 2347              	xQueueIsQueueEmptyFromISR:
 2348              	.LFB23:
1921:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1922:../src/RTOS/queue.c **** 
1923:../src/RTOS/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1924:../src/RTOS/queue.c **** {
 2349              		.loc 1 1924 0
 2350              		.cfi_startproc
 2351              		@ args = 0, pretend = 0, frame = 16
 2352              		@ frame_needed = 1, uses_anonymous_args = 0
 2353              		@ link register save eliminated.
 2354 0000 80B4     		push	{r7}
 2355              		.cfi_def_cfa_offset 4
 2356              		.cfi_offset 7, -4
 2357 0002 85B0     		sub	sp, sp, #20
 2358              		.cfi_def_cfa_offset 24
 2359 0004 00AF     		add	r7, sp, #0
 2360              		.cfi_def_cfa_register 7
 2361 0006 7860     		str	r0, [r7, #4]
1925:../src/RTOS/queue.c **** BaseType_t xReturn;
1926:../src/RTOS/queue.c **** 
1927:../src/RTOS/queue.c **** 	configASSERT( xQueue );
 2362              		.loc 1 1927 0
 2363 0008 7B68     		ldr	r3, [r7, #4]
 2364 000a 002B     		cmp	r3, #0
 2365 000c 00D1     		bne	.L192
 2366              	.L193:
 2367              		.loc 1 1927 0 is_stmt 0 discriminator 1
 2368 000e FEE7     		b	.L193
 2369              	.L192:
1928:../src/RTOS/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2370              		.loc 1 1928 0 is_stmt 1
 2371 0010 7B68     		ldr	r3, [r7, #4]
 2372 0012 9B6B     		ldr	r3, [r3, #56]
 2373 0014 002B     		cmp	r3, #0
 2374 0016 02D1     		bne	.L194
1929:../src/RTOS/queue.c **** 	{
1930:../src/RTOS/queue.c **** 		xReturn = pdTRUE;
 2375              		.loc 1 1930 0
 2376 0018 0123     		movs	r3, #1
 2377 001a FB60     		str	r3, [r7, #12]
 2378 001c 01E0     		b	.L195
 2379              	.L194:
1931:../src/RTOS/queue.c **** 	}
1932:../src/RTOS/queue.c **** 	else
1933:../src/RTOS/queue.c **** 	{
1934:../src/RTOS/queue.c **** 		xReturn = pdFALSE;
 2380              		.loc 1 1934 0
 2381 001e 0023     		movs	r3, #0
 2382 0020 FB60     		str	r3, [r7, #12]
 2383              	.L195:
1935:../src/RTOS/queue.c **** 	}
1936:../src/RTOS/queue.c **** 
1937:../src/RTOS/queue.c **** 	return xReturn;
 2384              		.loc 1 1937 0
 2385 0022 FB68     		ldr	r3, [r7, #12]
1938:../src/RTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2386              		.loc 1 1938 0
 2387 0024 1846     		mov	r0, r3
 2388 0026 1437     		adds	r7, r7, #20
 2389              		.cfi_def_cfa_offset 4
 2390 0028 BD46     		mov	sp, r7
 2391              		.cfi_def_cfa_register 13
 2392              		@ sp needed
 2393 002a 5DF8047B 		ldr	r7, [sp], #4
 2394              		.cfi_restore 7
 2395              		.cfi_def_cfa_offset 0
 2396 002e 7047     		bx	lr
 2397              		.cfi_endproc
 2398              	.LFE23:
 2400              		.section	.text.prvIsQueueFull,"ax",%progbits
 2401              		.align	2
 2402              		.thumb
 2403              		.thumb_func
 2405              	prvIsQueueFull:
 2406              	.LFB24:
1939:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1940:../src/RTOS/queue.c **** 
1941:../src/RTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1942:../src/RTOS/queue.c **** {
 2407              		.loc 1 1942 0
 2408              		.cfi_startproc
 2409              		@ args = 0, pretend = 0, frame = 16
 2410              		@ frame_needed = 1, uses_anonymous_args = 0
 2411 0000 80B5     		push	{r7, lr}
 2412              		.cfi_def_cfa_offset 8
 2413              		.cfi_offset 7, -8
 2414              		.cfi_offset 14, -4
 2415 0002 84B0     		sub	sp, sp, #16
 2416              		.cfi_def_cfa_offset 24
 2417 0004 00AF     		add	r7, sp, #0
 2418              		.cfi_def_cfa_register 7
 2419 0006 7860     		str	r0, [r7, #4]
1943:../src/RTOS/queue.c **** BaseType_t xReturn;
1944:../src/RTOS/queue.c **** 
1945:../src/RTOS/queue.c **** 	taskENTER_CRITICAL();
 2420              		.loc 1 1945 0
 2421 0008 FFF7FEFF 		bl	vPortEnterCritical
1946:../src/RTOS/queue.c **** 	{
1947:../src/RTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2422              		.loc 1 1947 0
 2423 000c 7B68     		ldr	r3, [r7, #4]
 2424 000e 9A6B     		ldr	r2, [r3, #56]
 2425 0010 7B68     		ldr	r3, [r7, #4]
 2426 0012 DB6B     		ldr	r3, [r3, #60]
 2427 0014 9A42     		cmp	r2, r3
 2428 0016 02D1     		bne	.L198
1948:../src/RTOS/queue.c **** 		{
1949:../src/RTOS/queue.c **** 			xReturn = pdTRUE;
 2429              		.loc 1 1949 0
 2430 0018 0123     		movs	r3, #1
 2431 001a FB60     		str	r3, [r7, #12]
 2432 001c 01E0     		b	.L199
 2433              	.L198:
1950:../src/RTOS/queue.c **** 		}
1951:../src/RTOS/queue.c **** 		else
1952:../src/RTOS/queue.c **** 		{
1953:../src/RTOS/queue.c **** 			xReturn = pdFALSE;
 2434              		.loc 1 1953 0
 2435 001e 0023     		movs	r3, #0
 2436 0020 FB60     		str	r3, [r7, #12]
 2437              	.L199:
1954:../src/RTOS/queue.c **** 		}
1955:../src/RTOS/queue.c **** 	}
1956:../src/RTOS/queue.c **** 	taskEXIT_CRITICAL();
 2438              		.loc 1 1956 0
 2439 0022 FFF7FEFF 		bl	vPortExitCritical
1957:../src/RTOS/queue.c **** 
1958:../src/RTOS/queue.c **** 	return xReturn;
 2440              		.loc 1 1958 0
 2441 0026 FB68     		ldr	r3, [r7, #12]
1959:../src/RTOS/queue.c **** }
 2442              		.loc 1 1959 0
 2443 0028 1846     		mov	r0, r3
 2444 002a 1037     		adds	r7, r7, #16
 2445              		.cfi_def_cfa_offset 8
 2446 002c BD46     		mov	sp, r7
 2447              		.cfi_def_cfa_register 13
 2448              		@ sp needed
 2449 002e 80BD     		pop	{r7, pc}
 2450              		.cfi_endproc
 2451              	.LFE24:
 2453              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2454              		.align	2
 2455              		.global	xQueueIsQueueFullFromISR
 2456              		.thumb
 2457              		.thumb_func
 2459              	xQueueIsQueueFullFromISR:
 2460              	.LFB25:
1960:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1961:../src/RTOS/queue.c **** 
1962:../src/RTOS/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1963:../src/RTOS/queue.c **** {
 2461              		.loc 1 1963 0
 2462              		.cfi_startproc
 2463              		@ args = 0, pretend = 0, frame = 16
 2464              		@ frame_needed = 1, uses_anonymous_args = 0
 2465              		@ link register save eliminated.
 2466 0000 80B4     		push	{r7}
 2467              		.cfi_def_cfa_offset 4
 2468              		.cfi_offset 7, -4
 2469 0002 85B0     		sub	sp, sp, #20
 2470              		.cfi_def_cfa_offset 24
 2471 0004 00AF     		add	r7, sp, #0
 2472              		.cfi_def_cfa_register 7
 2473 0006 7860     		str	r0, [r7, #4]
1964:../src/RTOS/queue.c **** BaseType_t xReturn;
1965:../src/RTOS/queue.c **** 
1966:../src/RTOS/queue.c **** 	configASSERT( xQueue );
 2474              		.loc 1 1966 0
 2475 0008 7B68     		ldr	r3, [r7, #4]
 2476 000a 002B     		cmp	r3, #0
 2477 000c 00D1     		bne	.L202
 2478              	.L203:
 2479              		.loc 1 1966 0 is_stmt 0 discriminator 1
 2480 000e FEE7     		b	.L203
 2481              	.L202:
1967:../src/RTOS/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 2482              		.loc 1 1967 0 is_stmt 1
 2483 0010 7B68     		ldr	r3, [r7, #4]
 2484 0012 9A6B     		ldr	r2, [r3, #56]
 2485 0014 7B68     		ldr	r3, [r7, #4]
 2486 0016 DB6B     		ldr	r3, [r3, #60]
 2487 0018 9A42     		cmp	r2, r3
 2488 001a 02D1     		bne	.L204
1968:../src/RTOS/queue.c **** 	{
1969:../src/RTOS/queue.c **** 		xReturn = pdTRUE;
 2489              		.loc 1 1969 0
 2490 001c 0123     		movs	r3, #1
 2491 001e FB60     		str	r3, [r7, #12]
 2492 0020 01E0     		b	.L205
 2493              	.L204:
1970:../src/RTOS/queue.c **** 	}
1971:../src/RTOS/queue.c **** 	else
1972:../src/RTOS/queue.c **** 	{
1973:../src/RTOS/queue.c **** 		xReturn = pdFALSE;
 2494              		.loc 1 1973 0
 2495 0022 0023     		movs	r3, #0
 2496 0024 FB60     		str	r3, [r7, #12]
 2497              	.L205:
1974:../src/RTOS/queue.c **** 	}
1975:../src/RTOS/queue.c **** 
1976:../src/RTOS/queue.c **** 	return xReturn;
 2498              		.loc 1 1976 0
 2499 0026 FB68     		ldr	r3, [r7, #12]
1977:../src/RTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2500              		.loc 1 1977 0
 2501 0028 1846     		mov	r0, r3
 2502 002a 1437     		adds	r7, r7, #20
 2503              		.cfi_def_cfa_offset 4
 2504 002c BD46     		mov	sp, r7
 2505              		.cfi_def_cfa_register 13
 2506              		@ sp needed
 2507 002e 5DF8047B 		ldr	r7, [sp], #4
 2508              		.cfi_restore 7
 2509              		.cfi_def_cfa_offset 0
 2510 0032 7047     		bx	lr
 2511              		.cfi_endproc
 2512              	.LFE25:
 2514              		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2515              		.align	2
 2516              		.global	vQueueAddToRegistry
 2517              		.thumb
 2518              		.thumb_func
 2520              	vQueueAddToRegistry:
 2521              	.LFB26:
1978:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
1979:../src/RTOS/queue.c **** 
1980:../src/RTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1981:../src/RTOS/queue.c **** 
1982:../src/RTOS/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
1983:../src/RTOS/queue.c **** 	{
1984:../src/RTOS/queue.c **** 	BaseType_t xReturn;
1985:../src/RTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1986:../src/RTOS/queue.c **** 
1987:../src/RTOS/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
1988:../src/RTOS/queue.c **** 		is required to prevent an interrupt removing something from the queue
1989:../src/RTOS/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
1990:../src/RTOS/queue.c **** 		portDISABLE_INTERRUPTS();
1991:../src/RTOS/queue.c **** 		{
1992:../src/RTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
1993:../src/RTOS/queue.c **** 			{
1994:../src/RTOS/queue.c **** 				/* The queue is full - do we want to block or just leave without
1995:../src/RTOS/queue.c **** 				posting? */
1996:../src/RTOS/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
1997:../src/RTOS/queue.c **** 				{
1998:../src/RTOS/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
1999:../src/RTOS/queue.c **** 					return indicating that we need to block. */
2000:../src/RTOS/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2001:../src/RTOS/queue.c **** 					portENABLE_INTERRUPTS();
2002:../src/RTOS/queue.c **** 					return errQUEUE_BLOCKED;
2003:../src/RTOS/queue.c **** 				}
2004:../src/RTOS/queue.c **** 				else
2005:../src/RTOS/queue.c **** 				{
2006:../src/RTOS/queue.c **** 					portENABLE_INTERRUPTS();
2007:../src/RTOS/queue.c **** 					return errQUEUE_FULL;
2008:../src/RTOS/queue.c **** 				}
2009:../src/RTOS/queue.c **** 			}
2010:../src/RTOS/queue.c **** 		}
2011:../src/RTOS/queue.c **** 		portENABLE_INTERRUPTS();
2012:../src/RTOS/queue.c **** 
2013:../src/RTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2014:../src/RTOS/queue.c **** 		{
2015:../src/RTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2016:../src/RTOS/queue.c **** 			{
2017:../src/RTOS/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2018:../src/RTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2019:../src/RTOS/queue.c **** 				xReturn = pdPASS;
2020:../src/RTOS/queue.c **** 
2021:../src/RTOS/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2022:../src/RTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2023:../src/RTOS/queue.c **** 				{
2024:../src/RTOS/queue.c **** 					/* In this instance the co-routine could be placed directly
2025:../src/RTOS/queue.c **** 					into the ready list as we are within a critical section.
2026:../src/RTOS/queue.c **** 					Instead the same pending ready list mechanism is used as if
2027:../src/RTOS/queue.c **** 					the event were caused from within an interrupt. */
2028:../src/RTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2029:../src/RTOS/queue.c **** 					{
2030:../src/RTOS/queue.c **** 						/* The co-routine waiting has a higher priority so record
2031:../src/RTOS/queue.c **** 						that a yield might be appropriate. */
2032:../src/RTOS/queue.c **** 						xReturn = errQUEUE_YIELD;
2033:../src/RTOS/queue.c **** 					}
2034:../src/RTOS/queue.c **** 					else
2035:../src/RTOS/queue.c **** 					{
2036:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2037:../src/RTOS/queue.c **** 					}
2038:../src/RTOS/queue.c **** 				}
2039:../src/RTOS/queue.c **** 				else
2040:../src/RTOS/queue.c **** 				{
2041:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2042:../src/RTOS/queue.c **** 				}
2043:../src/RTOS/queue.c **** 			}
2044:../src/RTOS/queue.c **** 			else
2045:../src/RTOS/queue.c **** 			{
2046:../src/RTOS/queue.c **** 				xReturn = errQUEUE_FULL;
2047:../src/RTOS/queue.c **** 			}
2048:../src/RTOS/queue.c **** 		}
2049:../src/RTOS/queue.c **** 		portENABLE_INTERRUPTS();
2050:../src/RTOS/queue.c **** 
2051:../src/RTOS/queue.c **** 		return xReturn;
2052:../src/RTOS/queue.c **** 	}
2053:../src/RTOS/queue.c **** 
2054:../src/RTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2055:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
2056:../src/RTOS/queue.c **** 
2057:../src/RTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2058:../src/RTOS/queue.c **** 
2059:../src/RTOS/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2060:../src/RTOS/queue.c **** 	{
2061:../src/RTOS/queue.c **** 	BaseType_t xReturn;
2062:../src/RTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2063:../src/RTOS/queue.c **** 
2064:../src/RTOS/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2065:../src/RTOS/queue.c **** 		is required to prevent an interrupt adding something to the queue
2066:../src/RTOS/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2067:../src/RTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2068:../src/RTOS/queue.c **** 		{
2069:../src/RTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2070:../src/RTOS/queue.c **** 			{
2071:../src/RTOS/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2072:../src/RTOS/queue.c **** 				leave with nothing? */
2073:../src/RTOS/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2074:../src/RTOS/queue.c **** 				{
2075:../src/RTOS/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2076:../src/RTOS/queue.c **** 					indicating that we need to block. */
2077:../src/RTOS/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2078:../src/RTOS/queue.c **** 					portENABLE_INTERRUPTS();
2079:../src/RTOS/queue.c **** 					return errQUEUE_BLOCKED;
2080:../src/RTOS/queue.c **** 				}
2081:../src/RTOS/queue.c **** 				else
2082:../src/RTOS/queue.c **** 				{
2083:../src/RTOS/queue.c **** 					portENABLE_INTERRUPTS();
2084:../src/RTOS/queue.c **** 					return errQUEUE_FULL;
2085:../src/RTOS/queue.c **** 				}
2086:../src/RTOS/queue.c **** 			}
2087:../src/RTOS/queue.c **** 			else
2088:../src/RTOS/queue.c **** 			{
2089:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2090:../src/RTOS/queue.c **** 			}
2091:../src/RTOS/queue.c **** 		}
2092:../src/RTOS/queue.c **** 		portENABLE_INTERRUPTS();
2093:../src/RTOS/queue.c **** 
2094:../src/RTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2095:../src/RTOS/queue.c **** 		{
2096:../src/RTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2097:../src/RTOS/queue.c **** 			{
2098:../src/RTOS/queue.c **** 				/* Data is available from the queue. */
2099:../src/RTOS/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2100:../src/RTOS/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2101:../src/RTOS/queue.c **** 				{
2102:../src/RTOS/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2103:../src/RTOS/queue.c **** 				}
2104:../src/RTOS/queue.c **** 				else
2105:../src/RTOS/queue.c **** 				{
2106:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2107:../src/RTOS/queue.c **** 				}
2108:../src/RTOS/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2109:../src/RTOS/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
2110:../src/RTOS/queue.c **** 
2111:../src/RTOS/queue.c **** 				xReturn = pdPASS;
2112:../src/RTOS/queue.c **** 
2113:../src/RTOS/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2114:../src/RTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2115:../src/RTOS/queue.c **** 				{
2116:../src/RTOS/queue.c **** 					/* In this instance the co-routine could be placed directly
2117:../src/RTOS/queue.c **** 					into the ready list as we are within a critical section.
2118:../src/RTOS/queue.c **** 					Instead the same pending ready list mechanism is used as if
2119:../src/RTOS/queue.c **** 					the event were caused from within an interrupt. */
2120:../src/RTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2121:../src/RTOS/queue.c **** 					{
2122:../src/RTOS/queue.c **** 						xReturn = errQUEUE_YIELD;
2123:../src/RTOS/queue.c **** 					}
2124:../src/RTOS/queue.c **** 					else
2125:../src/RTOS/queue.c **** 					{
2126:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2127:../src/RTOS/queue.c **** 					}
2128:../src/RTOS/queue.c **** 				}
2129:../src/RTOS/queue.c **** 				else
2130:../src/RTOS/queue.c **** 				{
2131:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2132:../src/RTOS/queue.c **** 				}
2133:../src/RTOS/queue.c **** 			}
2134:../src/RTOS/queue.c **** 			else
2135:../src/RTOS/queue.c **** 			{
2136:../src/RTOS/queue.c **** 				xReturn = pdFAIL;
2137:../src/RTOS/queue.c **** 			}
2138:../src/RTOS/queue.c **** 		}
2139:../src/RTOS/queue.c **** 		portENABLE_INTERRUPTS();
2140:../src/RTOS/queue.c **** 
2141:../src/RTOS/queue.c **** 		return xReturn;
2142:../src/RTOS/queue.c **** 	}
2143:../src/RTOS/queue.c **** 
2144:../src/RTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2145:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
2146:../src/RTOS/queue.c **** 
2147:../src/RTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2148:../src/RTOS/queue.c **** 
2149:../src/RTOS/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2150:../src/RTOS/queue.c **** 	{
2151:../src/RTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2152:../src/RTOS/queue.c **** 
2153:../src/RTOS/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2154:../src/RTOS/queue.c **** 		exit without doing anything. */
2155:../src/RTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2156:../src/RTOS/queue.c **** 		{
2157:../src/RTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2158:../src/RTOS/queue.c **** 
2159:../src/RTOS/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2160:../src/RTOS/queue.c **** 			co-routine has not already been woken. */
2161:../src/RTOS/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2162:../src/RTOS/queue.c **** 			{
2163:../src/RTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2164:../src/RTOS/queue.c **** 				{
2165:../src/RTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2166:../src/RTOS/queue.c **** 					{
2167:../src/RTOS/queue.c **** 						return pdTRUE;
2168:../src/RTOS/queue.c **** 					}
2169:../src/RTOS/queue.c **** 					else
2170:../src/RTOS/queue.c **** 					{
2171:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2172:../src/RTOS/queue.c **** 					}
2173:../src/RTOS/queue.c **** 				}
2174:../src/RTOS/queue.c **** 				else
2175:../src/RTOS/queue.c **** 				{
2176:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2177:../src/RTOS/queue.c **** 				}
2178:../src/RTOS/queue.c **** 			}
2179:../src/RTOS/queue.c **** 			else
2180:../src/RTOS/queue.c **** 			{
2181:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2182:../src/RTOS/queue.c **** 			}
2183:../src/RTOS/queue.c **** 		}
2184:../src/RTOS/queue.c **** 		else
2185:../src/RTOS/queue.c **** 		{
2186:../src/RTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2187:../src/RTOS/queue.c **** 		}
2188:../src/RTOS/queue.c **** 
2189:../src/RTOS/queue.c **** 		return xCoRoutinePreviouslyWoken;
2190:../src/RTOS/queue.c **** 	}
2191:../src/RTOS/queue.c **** 
2192:../src/RTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2193:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
2194:../src/RTOS/queue.c **** 
2195:../src/RTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2196:../src/RTOS/queue.c **** 
2197:../src/RTOS/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2198:../src/RTOS/queue.c **** 	{
2199:../src/RTOS/queue.c **** 	BaseType_t xReturn;
2200:../src/RTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2201:../src/RTOS/queue.c **** 
2202:../src/RTOS/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2203:../src/RTOS/queue.c **** 		not then just leave without doing anything. */
2204:../src/RTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2205:../src/RTOS/queue.c **** 		{
2206:../src/RTOS/queue.c **** 			/* Copy the data from the queue. */
2207:../src/RTOS/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2208:../src/RTOS/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2209:../src/RTOS/queue.c **** 			{
2210:../src/RTOS/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2211:../src/RTOS/queue.c **** 			}
2212:../src/RTOS/queue.c **** 			else
2213:../src/RTOS/queue.c **** 			{
2214:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2215:../src/RTOS/queue.c **** 			}
2216:../src/RTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2217:../src/RTOS/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
2218:../src/RTOS/queue.c **** 
2219:../src/RTOS/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2220:../src/RTOS/queue.c **** 			{
2221:../src/RTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2222:../src/RTOS/queue.c **** 				{
2223:../src/RTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2224:../src/RTOS/queue.c **** 					{
2225:../src/RTOS/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2226:../src/RTOS/queue.c **** 					}
2227:../src/RTOS/queue.c **** 					else
2228:../src/RTOS/queue.c **** 					{
2229:../src/RTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2230:../src/RTOS/queue.c **** 					}
2231:../src/RTOS/queue.c **** 				}
2232:../src/RTOS/queue.c **** 				else
2233:../src/RTOS/queue.c **** 				{
2234:../src/RTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2235:../src/RTOS/queue.c **** 				}
2236:../src/RTOS/queue.c **** 			}
2237:../src/RTOS/queue.c **** 			else
2238:../src/RTOS/queue.c **** 			{
2239:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2240:../src/RTOS/queue.c **** 			}
2241:../src/RTOS/queue.c **** 
2242:../src/RTOS/queue.c **** 			xReturn = pdPASS;
2243:../src/RTOS/queue.c **** 		}
2244:../src/RTOS/queue.c **** 		else
2245:../src/RTOS/queue.c **** 		{
2246:../src/RTOS/queue.c **** 			xReturn = pdFAIL;
2247:../src/RTOS/queue.c **** 		}
2248:../src/RTOS/queue.c **** 
2249:../src/RTOS/queue.c **** 		return xReturn;
2250:../src/RTOS/queue.c **** 	}
2251:../src/RTOS/queue.c **** 
2252:../src/RTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2253:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
2254:../src/RTOS/queue.c **** 
2255:../src/RTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2256:../src/RTOS/queue.c **** 
2257:../src/RTOS/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2258:../src/RTOS/queue.c **** 	{
 2522              		.loc 1 2258 0
 2523              		.cfi_startproc
 2524              		@ args = 0, pretend = 0, frame = 16
 2525              		@ frame_needed = 1, uses_anonymous_args = 0
 2526              		@ link register save eliminated.
 2527 0000 80B4     		push	{r7}
 2528              		.cfi_def_cfa_offset 4
 2529              		.cfi_offset 7, -4
 2530 0002 85B0     		sub	sp, sp, #20
 2531              		.cfi_def_cfa_offset 24
 2532 0004 00AF     		add	r7, sp, #0
 2533              		.cfi_def_cfa_register 7
 2534 0006 7860     		str	r0, [r7, #4]
 2535 0008 3960     		str	r1, [r7]
2259:../src/RTOS/queue.c **** 	UBaseType_t ux;
2260:../src/RTOS/queue.c **** 
2261:../src/RTOS/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2262:../src/RTOS/queue.c **** 		a free slot. */
2263:../src/RTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2536              		.loc 1 2263 0
 2537 000a 0023     		movs	r3, #0
 2538 000c FB60     		str	r3, [r7, #12]
 2539 000e 14E0     		b	.L208
 2540              	.L211:
2264:../src/RTOS/queue.c **** 		{
2265:../src/RTOS/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2541              		.loc 1 2265 0
 2542 0010 0E4A     		ldr	r2, .L212
 2543 0012 FB68     		ldr	r3, [r7, #12]
 2544 0014 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2545 0018 002B     		cmp	r3, #0
 2546 001a 0BD1     		bne	.L209
2266:../src/RTOS/queue.c **** 			{
2267:../src/RTOS/queue.c **** 				/* Store the information on this queue. */
2268:../src/RTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 2547              		.loc 1 2268 0
 2548 001c 0B49     		ldr	r1, .L212
 2549 001e FB68     		ldr	r3, [r7, #12]
 2550 0020 3A68     		ldr	r2, [r7]
 2551 0022 41F83320 		str	r2, [r1, r3, lsl #3]
2269:../src/RTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2552              		.loc 1 2269 0
 2553 0026 094A     		ldr	r2, .L212
 2554 0028 FB68     		ldr	r3, [r7, #12]
 2555 002a DB00     		lsls	r3, r3, #3
 2556 002c 1344     		add	r3, r3, r2
 2557 002e 7A68     		ldr	r2, [r7, #4]
 2558 0030 5A60     		str	r2, [r3, #4]
2270:../src/RTOS/queue.c **** 
2271:../src/RTOS/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2272:../src/RTOS/queue.c **** 				break;
 2559              		.loc 1 2272 0
 2560 0032 05E0     		b	.L207
 2561              	.L209:
2263:../src/RTOS/queue.c **** 		{
 2562              		.loc 1 2263 0 discriminator 2
 2563 0034 FB68     		ldr	r3, [r7, #12]
 2564 0036 0133     		adds	r3, r3, #1
 2565 0038 FB60     		str	r3, [r7, #12]
 2566              	.L208:
2263:../src/RTOS/queue.c **** 		{
 2567              		.loc 1 2263 0 is_stmt 0 discriminator 1
 2568 003a FB68     		ldr	r3, [r7, #12]
 2569 003c 092B     		cmp	r3, #9
 2570 003e E7D9     		bls	.L211
 2571              	.L207:
2273:../src/RTOS/queue.c **** 			}
2274:../src/RTOS/queue.c **** 			else
2275:../src/RTOS/queue.c **** 			{
2276:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2277:../src/RTOS/queue.c **** 			}
2278:../src/RTOS/queue.c **** 		}
2279:../src/RTOS/queue.c **** 	}
 2572              		.loc 1 2279 0 is_stmt 1
 2573 0040 1437     		adds	r7, r7, #20
 2574              		.cfi_def_cfa_offset 4
 2575 0042 BD46     		mov	sp, r7
 2576              		.cfi_def_cfa_register 13
 2577              		@ sp needed
 2578 0044 5DF8047B 		ldr	r7, [sp], #4
 2579              		.cfi_restore 7
 2580              		.cfi_def_cfa_offset 0
 2581 0048 7047     		bx	lr
 2582              	.L213:
 2583 004a 00BF     		.align	2
 2584              	.L212:
 2585 004c 00000000 		.word	xQueueRegistry
 2586              		.cfi_endproc
 2587              	.LFE26:
 2589              		.section	.text.pcQueueGetName,"ax",%progbits
 2590              		.align	2
 2591              		.global	pcQueueGetName
 2592              		.thumb
 2593              		.thumb_func
 2595              	pcQueueGetName:
 2596              	.LFB27:
2280:../src/RTOS/queue.c **** 
2281:../src/RTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2282:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
2283:../src/RTOS/queue.c **** 
2284:../src/RTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2285:../src/RTOS/queue.c **** 
2286:../src/RTOS/queue.c **** 	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed
2287:../src/RTOS/queue.c **** 	{
 2597              		.loc 1 2287 0
 2598              		.cfi_startproc
 2599              		@ args = 0, pretend = 0, frame = 16
 2600              		@ frame_needed = 1, uses_anonymous_args = 0
 2601              		@ link register save eliminated.
 2602 0000 80B4     		push	{r7}
 2603              		.cfi_def_cfa_offset 4
 2604              		.cfi_offset 7, -4
 2605 0002 85B0     		sub	sp, sp, #20
 2606              		.cfi_def_cfa_offset 24
 2607 0004 00AF     		add	r7, sp, #0
 2608              		.cfi_def_cfa_register 7
 2609 0006 7860     		str	r0, [r7, #4]
2288:../src/RTOS/queue.c **** 	UBaseType_t ux;
2289:../src/RTOS/queue.c **** 	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and singl
 2610              		.loc 1 2289 0
 2611 0008 0023     		movs	r3, #0
 2612 000a BB60     		str	r3, [r7, #8]
2290:../src/RTOS/queue.c **** 
2291:../src/RTOS/queue.c **** 		/* Note there is nothing here to protect against another task adding or
2292:../src/RTOS/queue.c **** 		removing entries from the registry while it is being searched. */
2293:../src/RTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2613              		.loc 1 2293 0
 2614 000c 0023     		movs	r3, #0
 2615 000e FB60     		str	r3, [r7, #12]
 2616 0010 10E0     		b	.L215
 2617              	.L218:
2294:../src/RTOS/queue.c **** 		{
2295:../src/RTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2618              		.loc 1 2295 0
 2619 0012 0D4A     		ldr	r2, .L220
 2620 0014 FB68     		ldr	r3, [r7, #12]
 2621 0016 DB00     		lsls	r3, r3, #3
 2622 0018 1344     		add	r3, r3, r2
 2623 001a 5A68     		ldr	r2, [r3, #4]
 2624 001c 7B68     		ldr	r3, [r7, #4]
 2625 001e 9A42     		cmp	r2, r3
 2626 0020 05D1     		bne	.L216
2296:../src/RTOS/queue.c **** 			{
2297:../src/RTOS/queue.c **** 				pcReturn = xQueueRegistry[ ux ].pcQueueName;
 2627              		.loc 1 2297 0
 2628 0022 094A     		ldr	r2, .L220
 2629 0024 FB68     		ldr	r3, [r7, #12]
 2630 0026 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2631 002a BB60     		str	r3, [r7, #8]
2298:../src/RTOS/queue.c **** 				break;
 2632              		.loc 1 2298 0
 2633 002c 05E0     		b	.L217
 2634              	.L216:
2293:../src/RTOS/queue.c **** 		{
 2635              		.loc 1 2293 0 discriminator 2
 2636 002e FB68     		ldr	r3, [r7, #12]
 2637 0030 0133     		adds	r3, r3, #1
 2638 0032 FB60     		str	r3, [r7, #12]
 2639              	.L215:
2293:../src/RTOS/queue.c **** 		{
 2640              		.loc 1 2293 0 is_stmt 0 discriminator 1
 2641 0034 FB68     		ldr	r3, [r7, #12]
 2642 0036 092B     		cmp	r3, #9
 2643 0038 EBD9     		bls	.L218
 2644              	.L217:
2299:../src/RTOS/queue.c **** 			}
2300:../src/RTOS/queue.c **** 			else
2301:../src/RTOS/queue.c **** 			{
2302:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2303:../src/RTOS/queue.c **** 			}
2304:../src/RTOS/queue.c **** 		}
2305:../src/RTOS/queue.c **** 
2306:../src/RTOS/queue.c **** 		return pcReturn;
 2645              		.loc 1 2306 0 is_stmt 1
 2646 003a BB68     		ldr	r3, [r7, #8]
2307:../src/RTOS/queue.c **** 	}
 2647              		.loc 1 2307 0
 2648 003c 1846     		mov	r0, r3
 2649 003e 1437     		adds	r7, r7, #20
 2650              		.cfi_def_cfa_offset 4
 2651 0040 BD46     		mov	sp, r7
 2652              		.cfi_def_cfa_register 13
 2653              		@ sp needed
 2654 0042 5DF8047B 		ldr	r7, [sp], #4
 2655              		.cfi_restore 7
 2656              		.cfi_def_cfa_offset 0
 2657 0046 7047     		bx	lr
 2658              	.L221:
 2659              		.align	2
 2660              	.L220:
 2661 0048 00000000 		.word	xQueueRegistry
 2662              		.cfi_endproc
 2663              	.LFE27:
 2665              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2666              		.align	2
 2667              		.global	vQueueUnregisterQueue
 2668              		.thumb
 2669              		.thumb_func
 2671              	vQueueUnregisterQueue:
 2672              	.LFB28:
2308:../src/RTOS/queue.c **** 
2309:../src/RTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2310:../src/RTOS/queue.c **** /*-----------------------------------------------------------*/
2311:../src/RTOS/queue.c **** 
2312:../src/RTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2313:../src/RTOS/queue.c **** 
2314:../src/RTOS/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2315:../src/RTOS/queue.c **** 	{
 2673              		.loc 1 2315 0
 2674              		.cfi_startproc
 2675              		@ args = 0, pretend = 0, frame = 16
 2676              		@ frame_needed = 1, uses_anonymous_args = 0
 2677              		@ link register save eliminated.
 2678 0000 80B4     		push	{r7}
 2679              		.cfi_def_cfa_offset 4
 2680              		.cfi_offset 7, -4
 2681 0002 85B0     		sub	sp, sp, #20
 2682              		.cfi_def_cfa_offset 24
 2683 0004 00AF     		add	r7, sp, #0
 2684              		.cfi_def_cfa_register 7
 2685 0006 7860     		str	r0, [r7, #4]
2316:../src/RTOS/queue.c **** 	UBaseType_t ux;
2317:../src/RTOS/queue.c **** 
2318:../src/RTOS/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2319:../src/RTOS/queue.c **** 		registry. */
2320:../src/RTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2686              		.loc 1 2320 0
 2687 0008 0023     		movs	r3, #0
 2688 000a FB60     		str	r3, [r7, #12]
 2689 000c 16E0     		b	.L223
 2690              	.L226:
2321:../src/RTOS/queue.c **** 		{
2322:../src/RTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2691              		.loc 1 2322 0
 2692 000e 0F4A     		ldr	r2, .L227
 2693 0010 FB68     		ldr	r3, [r7, #12]
 2694 0012 DB00     		lsls	r3, r3, #3
 2695 0014 1344     		add	r3, r3, r2
 2696 0016 5A68     		ldr	r2, [r3, #4]
 2697 0018 7B68     		ldr	r3, [r7, #4]
 2698 001a 9A42     		cmp	r2, r3
 2699 001c 0BD1     		bne	.L224
2323:../src/RTOS/queue.c **** 			{
2324:../src/RTOS/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2325:../src/RTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 2700              		.loc 1 2325 0
 2701 001e 0B4A     		ldr	r2, .L227
 2702 0020 FB68     		ldr	r3, [r7, #12]
 2703 0022 0021     		movs	r1, #0
 2704 0024 42F83310 		str	r1, [r2, r3, lsl #3]
2326:../src/RTOS/queue.c **** 
2327:../src/RTOS/queue.c **** 				/* Set the handle to NULL to ensure the same queue handle cannot
2328:../src/RTOS/queue.c **** 				appear in the registry twice if it is added, removed, then
2329:../src/RTOS/queue.c **** 				added again. */
2330:../src/RTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 2705              		.loc 1 2330 0
 2706 0028 084A     		ldr	r2, .L227
 2707 002a FB68     		ldr	r3, [r7, #12]
 2708 002c DB00     		lsls	r3, r3, #3
 2709 002e 1344     		add	r3, r3, r2
 2710 0030 0022     		movs	r2, #0
 2711 0032 5A60     		str	r2, [r3, #4]
2331:../src/RTOS/queue.c **** 				break;
 2712              		.loc 1 2331 0
 2713 0034 05E0     		b	.L222
 2714              	.L224:
2320:../src/RTOS/queue.c **** 		{
 2715              		.loc 1 2320 0 discriminator 2
 2716 0036 FB68     		ldr	r3, [r7, #12]
 2717 0038 0133     		adds	r3, r3, #1
 2718 003a FB60     		str	r3, [r7, #12]
 2719              	.L223:
2320:../src/RTOS/queue.c **** 		{
 2720              		.loc 1 2320 0 is_stmt 0 discriminator 1
 2721 003c FB68     		ldr	r3, [r7, #12]
 2722 003e 092B     		cmp	r3, #9
 2723 0040 E5D9     		bls	.L226
 2724              	.L222:
2332:../src/RTOS/queue.c **** 			}
2333:../src/RTOS/queue.c **** 			else
2334:../src/RTOS/queue.c **** 			{
2335:../src/RTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2336:../src/RTOS/queue.c **** 			}
2337:../src/RTOS/queue.c **** 		}
2338:../src/RTOS/queue.c **** 
2339:../src/RTOS/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2725              		.loc 1 2339 0 is_stmt 1
 2726 0042 1437     		adds	r7, r7, #20
 2727              		.cfi_def_cfa_offset 4
 2728 0044 BD46     		mov	sp, r7
 2729              		.cfi_def_cfa_register 13
 2730              		@ sp needed
 2731 0046 5DF8047B 		ldr	r7, [sp], #4
 2732              		.cfi_restore 7
 2733              		.cfi_def_cfa_offset 0
 2734 004a 7047     		bx	lr
 2735              	.L228:
 2736              		.align	2
 2737              	.L227:
 2738 004c 00000000 		.word	xQueueRegistry
 2739              		.cfi_endproc
 2740              	.LFE28:
 2742              		.text
 2743              	.Letext0:
 2744              		.file 3 "c:\\program files (x86)\\emprog\\thunderbench-arm-v3.85\\arm\\lib\\gcc\\arm-none-eabi\\4.
 2745              		.file 4 "c:\\program files (x86)\\emprog\\thunderbench-arm-v3.85\\arm\\arm-none-eabi\\include\\mac
 2746              		.file 5 "c:\\program files (x86)\\emprog\\thunderbench-arm-v3.85\\arm\\arm-none-eabi\\include\\std
 2747              		.file 6 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/list.h"
 2748              		.file 7 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/task.h"
 2749              		.file 8 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/queue.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
                            *COM*:00000050 xQueueRegistry
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:20     .text.xQueueGenericReset:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:25     .text.xQueueGenericReset:00000000 xQueueGenericReset
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:151    .text.xQueueGenericReset:000000b8 $d
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:156    .text.xQueueGenericCreate:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:161    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:245    .text.prvInitialiseNewQueue:00000000 prvInitialiseNewQueue
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:241    .text.prvInitialiseNewQueue:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:301    .text.prvInitialiseMutex:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:305    .text.prvInitialiseMutex:00000000 prvInitialiseMutex
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:409    .text.xQueueGenericSend:00000000 xQueueGenericSend
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:354    .text.xQueueCreateMutex:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:359    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:404    .text.xQueueGenericSend:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1950   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2405   .text.prvIsQueueFull:00000000 prvIsQueueFull
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2169   .text.prvUnlockQueue:00000000 prvUnlockQueue
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:707    .text.xQueueGenericSend:000001b0 $d
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:712    .text.xQueueGenericSendFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:717    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:911    .text.xQueueGiveFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:916    .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1092   .text.xQueueGenericReceive:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1097   .text.xQueueGenericReceive:00000000 xQueueGenericReceive
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2102   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2295   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1425   .text.xQueueGenericReceive:000001f0 $d
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1430   .text.xQueueReceiveFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1435   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1604   .text.xQueuePeekFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1609   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1743   .text.uxQueueMessagesWaiting:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1748   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1793   .text.uxQueueSpacesAvailable:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1798   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1849   .text.uxQueueMessagesWaitingFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1854   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1898   .text.vQueueDelete:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1903   .text.vQueueDelete:00000000 vQueueDelete
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2671   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:1946   .text.prvCopyDataToQueue:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2098   .text.prvCopyDataFromQueue:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2165   .text.prvUnlockQueue:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2291   .text.prvIsQueueEmpty:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2342   .text.xQueueIsQueueEmptyFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2347   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2401   .text.prvIsQueueFull:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2454   .text.xQueueIsQueueFullFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2459   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2515   .text.vQueueAddToRegistry:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2520   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2585   .text.vQueueAddToRegistry:0000004c $d
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2590   .text.pcQueueGetName:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2595   .text.pcQueueGetName:00000000 pcQueueGetName
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2661   .text.pcQueueGetName:00000048 $d
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2666   .text.vQueueUnregisterQueue:00000000 $t
C:\Users\Riley\AppData\Local\Temp\cc9XS7MA.s:2738   .text.vQueueUnregisterQueue:0000004c $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vPortEnterCritical
xTaskRemoveFromEventList
vListInitialise
vPortExitCritical
pvPortMalloc
xTaskGetSchedulerState
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortValidateInterruptPriority
pvTaskIncrementMutexHeldCount
vTaskPriorityInherit
vPortFree
xTaskPriorityDisinherit
memcpy
vTaskMissedYield
