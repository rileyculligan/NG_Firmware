   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tasks.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	pxCurrentTCB
  19              		.section	.bss.pxCurrentTCB,"aw",%nobits
  20              		.align	2
  23              	pxCurrentTCB:
  24 0000 00000000 		.space	4
  25              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  26              		.align	2
  29              	pxReadyTasksLists:
  30 0000 00000000 		.space	200
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  32              		.align	2
  35              	xDelayedTaskList1:
  36 0000 00000000 		.space	20
  36      00000000 
  36      00000000 
  36      00000000 
  36      00000000 
  37              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  38              		.align	2
  41              	xDelayedTaskList2:
  42 0000 00000000 		.space	20
  42      00000000 
  42      00000000 
  42      00000000 
  42      00000000 
  43              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  44              		.align	2
  47              	pxDelayedTaskList:
  48 0000 00000000 		.space	4
  49              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  50              		.align	2
  53              	pxOverflowDelayedTaskList:
  54 0000 00000000 		.space	4
  55              		.section	.bss.xPendingReadyList,"aw",%nobits
  56              		.align	2
  59              	xPendingReadyList:
  60 0000 00000000 		.space	20
  60      00000000 
  60      00000000 
  60      00000000 
  60      00000000 
  61              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  62              		.align	2
  65              	xSuspendedTaskList:
  66 0000 00000000 		.space	20
  66      00000000 
  66      00000000 
  66      00000000 
  66      00000000 
  67              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  68              		.align	2
  71              	uxCurrentNumberOfTasks:
  72 0000 00000000 		.space	4
  73              		.section	.bss.xTickCount,"aw",%nobits
  74              		.align	2
  77              	xTickCount:
  78 0000 00000000 		.space	4
  79              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  80              		.align	2
  83              	uxTopReadyPriority:
  84 0000 00000000 		.space	4
  85              		.section	.bss.xSchedulerRunning,"aw",%nobits
  86              		.align	2
  89              	xSchedulerRunning:
  90 0000 00000000 		.space	4
  91              		.section	.bss.uxPendedTicks,"aw",%nobits
  92              		.align	2
  95              	uxPendedTicks:
  96 0000 00000000 		.space	4
  97              		.section	.bss.xYieldPending,"aw",%nobits
  98              		.align	2
 101              	xYieldPending:
 102 0000 00000000 		.space	4
 103              		.section	.bss.xNumOfOverflows,"aw",%nobits
 104              		.align	2
 107              	xNumOfOverflows:
 108 0000 00000000 		.space	4
 109              		.section	.bss.uxTaskNumber,"aw",%nobits
 110              		.align	2
 113              	uxTaskNumber:
 114 0000 00000000 		.space	4
 115              		.section	.bss.xNextTaskUnblockTime,"aw",%nobits
 116              		.align	2
 119              	xNextTaskUnblockTime:
 120 0000 00000000 		.space	4
 121              		.section	.bss.xIdleTaskHandle,"aw",%nobits
 122              		.align	2
 125              	xIdleTaskHandle:
 126 0000 00000000 		.space	4
 127              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 128              		.align	2
 131              	uxSchedulerSuspended:
 132 0000 00000000 		.space	4
 133              		.section	.text.xTaskCreate,"ax",%progbits
 134              		.align	2
 135              		.global	xTaskCreate
 136              		.thumb
 137              		.thumb_func
 139              	xTaskCreate:
 140              	.LFB4:
 141              		.file 1 "../src/RTOS/tasks.c"
   1:../src/RTOS/tasks.c **** /*
   2:../src/RTOS/tasks.c ****     FreeRTOS V9.0.0rc2 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:../src/RTOS/tasks.c ****     All rights reserved
   4:../src/RTOS/tasks.c **** 
   5:../src/RTOS/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../src/RTOS/tasks.c **** 
   7:../src/RTOS/tasks.c ****     This file is part of the FreeRTOS distribution.
   8:../src/RTOS/tasks.c **** 
   9:../src/RTOS/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:../src/RTOS/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:../src/RTOS/tasks.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:../src/RTOS/tasks.c **** 
  13:../src/RTOS/tasks.c ****     ***************************************************************************
  14:../src/RTOS/tasks.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:../src/RTOS/tasks.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:../src/RTOS/tasks.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:../src/RTOS/tasks.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:../src/RTOS/tasks.c ****     ***************************************************************************
  19:../src/RTOS/tasks.c **** 
  20:../src/RTOS/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:../src/RTOS/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:../src/RTOS/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:../src/RTOS/tasks.c ****     link: http://www.freertos.org/a00114.html
  24:../src/RTOS/tasks.c **** 
  25:../src/RTOS/tasks.c ****     ***************************************************************************
  26:../src/RTOS/tasks.c ****      *                                                                       *
  27:../src/RTOS/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:../src/RTOS/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:../src/RTOS/tasks.c ****      *    platform software that is more than just the market leader, it     *
  30:../src/RTOS/tasks.c ****      *    is the industry's de facto standard.                               *
  31:../src/RTOS/tasks.c ****      *                                                                       *
  32:../src/RTOS/tasks.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:../src/RTOS/tasks.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:../src/RTOS/tasks.c ****      *    tutorial book, reference manual, or both:                          *
  35:../src/RTOS/tasks.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:../src/RTOS/tasks.c ****      *                                                                       *
  37:../src/RTOS/tasks.c ****     ***************************************************************************
  38:../src/RTOS/tasks.c **** 
  39:../src/RTOS/tasks.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:../src/RTOS/tasks.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:../src/RTOS/tasks.c ****     defined configASSERT()?
  42:../src/RTOS/tasks.c **** 
  43:../src/RTOS/tasks.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:../src/RTOS/tasks.c ****     embedded software for free we request you assist our global community by
  45:../src/RTOS/tasks.c ****     participating in the support forum.
  46:../src/RTOS/tasks.c **** 
  47:../src/RTOS/tasks.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:../src/RTOS/tasks.c ****     be as productive as possible as early as possible.  Now you can receive
  49:../src/RTOS/tasks.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:../src/RTOS/tasks.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:../src/RTOS/tasks.c **** 
  52:../src/RTOS/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:../src/RTOS/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:../src/RTOS/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:../src/RTOS/tasks.c **** 
  56:../src/RTOS/tasks.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:../src/RTOS/tasks.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:../src/RTOS/tasks.c **** 
  59:../src/RTOS/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:../src/RTOS/tasks.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:../src/RTOS/tasks.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:../src/RTOS/tasks.c **** 
  63:../src/RTOS/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:../src/RTOS/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  65:../src/RTOS/tasks.c ****     mission critical applications that require provable dependability.
  66:../src/RTOS/tasks.c **** 
  67:../src/RTOS/tasks.c ****     1 tab == 4 spaces!
  68:../src/RTOS/tasks.c **** */
  69:../src/RTOS/tasks.c **** 
  70:../src/RTOS/tasks.c **** /* Standard includes. */
  71:../src/RTOS/tasks.c **** #include <stdlib.h>
  72:../src/RTOS/tasks.c **** #include <string.h>
  73:../src/RTOS/tasks.c **** 
  74:../src/RTOS/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  75:../src/RTOS/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  76:../src/RTOS/tasks.c **** task.h is included from an application file. */
  77:../src/RTOS/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  78:../src/RTOS/tasks.c **** 
  79:../src/RTOS/tasks.c **** /* FreeRTOS includes. */
  80:../src/RTOS/tasks.c **** #include "FreeRTOS.h"
  81:../src/RTOS/tasks.c **** #include "task.h"
  82:../src/RTOS/tasks.c **** #include "timers.h"
  83:../src/RTOS/tasks.c **** #include "StackMacros.h"
  84:../src/RTOS/tasks.c **** 
  85:../src/RTOS/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  86:../src/RTOS/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  87:../src/RTOS/tasks.c **** header files above, but not in this file, in order to generate the correct
  88:../src/RTOS/tasks.c **** privileged Vs unprivileged linkage and placement. */
  89:../src/RTOS/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  90:../src/RTOS/tasks.c **** 
  91:../src/RTOS/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  92:../src/RTOS/tasks.c **** functions but without including stdio.h here. */
  93:../src/RTOS/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  94:../src/RTOS/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  95:../src/RTOS/tasks.c **** 	to generate human readable text from the raw data generated by the
  96:../src/RTOS/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  97:../src/RTOS/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  98:../src/RTOS/tasks.c **** 	#include <stdio.h>
  99:../src/RTOS/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
 100:../src/RTOS/tasks.c **** 
 101:../src/RTOS/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 102:../src/RTOS/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 103:../src/RTOS/tasks.c **** 	performed just because a higher priority task has been woken. */
 104:../src/RTOS/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 105:../src/RTOS/tasks.c **** #else
 106:../src/RTOS/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 107:../src/RTOS/tasks.c **** #endif
 108:../src/RTOS/tasks.c **** 
 109:../src/RTOS/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
 110:../src/RTOS/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
 111:../src/RTOS/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
 112:../src/RTOS/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
 113:../src/RTOS/tasks.c **** 
 114:../src/RTOS/tasks.c **** /*
 115:../src/RTOS/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 116:../src/RTOS/tasks.c ****  * is used purely for checking the high water mark for tasks.
 117:../src/RTOS/tasks.c ****  */
 118:../src/RTOS/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 119:../src/RTOS/tasks.c **** 
 120:../src/RTOS/tasks.c **** /*
 121:../src/RTOS/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 122:../src/RTOS/tasks.c ****  */
 123:../src/RTOS/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 124:../src/RTOS/tasks.c **** #define tskREADY_CHAR		( 'R' )
 125:../src/RTOS/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 126:../src/RTOS/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 127:../src/RTOS/tasks.c **** 
 128:../src/RTOS/tasks.c **** /*
 129:../src/RTOS/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 130:../src/RTOS/tasks.c ****  * global, rather than file scope.
 131:../src/RTOS/tasks.c ****  */
 132:../src/RTOS/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 133:../src/RTOS/tasks.c **** 	#define static
 134:../src/RTOS/tasks.c **** #endif
 135:../src/RTOS/tasks.c **** 
 136:../src/RTOS/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 137:../src/RTOS/tasks.c **** 
 138:../src/RTOS/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 139:../src/RTOS/tasks.c **** 	performed in a generic way that is not optimised to any particular
 140:../src/RTOS/tasks.c **** 	microcontroller architecture. */
 141:../src/RTOS/tasks.c **** 
 142:../src/RTOS/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 143:../src/RTOS/tasks.c **** 	state task. */
 144:../src/RTOS/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 145:../src/RTOS/tasks.c **** 	{																									\
 146:../src/RTOS/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 147:../src/RTOS/tasks.c **** 		{																								\
 148:../src/RTOS/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 149:../src/RTOS/tasks.c **** 		}																								\
 150:../src/RTOS/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 151:../src/RTOS/tasks.c **** 
 152:../src/RTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 153:../src/RTOS/tasks.c **** 
 154:../src/RTOS/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 155:../src/RTOS/tasks.c **** 	{																									\
 156:../src/RTOS/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 157:../src/RTOS/tasks.c **** 																										\
 158:../src/RTOS/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 159:../src/RTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 160:../src/RTOS/tasks.c **** 		{																								\
 161:../src/RTOS/tasks.c **** 			configASSERT( uxTopPriority );																\
 162:../src/RTOS/tasks.c **** 			--uxTopPriority;																			\
 163:../src/RTOS/tasks.c **** 		}																								\
 164:../src/RTOS/tasks.c **** 																										\
 165:../src/RTOS/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 166:../src/RTOS/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 167:../src/RTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 168:../src/RTOS/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 169:../src/RTOS/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 170:../src/RTOS/tasks.c **** 
 171:../src/RTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 172:../src/RTOS/tasks.c **** 
 173:../src/RTOS/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 174:../src/RTOS/tasks.c **** 	they are only required when a port optimised method of task selection is
 175:../src/RTOS/tasks.c **** 	being used. */
 176:../src/RTOS/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 177:../src/RTOS/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 178:../src/RTOS/tasks.c **** 
 179:../src/RTOS/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 180:../src/RTOS/tasks.c **** 
 181:../src/RTOS/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 182:../src/RTOS/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 183:../src/RTOS/tasks.c **** 	architecture being used. */
 184:../src/RTOS/tasks.c **** 
 185:../src/RTOS/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 186:../src/RTOS/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 187:../src/RTOS/tasks.c **** 
 188:../src/RTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 189:../src/RTOS/tasks.c **** 
 190:../src/RTOS/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 191:../src/RTOS/tasks.c **** 	{																								\
 192:../src/RTOS/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 193:../src/RTOS/tasks.c **** 																									\
 194:../src/RTOS/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 195:../src/RTOS/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 196:../src/RTOS/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 197:../src/RTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 198:../src/RTOS/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 199:../src/RTOS/tasks.c **** 
 200:../src/RTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 201:../src/RTOS/tasks.c **** 
 202:../src/RTOS/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 203:../src/RTOS/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 204:../src/RTOS/tasks.c **** 	or suspended list then it won't be in a ready list. */
 205:../src/RTOS/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 206:../src/RTOS/tasks.c **** 	{																									\
 207:../src/RTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 208:../src/RTOS/tasks.c **** 		{																								\
 209:../src/RTOS/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 210:../src/RTOS/tasks.c **** 		}																								\
 211:../src/RTOS/tasks.c **** 	}
 212:../src/RTOS/tasks.c **** 
 213:../src/RTOS/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 214:../src/RTOS/tasks.c **** 
 215:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
 216:../src/RTOS/tasks.c **** 
 217:../src/RTOS/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 218:../src/RTOS/tasks.c **** count overflows. */
 219:../src/RTOS/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 220:../src/RTOS/tasks.c **** {																									\
 221:../src/RTOS/tasks.c **** 	List_t *pxTemp;																					\
 222:../src/RTOS/tasks.c **** 																									\
 223:../src/RTOS/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 224:../src/RTOS/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 225:../src/RTOS/tasks.c **** 																									\
 226:../src/RTOS/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 227:../src/RTOS/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 228:../src/RTOS/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 229:../src/RTOS/tasks.c **** 	xNumOfOverflows++;																				\
 230:../src/RTOS/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 231:../src/RTOS/tasks.c **** }
 232:../src/RTOS/tasks.c **** 
 233:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
 234:../src/RTOS/tasks.c **** 
 235:../src/RTOS/tasks.c **** /*
 236:../src/RTOS/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 237:../src/RTOS/tasks.c ****  * the task.  It is inserted at the end of the list.
 238:../src/RTOS/tasks.c ****  */
 239:../src/RTOS/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 240:../src/RTOS/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 241:../src/RTOS/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 242:../src/RTOS/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 243:../src/RTOS/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 244:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
 245:../src/RTOS/tasks.c **** 
 246:../src/RTOS/tasks.c **** /*
 247:../src/RTOS/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 248:../src/RTOS/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 249:../src/RTOS/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 250:../src/RTOS/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 251:../src/RTOS/tasks.c ****  */
 252:../src/RTOS/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 253:../src/RTOS/tasks.c **** 
 254:../src/RTOS/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 255:../src/RTOS/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 256:../src/RTOS/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 257:../src/RTOS/tasks.c **** is important its value is not updated due to a task priority change while it is
 258:../src/RTOS/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 259:../src/RTOS/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 260:../src/RTOS/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 261:../src/RTOS/tasks.c **** to its original value when it is released. */
 262:../src/RTOS/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 263:../src/RTOS/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 264:../src/RTOS/tasks.c **** #else
 265:../src/RTOS/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 266:../src/RTOS/tasks.c **** #endif
 267:../src/RTOS/tasks.c **** 
 268:../src/RTOS/tasks.c **** /*
 269:../src/RTOS/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 270:../src/RTOS/tasks.c ****  * and stores task state information, including a pointer to the task's context
 271:../src/RTOS/tasks.c ****  * (the task's run time environment, including register values)
 272:../src/RTOS/tasks.c ****  */
 273:../src/RTOS/tasks.c **** typedef struct tskTaskControlBlock
 274:../src/RTOS/tasks.c **** {
 275:../src/RTOS/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 276:../src/RTOS/tasks.c **** 
 277:../src/RTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 278:../src/RTOS/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 279:../src/RTOS/tasks.c **** 	#endif
 280:../src/RTOS/tasks.c **** 
 281:../src/RTOS/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 282:../src/RTOS/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 283:../src/RTOS/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 284:../src/RTOS/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 285:../src/RTOS/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 286:../src/RTOS/tasks.c **** 
 287:../src/RTOS/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 288:../src/RTOS/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack 
 289:../src/RTOS/tasks.c **** 	#endif
 290:../src/RTOS/tasks.c **** 
 291:../src/RTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 292:../src/RTOS/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 293:../src/RTOS/tasks.c **** 	#endif
 294:../src/RTOS/tasks.c **** 
 295:../src/RTOS/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 296:../src/RTOS/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 297:../src/RTOS/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 298:../src/RTOS/tasks.c **** 	#endif
 299:../src/RTOS/tasks.c **** 
 300:../src/RTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 301:../src/RTOS/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 302:../src/RTOS/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 303:../src/RTOS/tasks.c **** 	#endif
 304:../src/RTOS/tasks.c **** 
 305:../src/RTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 306:../src/RTOS/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 307:../src/RTOS/tasks.c **** 	#endif
 308:../src/RTOS/tasks.c **** 
 309:../src/RTOS/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 310:../src/RTOS/tasks.c **** 		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 311:../src/RTOS/tasks.c **** 	#endif
 312:../src/RTOS/tasks.c **** 
 313:../src/RTOS/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 314:../src/RTOS/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 315:../src/RTOS/tasks.c **** 	#endif
 316:../src/RTOS/tasks.c **** 
 317:../src/RTOS/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 318:../src/RTOS/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 319:../src/RTOS/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 320:../src/RTOS/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 321:../src/RTOS/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 322:../src/RTOS/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 323:../src/RTOS/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 324:../src/RTOS/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 325:../src/RTOS/tasks.c **** 		struct	_reent xNewLib_reent;
 326:../src/RTOS/tasks.c **** 	#endif
 327:../src/RTOS/tasks.c **** 
 328:../src/RTOS/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 329:../src/RTOS/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 330:../src/RTOS/tasks.c **** 		volatile uint8_t ucNotifyState;
 331:../src/RTOS/tasks.c **** 	#endif
 332:../src/RTOS/tasks.c **** 
 333:../src/RTOS/tasks.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 334:../src/RTOS/tasks.c **** 		uint8_t	ucStaticallyAllocated; /* Set to pdTRUE if the task is a statically allocated to ensure n
 335:../src/RTOS/tasks.c **** 	#endif
 336:../src/RTOS/tasks.c **** 
 337:../src/RTOS/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 338:../src/RTOS/tasks.c **** 		uint8_t ucDelayAborted;
 339:../src/RTOS/tasks.c **** 	#endif
 340:../src/RTOS/tasks.c **** 
 341:../src/RTOS/tasks.c **** } tskTCB;
 342:../src/RTOS/tasks.c **** 
 343:../src/RTOS/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 344:../src/RTOS/tasks.c **** below to enable the use of older kernel aware debuggers. */
 345:../src/RTOS/tasks.c **** typedef tskTCB TCB_t;
 346:../src/RTOS/tasks.c **** 
 347:../src/RTOS/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 348:../src/RTOS/tasks.c **** static variables must be declared volatile. */
 349:../src/RTOS/tasks.c **** 
 350:../src/RTOS/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 351:../src/RTOS/tasks.c **** 
 352:../src/RTOS/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 353:../src/RTOS/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 354:../src/RTOS/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 355:../src/RTOS/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 356:../src/RTOS/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 357:../src/RTOS/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 358:../src/RTOS/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 359:../src/RTOS/tasks.c **** 
 360:../src/RTOS/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 361:../src/RTOS/tasks.c **** 
 362:../src/RTOS/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 363:../src/RTOS/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 364:../src/RTOS/tasks.c **** 
 365:../src/RTOS/tasks.c **** #endif
 366:../src/RTOS/tasks.c **** 
 367:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 368:../src/RTOS/tasks.c **** 
 369:../src/RTOS/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 370:../src/RTOS/tasks.c **** 
 371:../src/RTOS/tasks.c **** #endif
 372:../src/RTOS/tasks.c **** 
 373:../src/RTOS/tasks.c **** /* Other file private variables. --------------------------------*/
 374:../src/RTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 375:../src/RTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
 376:../src/RTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 377:../src/RTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 378:../src/RTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 379:../src/RTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 380:../src/RTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 381:../src/RTOS/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 382:../src/RTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 383:../src/RTOS/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 384:../src/RTOS/tasks.c **** 
 385:../src/RTOS/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 386:../src/RTOS/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 387:../src/RTOS/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 388:../src/RTOS/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 389:../src/RTOS/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 390:../src/RTOS/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 391:../src/RTOS/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 392:../src/RTOS/tasks.c **** accessed from a critical section. */
 393:../src/RTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 394:../src/RTOS/tasks.c **** 
 395:../src/RTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 396:../src/RTOS/tasks.c **** 
 397:../src/RTOS/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 398:../src/RTOS/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 399:../src/RTOS/tasks.c **** 
 400:../src/RTOS/tasks.c **** #endif
 401:../src/RTOS/tasks.c **** 
 402:../src/RTOS/tasks.c **** /*lint +e956 */
 403:../src/RTOS/tasks.c **** 
 404:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
 405:../src/RTOS/tasks.c **** 
 406:../src/RTOS/tasks.c **** /* Callback function prototypes. --------------------------*/
 407:../src/RTOS/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 408:../src/RTOS/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 409:../src/RTOS/tasks.c **** #endif
 410:../src/RTOS/tasks.c **** 
 411:../src/RTOS/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 412:../src/RTOS/tasks.c **** 	extern void vApplicationTickHook( void );
 413:../src/RTOS/tasks.c **** #endif
 414:../src/RTOS/tasks.c **** 
 415:../src/RTOS/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 416:../src/RTOS/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 417:../src/RTOS/tasks.c **** #endif
 418:../src/RTOS/tasks.c **** 
 419:../src/RTOS/tasks.c **** /* File private functions. --------------------------------*/
 420:../src/RTOS/tasks.c **** 
 421:../src/RTOS/tasks.c **** /**
 422:../src/RTOS/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 423:../src/RTOS/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 424:../src/RTOS/tasks.c ****  * is in any other state.
 425:../src/RTOS/tasks.c ****  */
 426:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 427:../src/RTOS/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 428:../src/RTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 429:../src/RTOS/tasks.c **** 
 430:../src/RTOS/tasks.c **** /*
 431:../src/RTOS/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 432:../src/RTOS/tasks.c ****  * automatically upon the creation of the first task.
 433:../src/RTOS/tasks.c ****  */
 434:../src/RTOS/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 435:../src/RTOS/tasks.c **** 
 436:../src/RTOS/tasks.c **** /*
 437:../src/RTOS/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 438:../src/RTOS/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 439:../src/RTOS/tasks.c ****  * creation of the first user task.
 440:../src/RTOS/tasks.c ****  *
 441:../src/RTOS/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 442:../src/RTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 443:../src/RTOS/tasks.c ****  *
 444:../src/RTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
 445:../src/RTOS/tasks.c ****  *
 446:../src/RTOS/tasks.c ****  */
 447:../src/RTOS/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 448:../src/RTOS/tasks.c **** 
 449:../src/RTOS/tasks.c **** /*
 450:../src/RTOS/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 451:../src/RTOS/tasks.c ****  * including the stack pointed to by the TCB.
 452:../src/RTOS/tasks.c ****  *
 453:../src/RTOS/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 454:../src/RTOS/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 455:../src/RTOS/tasks.c ****  */
 456:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 457:../src/RTOS/tasks.c **** 
 458:../src/RTOS/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 459:../src/RTOS/tasks.c **** 
 460:../src/RTOS/tasks.c **** #endif
 461:../src/RTOS/tasks.c **** 
 462:../src/RTOS/tasks.c **** /*
 463:../src/RTOS/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 464:../src/RTOS/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 465:../src/RTOS/tasks.c ****  * and its TCB deleted.
 466:../src/RTOS/tasks.c ****  */
 467:../src/RTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 468:../src/RTOS/tasks.c **** 
 469:../src/RTOS/tasks.c **** /*
 470:../src/RTOS/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 471:../src/RTOS/tasks.c ****  * either the current or the overflow delayed task list.
 472:../src/RTOS/tasks.c ****  */
 473:../src/RTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 474:../src/RTOS/tasks.c **** 
 475:../src/RTOS/tasks.c **** /*
 476:../src/RTOS/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 477:../src/RTOS/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 478:../src/RTOS/tasks.c ****  * a suspended list, etc.).
 479:../src/RTOS/tasks.c ****  *
 480:../src/RTOS/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 481:../src/RTOS/tasks.c ****  * NORMAL APPLICATION CODE.
 482:../src/RTOS/tasks.c ****  */
 483:../src/RTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 484:../src/RTOS/tasks.c **** 
 485:../src/RTOS/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 486:../src/RTOS/tasks.c **** 
 487:../src/RTOS/tasks.c **** #endif
 488:../src/RTOS/tasks.c **** 
 489:../src/RTOS/tasks.c **** /*
 490:../src/RTOS/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 491:../src/RTOS/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 492:../src/RTOS/tasks.c ****  */
 493:../src/RTOS/tasks.c **** #if ( INCLUDE_xTaskGetTaskHandle == 1 )
 494:../src/RTOS/tasks.c **** 
 495:../src/RTOS/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 496:../src/RTOS/tasks.c **** 
 497:../src/RTOS/tasks.c **** #endif
 498:../src/RTOS/tasks.c **** 
 499:../src/RTOS/tasks.c **** /*
 500:../src/RTOS/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 501:../src/RTOS/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 502:../src/RTOS/tasks.c ****  * determining how much of the stack remains at the original preset value.
 503:../src/RTOS/tasks.c ****  */
 504:../src/RTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 505:../src/RTOS/tasks.c **** 
 506:../src/RTOS/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 507:../src/RTOS/tasks.c **** 
 508:../src/RTOS/tasks.c **** #endif
 509:../src/RTOS/tasks.c **** 
 510:../src/RTOS/tasks.c **** /*
 511:../src/RTOS/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 512:../src/RTOS/tasks.c ****  * next move a task from the Blocked state to the Running state.
 513:../src/RTOS/tasks.c ****  *
 514:../src/RTOS/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 515:../src/RTOS/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 516:../src/RTOS/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 517:../src/RTOS/tasks.c ****  * set to a value other than 1.
 518:../src/RTOS/tasks.c ****  */
 519:../src/RTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 520:../src/RTOS/tasks.c **** 
 521:../src/RTOS/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 522:../src/RTOS/tasks.c **** 
 523:../src/RTOS/tasks.c **** #endif
 524:../src/RTOS/tasks.c **** 
 525:../src/RTOS/tasks.c **** /*
 526:../src/RTOS/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 527:../src/RTOS/tasks.c ****  * will exit the Blocked state.
 528:../src/RTOS/tasks.c ****  */
 529:../src/RTOS/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 530:../src/RTOS/tasks.c **** 
 531:../src/RTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 532:../src/RTOS/tasks.c **** 
 533:../src/RTOS/tasks.c **** 	/*
 534:../src/RTOS/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 535:../src/RTOS/tasks.c **** 	 * human readable tables of task information.
 536:../src/RTOS/tasks.c **** 	 */
 537:../src/RTOS/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 538:../src/RTOS/tasks.c **** 
 539:../src/RTOS/tasks.c **** #endif
 540:../src/RTOS/tasks.c **** 
 541:../src/RTOS/tasks.c **** /*
 542:../src/RTOS/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 543:../src/RTOS/tasks.c ****  * dynamically to fill in the structure's members.
 544:../src/RTOS/tasks.c ****  */
 545:../src/RTOS/tasks.c **** static void prvInitialiseNewTask( TaskFunction_t pxTaskCode, const char * const pcName, const uint1
 546:../src/RTOS/tasks.c **** 
 547:../src/RTOS/tasks.c **** /*
 548:../src/RTOS/tasks.c ****  * Called after a new task has been created and initialised to place the task
 549:../src/RTOS/tasks.c ****  * under the control of the scheduler.
 550:../src/RTOS/tasks.c ****  */
 551:../src/RTOS/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 552:../src/RTOS/tasks.c **** 
 553:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
 554:../src/RTOS/tasks.c **** 
 555:../src/RTOS/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 556:../src/RTOS/tasks.c **** 
 557:../src/RTOS/tasks.c **** 	BaseType_t xTaskCreateStatic( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 558:../src/RTOS/tasks.c **** 	{
 559:../src/RTOS/tasks.c **** 	TCB_t *pxNewTCB;
 560:../src/RTOS/tasks.c **** 	BaseType_t xReturn;
 561:../src/RTOS/tasks.c **** 
 562:../src/RTOS/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 563:../src/RTOS/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 564:../src/RTOS/tasks.c **** 
 565:../src/RTOS/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 566:../src/RTOS/tasks.c **** 		{
 567:../src/RTOS/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 568:../src/RTOS/tasks.c **** 			function - use them. */
 569:../src/RTOS/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are desig
 570:../src/RTOS/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 571:../src/RTOS/tasks.c **** 
 572:../src/RTOS/tasks.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 573:../src/RTOS/tasks.c **** 			{
 574:../src/RTOS/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 575:../src/RTOS/tasks.c **** 				task was created statically in case the task is later deleted. */
 576:../src/RTOS/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = pdTRUE;
 577:../src/RTOS/tasks.c **** 			}
 578:../src/RTOS/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 579:../src/RTOS/tasks.c **** 
 580:../src/RTOS/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask,
 581:../src/RTOS/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 582:../src/RTOS/tasks.c **** 			xReturn = pdPASS;
 583:../src/RTOS/tasks.c **** 		}
 584:../src/RTOS/tasks.c **** 		else
 585:../src/RTOS/tasks.c **** 		{
 586:../src/RTOS/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 587:../src/RTOS/tasks.c **** 		}
 588:../src/RTOS/tasks.c **** 
 589:../src/RTOS/tasks.c **** 		return xReturn;
 590:../src/RTOS/tasks.c **** 	}
 591:../src/RTOS/tasks.c **** 
 592:../src/RTOS/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 593:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
 594:../src/RTOS/tasks.c **** 
 595:../src/RTOS/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 596:../src/RTOS/tasks.c **** 
 597:../src/RTOS/tasks.c **** 	BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usSta
 598:../src/RTOS/tasks.c **** 	{
 142              		.loc 1 598 0
 143              		.cfi_startproc
 144              		@ args = 8, pretend = 0, frame = 32
 145              		@ frame_needed = 1, uses_anonymous_args = 0
 146 0000 80B5     		push	{r7, lr}
 147              		.cfi_def_cfa_offset 8
 148              		.cfi_offset 7, -8
 149              		.cfi_offset 14, -4
 150 0002 8CB0     		sub	sp, sp, #48
 151              		.cfi_def_cfa_offset 56
 152 0004 04AF     		add	r7, sp, #16
 153              		.cfi_def_cfa 7, 40
 154 0006 F860     		str	r0, [r7, #12]
 155 0008 B960     		str	r1, [r7, #8]
 156 000a 3B60     		str	r3, [r7]
 157 000c 1346     		mov	r3, r2	@ movhi
 158 000e FB80     		strh	r3, [r7, #6]	@ movhi
 159              	.LBB18:
 599:../src/RTOS/tasks.c **** 	TCB_t *pxNewTCB;
 600:../src/RTOS/tasks.c **** 	BaseType_t xReturn;
 601:../src/RTOS/tasks.c **** 
 602:../src/RTOS/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 603:../src/RTOS/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 604:../src/RTOS/tasks.c **** 		the TCB then the stack. */
 605:../src/RTOS/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 606:../src/RTOS/tasks.c **** 		{
 607:../src/RTOS/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 608:../src/RTOS/tasks.c **** 			the implementation of the port malloc function and whether or not static
 609:../src/RTOS/tasks.c **** 			allocation is being used. */
 610:../src/RTOS/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 611:../src/RTOS/tasks.c **** 
 612:../src/RTOS/tasks.c **** 			if( pxNewTCB != NULL )
 613:../src/RTOS/tasks.c **** 			{
 614:../src/RTOS/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 615:../src/RTOS/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 616:../src/RTOS/tasks.c **** 				be deleted later if required. */
 617:../src/RTOS/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 618:../src/RTOS/tasks.c **** 
 619:../src/RTOS/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 620:../src/RTOS/tasks.c **** 				{
 621:../src/RTOS/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 622:../src/RTOS/tasks.c **** 					vPortFree( pxNewTCB );
 623:../src/RTOS/tasks.c **** 					pxNewTCB = NULL;
 624:../src/RTOS/tasks.c **** 				}
 625:../src/RTOS/tasks.c **** 			}
 626:../src/RTOS/tasks.c **** 		}
 627:../src/RTOS/tasks.c **** 		#else /* portSTACK_GROWTH */
 628:../src/RTOS/tasks.c **** 		{
 629:../src/RTOS/tasks.c **** 		StackType_t *pxStack;
 630:../src/RTOS/tasks.c **** 
 631:../src/RTOS/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 632:../src/RTOS/tasks.c **** 			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) 
 160              		.loc 1 632 0
 161 0010 FB88     		ldrh	r3, [r7, #6]
 162 0012 9B00     		lsls	r3, r3, #2
 163 0014 1846     		mov	r0, r3
 164 0016 FFF7FEFF 		bl	pvPortMalloc
 165 001a 7861     		str	r0, [r7, #20]
 633:../src/RTOS/tasks.c **** 
 634:../src/RTOS/tasks.c **** 			if( pxStack != NULL )
 166              		.loc 1 634 0
 167 001c 7B69     		ldr	r3, [r7, #20]
 168 001e 002B     		cmp	r3, #0
 169 0020 0ED0     		beq	.L2
 635:../src/RTOS/tasks.c **** 			{
 636:../src/RTOS/tasks.c **** 				/* Allocate space for the TCB. */
 637:../src/RTOS/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the cas
 170              		.loc 1 637 0
 171 0022 4C20     		movs	r0, #76
 172 0024 FFF7FEFF 		bl	pvPortMalloc
 173 0028 F861     		str	r0, [r7, #28]
 638:../src/RTOS/tasks.c **** 
 639:../src/RTOS/tasks.c **** 				if( pxNewTCB != NULL )
 174              		.loc 1 639 0
 175 002a FB69     		ldr	r3, [r7, #28]
 176 002c 002B     		cmp	r3, #0
 177 002e 03D0     		beq	.L3
 640:../src/RTOS/tasks.c **** 				{
 641:../src/RTOS/tasks.c **** 					/* Store the stack location in the TCB. */
 642:../src/RTOS/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 178              		.loc 1 642 0
 179 0030 FB69     		ldr	r3, [r7, #28]
 180 0032 7A69     		ldr	r2, [r7, #20]
 181 0034 1A63     		str	r2, [r3, #48]
 182 0036 05E0     		b	.L5
 183              	.L3:
 643:../src/RTOS/tasks.c **** 				}
 644:../src/RTOS/tasks.c **** 				else
 645:../src/RTOS/tasks.c **** 				{
 646:../src/RTOS/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 647:../src/RTOS/tasks.c **** 					it again. */
 648:../src/RTOS/tasks.c **** 					vPortFree( pxStack );
 184              		.loc 1 648 0
 185 0038 7869     		ldr	r0, [r7, #20]
 186 003a FFF7FEFF 		bl	vPortFree
 187 003e 01E0     		b	.L5
 188              	.L2:
 649:../src/RTOS/tasks.c **** 				}
 650:../src/RTOS/tasks.c **** 			}
 651:../src/RTOS/tasks.c **** 			else
 652:../src/RTOS/tasks.c **** 			{
 653:../src/RTOS/tasks.c **** 				pxNewTCB = NULL;
 189              		.loc 1 653 0
 190 0040 0023     		movs	r3, #0
 191 0042 FB61     		str	r3, [r7, #28]
 192              	.L5:
 193              	.LBE18:
 654:../src/RTOS/tasks.c **** 			}
 655:../src/RTOS/tasks.c **** 		}
 656:../src/RTOS/tasks.c **** 		#endif /* portSTACK_GROWTH */
 657:../src/RTOS/tasks.c **** 
 658:../src/RTOS/tasks.c **** 		if( pxNewTCB != NULL )
 194              		.loc 1 658 0
 195 0044 FB69     		ldr	r3, [r7, #28]
 196 0046 002B     		cmp	r3, #0
 197 0048 11D0     		beq	.L6
 659:../src/RTOS/tasks.c **** 		{
 660:../src/RTOS/tasks.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 661:../src/RTOS/tasks.c **** 			{
 662:../src/RTOS/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 663:../src/RTOS/tasks.c **** 				task was created dynamically in case it is later deleted. */
 664:../src/RTOS/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = pdFALSE;
 665:../src/RTOS/tasks.c **** 			}
 666:../src/RTOS/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 667:../src/RTOS/tasks.c **** 
 668:../src/RTOS/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask,
 198              		.loc 1 668 0
 199 004a FA88     		ldrh	r2, [r7, #6]
 200 004c BB6A     		ldr	r3, [r7, #40]
 201 004e 0093     		str	r3, [sp]
 202 0050 FB6A     		ldr	r3, [r7, #44]
 203 0052 0193     		str	r3, [sp, #4]
 204 0054 FB69     		ldr	r3, [r7, #28]
 205 0056 0293     		str	r3, [sp, #8]
 206 0058 F868     		ldr	r0, [r7, #12]
 207 005a B968     		ldr	r1, [r7, #8]
 208 005c 3B68     		ldr	r3, [r7]
 209 005e FFF7FEFF 		bl	prvInitialiseNewTask
 669:../src/RTOS/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 210              		.loc 1 669 0
 211 0062 F869     		ldr	r0, [r7, #28]
 212 0064 FFF7FEFF 		bl	prvAddNewTaskToReadyList
 670:../src/RTOS/tasks.c **** 			xReturn = pdPASS;
 213              		.loc 1 670 0
 214 0068 0123     		movs	r3, #1
 215 006a BB61     		str	r3, [r7, #24]
 216 006c 02E0     		b	.L7
 217              	.L6:
 671:../src/RTOS/tasks.c **** 		}
 672:../src/RTOS/tasks.c **** 		else
 673:../src/RTOS/tasks.c **** 		{
 674:../src/RTOS/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 218              		.loc 1 674 0
 219 006e 4FF0FF33 		mov	r3, #-1
 220 0072 BB61     		str	r3, [r7, #24]
 221              	.L7:
 675:../src/RTOS/tasks.c **** 		}
 676:../src/RTOS/tasks.c **** 
 677:../src/RTOS/tasks.c **** 		return xReturn;
 222              		.loc 1 677 0
 223 0074 BB69     		ldr	r3, [r7, #24]
 678:../src/RTOS/tasks.c **** 	}
 224              		.loc 1 678 0
 225 0076 1846     		mov	r0, r3
 226 0078 2037     		adds	r7, r7, #32
 227              		.cfi_def_cfa_offset 8
 228 007a BD46     		mov	sp, r7
 229              		.cfi_def_cfa_register 13
 230              		@ sp needed
 231 007c 80BD     		pop	{r7, pc}
 232              		.cfi_endproc
 233              	.LFE4:
 235 007e 00BF     		.section	.text.prvInitialiseNewTask,"ax",%progbits
 236              		.align	2
 237              		.thumb
 238              		.thumb_func
 240              	prvInitialiseNewTask:
 241              	.LFB5:
 679:../src/RTOS/tasks.c **** 
 680:../src/RTOS/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 681:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
 682:../src/RTOS/tasks.c **** 
 683:../src/RTOS/tasks.c **** static void prvInitialiseNewTask( TaskFunction_t pxTaskCode, const char * const pcName, const uint1
 684:../src/RTOS/tasks.c **** {
 242              		.loc 1 684 0
 243              		.cfi_startproc
 244              		@ args = 12, pretend = 0, frame = 24
 245              		@ frame_needed = 1, uses_anonymous_args = 0
 246 0000 80B5     		push	{r7, lr}
 247              		.cfi_def_cfa_offset 8
 248              		.cfi_offset 7, -8
 249              		.cfi_offset 14, -4
 250 0002 86B0     		sub	sp, sp, #24
 251              		.cfi_def_cfa_offset 32
 252 0004 00AF     		add	r7, sp, #0
 253              		.cfi_def_cfa_register 7
 254 0006 F860     		str	r0, [r7, #12]
 255 0008 B960     		str	r1, [r7, #8]
 256 000a 3B60     		str	r3, [r7]
 257 000c 1346     		mov	r3, r2	@ movhi
 258 000e FB80     		strh	r3, [r7, #6]	@ movhi
 685:../src/RTOS/tasks.c **** StackType_t *pxTopOfStack;
 686:../src/RTOS/tasks.c **** UBaseType_t x;
 687:../src/RTOS/tasks.c **** 
 688:../src/RTOS/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 689:../src/RTOS/tasks.c **** 		/* Should the task be created in privileged mode? */
 690:../src/RTOS/tasks.c **** 		BaseType_t xRunPrivileged;
 691:../src/RTOS/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 692:../src/RTOS/tasks.c **** 		{
 693:../src/RTOS/tasks.c **** 			xRunPrivileged = pdTRUE;
 694:../src/RTOS/tasks.c **** 		}
 695:../src/RTOS/tasks.c **** 		else
 696:../src/RTOS/tasks.c **** 		{
 697:../src/RTOS/tasks.c **** 			xRunPrivileged = pdFALSE;
 698:../src/RTOS/tasks.c **** 		}
 699:../src/RTOS/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 700:../src/RTOS/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 701:../src/RTOS/tasks.c **** 
 702:../src/RTOS/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 703:../src/RTOS/tasks.c **** 	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTa
 704:../src/RTOS/tasks.c **** 	{
 705:../src/RTOS/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 706:../src/RTOS/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof(
 707:../src/RTOS/tasks.c **** 	}
 708:../src/RTOS/tasks.c **** 	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INC
 709:../src/RTOS/tasks.c **** 
 710:../src/RTOS/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 711:../src/RTOS/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 712:../src/RTOS/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 713:../src/RTOS/tasks.c **** 	by the port. */
 714:../src/RTOS/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 715:../src/RTOS/tasks.c **** 	{
 716:../src/RTOS/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 259              		.loc 1 716 0
 260 0010 BB6A     		ldr	r3, [r7, #40]
 261 0012 1A6B     		ldr	r2, [r3, #48]
 262 0014 FB88     		ldrh	r3, [r7, #6]
 263 0016 03F18043 		add	r3, r3, #1073741824
 264 001a 013B     		subs	r3, r3, #1
 265 001c 9B00     		lsls	r3, r3, #2
 266 001e 1344     		add	r3, r3, r2
 267 0020 3B61     		str	r3, [r7, #16]
 717:../src/RTOS/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 268              		.loc 1 717 0
 269 0022 3B69     		ldr	r3, [r7, #16]
 270 0024 23F00703 		bic	r3, r3, #7
 271 0028 3B61     		str	r3, [r7, #16]
 718:../src/RTOS/tasks.c **** 
 719:../src/RTOS/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 720:../src/RTOS/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 272              		.loc 1 720 0
 273 002a 3B69     		ldr	r3, [r7, #16]
 274 002c 03F00703 		and	r3, r3, #7
 275 0030 002B     		cmp	r3, #0
 276 0032 00D0     		beq	.L10
 277              	.L11:
 278              		.loc 1 720 0 is_stmt 0 discriminator 1
 279 0034 FEE7     		b	.L11
 280              	.L10:
 721:../src/RTOS/tasks.c **** 	}
 722:../src/RTOS/tasks.c **** 	#else /* portSTACK_GROWTH */
 723:../src/RTOS/tasks.c **** 	{
 724:../src/RTOS/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 725:../src/RTOS/tasks.c **** 
 726:../src/RTOS/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 727:../src/RTOS/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 728:../src/RTOS/tasks.c **** 
 729:../src/RTOS/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 730:../src/RTOS/tasks.c **** 		performed. */
 731:../src/RTOS/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 732:../src/RTOS/tasks.c **** 	}
 733:../src/RTOS/tasks.c **** 	#endif /* portSTACK_GROWTH */
 734:../src/RTOS/tasks.c **** 
 735:../src/RTOS/tasks.c **** 	/* Store the task name in the TCB. */
 736:../src/RTOS/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 281              		.loc 1 736 0 is_stmt 1
 282 0036 0023     		movs	r3, #0
 283 0038 7B61     		str	r3, [r7, #20]
 284 003a 13E0     		b	.L12
 285              	.L15:
 737:../src/RTOS/tasks.c **** 	{
 738:../src/RTOS/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 286              		.loc 1 738 0
 287 003c BA68     		ldr	r2, [r7, #8]
 288 003e 7B69     		ldr	r3, [r7, #20]
 289 0040 1344     		add	r3, r3, r2
 290 0042 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 291 0044 BA6A     		ldr	r2, [r7, #40]
 292 0046 7B69     		ldr	r3, [r7, #20]
 293 0048 1344     		add	r3, r3, r2
 294 004a 3033     		adds	r3, r3, #48
 295 004c 0A46     		mov	r2, r1
 296 004e 1A71     		strb	r2, [r3, #4]
 739:../src/RTOS/tasks.c **** 
 740:../src/RTOS/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 741:../src/RTOS/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 742:../src/RTOS/tasks.c **** 		string is not accessible (extremely unlikely). */
 743:../src/RTOS/tasks.c **** 		if( pcName[ x ] == 0x00 )
 297              		.loc 1 743 0
 298 0050 BA68     		ldr	r2, [r7, #8]
 299 0052 7B69     		ldr	r3, [r7, #20]
 300 0054 1344     		add	r3, r3, r2
 301 0056 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 302 0058 002B     		cmp	r3, #0
 303 005a 00D1     		bne	.L13
 744:../src/RTOS/tasks.c **** 		{
 745:../src/RTOS/tasks.c **** 			break;
 304              		.loc 1 745 0
 305 005c 05E0     		b	.L14
 306              	.L13:
 736:../src/RTOS/tasks.c **** 	{
 307              		.loc 1 736 0 discriminator 2
 308 005e 7B69     		ldr	r3, [r7, #20]
 309 0060 0133     		adds	r3, r3, #1
 310 0062 7B61     		str	r3, [r7, #20]
 311              	.L12:
 736:../src/RTOS/tasks.c **** 	{
 312              		.loc 1 736 0 is_stmt 0 discriminator 1
 313 0064 7B69     		ldr	r3, [r7, #20]
 314 0066 042B     		cmp	r3, #4
 315 0068 E8D9     		bls	.L15
 316              	.L14:
 746:../src/RTOS/tasks.c **** 		}
 747:../src/RTOS/tasks.c **** 		else
 748:../src/RTOS/tasks.c **** 		{
 749:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 750:../src/RTOS/tasks.c **** 		}
 751:../src/RTOS/tasks.c **** 	}
 752:../src/RTOS/tasks.c **** 
 753:../src/RTOS/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 754:../src/RTOS/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
 755:../src/RTOS/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 317              		.loc 1 755 0 is_stmt 1
 318 006a BB6A     		ldr	r3, [r7, #40]
 319 006c 0022     		movs	r2, #0
 320 006e 83F83820 		strb	r2, [r3, #56]
 756:../src/RTOS/tasks.c **** 
 757:../src/RTOS/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 758:../src/RTOS/tasks.c **** 	remove the privilege bit if one is present. */
 759:../src/RTOS/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 321              		.loc 1 759 0
 322 0072 3B6A     		ldr	r3, [r7, #32]
 323 0074 092B     		cmp	r3, #9
 324 0076 01D9     		bls	.L16
 760:../src/RTOS/tasks.c **** 	{
 761:../src/RTOS/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 325              		.loc 1 761 0
 326 0078 0923     		movs	r3, #9
 327 007a 3B62     		str	r3, [r7, #32]
 328              	.L16:
 762:../src/RTOS/tasks.c **** 	}
 763:../src/RTOS/tasks.c **** 	else
 764:../src/RTOS/tasks.c **** 	{
 765:../src/RTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 766:../src/RTOS/tasks.c **** 	}
 767:../src/RTOS/tasks.c **** 
 768:../src/RTOS/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 329              		.loc 1 768 0
 330 007c BB6A     		ldr	r3, [r7, #40]
 331 007e 3A6A     		ldr	r2, [r7, #32]
 332 0080 DA62     		str	r2, [r3, #44]
 769:../src/RTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 770:../src/RTOS/tasks.c **** 	{
 771:../src/RTOS/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 333              		.loc 1 771 0
 334 0082 BB6A     		ldr	r3, [r7, #40]
 335 0084 3A6A     		ldr	r2, [r7, #32]
 336 0086 DA63     		str	r2, [r3, #60]
 772:../src/RTOS/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 337              		.loc 1 772 0
 338 0088 BB6A     		ldr	r3, [r7, #40]
 339 008a 0022     		movs	r2, #0
 340 008c 1A64     		str	r2, [r3, #64]
 773:../src/RTOS/tasks.c **** 	}
 774:../src/RTOS/tasks.c **** 	#endif /* configUSE_MUTEXES */
 775:../src/RTOS/tasks.c **** 
 776:../src/RTOS/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 341              		.loc 1 776 0
 342 008e BB6A     		ldr	r3, [r7, #40]
 343 0090 0433     		adds	r3, r3, #4
 344 0092 1846     		mov	r0, r3
 345 0094 FFF7FEFF 		bl	vListInitialiseItem
 777:../src/RTOS/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 346              		.loc 1 777 0
 347 0098 BB6A     		ldr	r3, [r7, #40]
 348 009a 1833     		adds	r3, r3, #24
 349 009c 1846     		mov	r0, r3
 350 009e FFF7FEFF 		bl	vListInitialiseItem
 778:../src/RTOS/tasks.c **** 
 779:../src/RTOS/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 780:../src/RTOS/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 781:../src/RTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 351              		.loc 1 781 0
 352 00a2 BB6A     		ldr	r3, [r7, #40]
 353 00a4 BA6A     		ldr	r2, [r7, #40]
 354 00a6 1A61     		str	r2, [r3, #16]
 782:../src/RTOS/tasks.c **** 
 783:../src/RTOS/tasks.c **** 	/* Event lists are always in priority order. */
 784:../src/RTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 355              		.loc 1 784 0
 356 00a8 3B6A     		ldr	r3, [r7, #32]
 357 00aa C3F10A02 		rsb	r2, r3, #10
 358 00ae BB6A     		ldr	r3, [r7, #40]
 359 00b0 9A61     		str	r2, [r3, #24]
 785:../src/RTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 360              		.loc 1 785 0
 361 00b2 BB6A     		ldr	r3, [r7, #40]
 362 00b4 BA6A     		ldr	r2, [r7, #40]
 363 00b6 5A62     		str	r2, [r3, #36]
 786:../src/RTOS/tasks.c **** 
 787:../src/RTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 788:../src/RTOS/tasks.c **** 	{
 789:../src/RTOS/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 790:../src/RTOS/tasks.c **** 	}
 791:../src/RTOS/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 792:../src/RTOS/tasks.c **** 
 793:../src/RTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 794:../src/RTOS/tasks.c **** 	{
 795:../src/RTOS/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 796:../src/RTOS/tasks.c **** 	}
 797:../src/RTOS/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 798:../src/RTOS/tasks.c **** 
 799:../src/RTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 800:../src/RTOS/tasks.c **** 	{
 801:../src/RTOS/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 802:../src/RTOS/tasks.c **** 	}
 803:../src/RTOS/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 804:../src/RTOS/tasks.c **** 
 805:../src/RTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 806:../src/RTOS/tasks.c **** 	{
 807:../src/RTOS/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, usStackDepth
 808:../src/RTOS/tasks.c **** 	}
 809:../src/RTOS/tasks.c **** 	#endif
 810:../src/RTOS/tasks.c **** 
 811:../src/RTOS/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 812:../src/RTOS/tasks.c **** 	{
 813:../src/RTOS/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 814:../src/RTOS/tasks.c **** 		{
 815:../src/RTOS/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 816:../src/RTOS/tasks.c **** 		}
 817:../src/RTOS/tasks.c **** 	}
 818:../src/RTOS/tasks.c **** 	#endif
 819:../src/RTOS/tasks.c **** 
 820:../src/RTOS/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 821:../src/RTOS/tasks.c **** 	{
 822:../src/RTOS/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
 364              		.loc 1 822 0
 365 00b8 BB6A     		ldr	r3, [r7, #40]
 366 00ba 0022     		movs	r2, #0
 367 00bc 5A64     		str	r2, [r3, #68]
 823:../src/RTOS/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 368              		.loc 1 823 0
 369 00be BB6A     		ldr	r3, [r7, #40]
 370 00c0 0022     		movs	r2, #0
 371 00c2 83F84820 		strb	r2, [r3, #72]
 824:../src/RTOS/tasks.c **** 	}
 825:../src/RTOS/tasks.c **** 	#endif
 826:../src/RTOS/tasks.c **** 
 827:../src/RTOS/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 828:../src/RTOS/tasks.c **** 	{
 829:../src/RTOS/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
 830:../src/RTOS/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 831:../src/RTOS/tasks.c **** 	}
 832:../src/RTOS/tasks.c **** 	#endif
 833:../src/RTOS/tasks.c **** 
 834:../src/RTOS/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 835:../src/RTOS/tasks.c **** 	{
 836:../src/RTOS/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
 837:../src/RTOS/tasks.c **** 	}
 838:../src/RTOS/tasks.c **** 	#endif
 839:../src/RTOS/tasks.c **** 
 840:../src/RTOS/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
 841:../src/RTOS/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
 842:../src/RTOS/tasks.c **** 	to the start of the task function. Once the stack has been initialised
 843:../src/RTOS/tasks.c **** 	the	top of stack variable is updated. */
 844:../src/RTOS/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 845:../src/RTOS/tasks.c **** 	{
 846:../src/RTOS/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
 847:../src/RTOS/tasks.c **** 	}
 848:../src/RTOS/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
 849:../src/RTOS/tasks.c **** 	{
 850:../src/RTOS/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 372              		.loc 1 850 0
 373 00c6 3869     		ldr	r0, [r7, #16]
 374 00c8 F968     		ldr	r1, [r7, #12]
 375 00ca 3A68     		ldr	r2, [r7]
 376 00cc FFF7FEFF 		bl	pxPortInitialiseStack
 377 00d0 0246     		mov	r2, r0
 378 00d2 BB6A     		ldr	r3, [r7, #40]
 379 00d4 1A60     		str	r2, [r3]
 851:../src/RTOS/tasks.c **** 	}
 852:../src/RTOS/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
 853:../src/RTOS/tasks.c **** 
 854:../src/RTOS/tasks.c **** 	if( ( void * ) pxCreatedTask != NULL )
 380              		.loc 1 854 0
 381 00d6 7B6A     		ldr	r3, [r7, #36]
 382 00d8 002B     		cmp	r3, #0
 383 00da 02D0     		beq	.L9
 855:../src/RTOS/tasks.c **** 	{
 856:../src/RTOS/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
 857:../src/RTOS/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
 858:../src/RTOS/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 384              		.loc 1 858 0
 385 00dc 7B6A     		ldr	r3, [r7, #36]
 386 00de BA6A     		ldr	r2, [r7, #40]
 387 00e0 1A60     		str	r2, [r3]
 388              	.L9:
 859:../src/RTOS/tasks.c **** 	}
 860:../src/RTOS/tasks.c **** 	else
 861:../src/RTOS/tasks.c **** 	{
 862:../src/RTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 863:../src/RTOS/tasks.c **** 	}
 864:../src/RTOS/tasks.c **** }
 389              		.loc 1 864 0
 390 00e2 1837     		adds	r7, r7, #24
 391              		.cfi_def_cfa_offset 8
 392 00e4 BD46     		mov	sp, r7
 393              		.cfi_def_cfa_register 13
 394              		@ sp needed
 395 00e6 80BD     		pop	{r7, pc}
 396              		.cfi_endproc
 397              	.LFE5:
 399              		.section	.text.prvAddNewTaskToReadyList,"ax",%progbits
 400              		.align	2
 401              		.thumb
 402              		.thumb_func
 404              	prvAddNewTaskToReadyList:
 405              	.LFB6:
 865:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
 866:../src/RTOS/tasks.c **** 
 867:../src/RTOS/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
 868:../src/RTOS/tasks.c **** {
 406              		.loc 1 868 0
 407              		.cfi_startproc
 408              		@ args = 0, pretend = 0, frame = 8
 409              		@ frame_needed = 1, uses_anonymous_args = 0
 410 0000 80B5     		push	{r7, lr}
 411              		.cfi_def_cfa_offset 8
 412              		.cfi_offset 7, -8
 413              		.cfi_offset 14, -4
 414 0002 82B0     		sub	sp, sp, #8
 415              		.cfi_def_cfa_offset 16
 416 0004 00AF     		add	r7, sp, #0
 417              		.cfi_def_cfa_register 7
 418 0006 7860     		str	r0, [r7, #4]
 869:../src/RTOS/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
 870:../src/RTOS/tasks.c **** 	updated. */
 871:../src/RTOS/tasks.c **** 	taskENTER_CRITICAL();
 419              		.loc 1 871 0
 420 0008 FFF7FEFF 		bl	vPortEnterCritical
 872:../src/RTOS/tasks.c **** 	{
 873:../src/RTOS/tasks.c **** 		uxCurrentNumberOfTasks++;
 421              		.loc 1 873 0
 422 000c 2A4B     		ldr	r3, .L23
 423 000e 1B68     		ldr	r3, [r3]
 424 0010 0133     		adds	r3, r3, #1
 425 0012 294A     		ldr	r2, .L23
 426 0014 1360     		str	r3, [r2]
 874:../src/RTOS/tasks.c **** 		if( pxCurrentTCB == NULL )
 427              		.loc 1 874 0
 428 0016 294B     		ldr	r3, .L23+4
 429 0018 1B68     		ldr	r3, [r3]
 430 001a 002B     		cmp	r3, #0
 431 001c 09D1     		bne	.L19
 875:../src/RTOS/tasks.c **** 		{
 876:../src/RTOS/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
 877:../src/RTOS/tasks.c **** 			the suspended state - make this the current task. */
 878:../src/RTOS/tasks.c **** 			pxCurrentTCB = pxNewTCB;
 432              		.loc 1 878 0
 433 001e 274A     		ldr	r2, .L23+4
 434 0020 7B68     		ldr	r3, [r7, #4]
 435 0022 1360     		str	r3, [r2]
 879:../src/RTOS/tasks.c **** 
 880:../src/RTOS/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 436              		.loc 1 880 0
 437 0024 244B     		ldr	r3, .L23
 438 0026 1B68     		ldr	r3, [r3]
 439 0028 012B     		cmp	r3, #1
 440 002a 10D1     		bne	.L20
 881:../src/RTOS/tasks.c **** 			{
 882:../src/RTOS/tasks.c **** 				/* This is the first task to be created so do the preliminary
 883:../src/RTOS/tasks.c **** 				initialisation required.  We will not recover if this call
 884:../src/RTOS/tasks.c **** 				fails, but we will report the failure. */
 885:../src/RTOS/tasks.c **** 				prvInitialiseTaskLists();
 441              		.loc 1 885 0
 442 002c FFF7FEFF 		bl	prvInitialiseTaskLists
 443 0030 0DE0     		b	.L20
 444              	.L19:
 886:../src/RTOS/tasks.c **** 			}
 887:../src/RTOS/tasks.c **** 			else
 888:../src/RTOS/tasks.c **** 			{
 889:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 890:../src/RTOS/tasks.c **** 			}
 891:../src/RTOS/tasks.c **** 		}
 892:../src/RTOS/tasks.c **** 		else
 893:../src/RTOS/tasks.c **** 		{
 894:../src/RTOS/tasks.c **** 			/* If the scheduler is not already running, make this task the
 895:../src/RTOS/tasks.c **** 			current task if it is the highest priority task to be created
 896:../src/RTOS/tasks.c **** 			so far. */
 897:../src/RTOS/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
 445              		.loc 1 897 0
 446 0032 234B     		ldr	r3, .L23+8
 447 0034 1B68     		ldr	r3, [r3]
 448 0036 002B     		cmp	r3, #0
 449 0038 09D1     		bne	.L20
 898:../src/RTOS/tasks.c **** 			{
 899:../src/RTOS/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 450              		.loc 1 899 0
 451 003a 204B     		ldr	r3, .L23+4
 452 003c 1B68     		ldr	r3, [r3]
 453 003e DA6A     		ldr	r2, [r3, #44]
 454 0040 7B68     		ldr	r3, [r7, #4]
 455 0042 DB6A     		ldr	r3, [r3, #44]
 456 0044 9A42     		cmp	r2, r3
 457 0046 02D8     		bhi	.L20
 900:../src/RTOS/tasks.c **** 				{
 901:../src/RTOS/tasks.c **** 					pxCurrentTCB = pxNewTCB;
 458              		.loc 1 901 0
 459 0048 1C4A     		ldr	r2, .L23+4
 460 004a 7B68     		ldr	r3, [r7, #4]
 461 004c 1360     		str	r3, [r2]
 462              	.L20:
 902:../src/RTOS/tasks.c **** 				}
 903:../src/RTOS/tasks.c **** 				else
 904:../src/RTOS/tasks.c **** 				{
 905:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 906:../src/RTOS/tasks.c **** 				}
 907:../src/RTOS/tasks.c **** 			}
 908:../src/RTOS/tasks.c **** 			else
 909:../src/RTOS/tasks.c **** 			{
 910:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 911:../src/RTOS/tasks.c **** 			}
 912:../src/RTOS/tasks.c **** 		}
 913:../src/RTOS/tasks.c **** 
 914:../src/RTOS/tasks.c **** 		uxTaskNumber++;
 463              		.loc 1 914 0
 464 004e 1D4B     		ldr	r3, .L23+12
 465 0050 1B68     		ldr	r3, [r3]
 466 0052 0133     		adds	r3, r3, #1
 467 0054 1B4A     		ldr	r2, .L23+12
 468 0056 1360     		str	r3, [r2]
 915:../src/RTOS/tasks.c **** 
 916:../src/RTOS/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
 917:../src/RTOS/tasks.c **** 		{
 918:../src/RTOS/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
 919:../src/RTOS/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
 920:../src/RTOS/tasks.c **** 		}
 921:../src/RTOS/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
 922:../src/RTOS/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
 923:../src/RTOS/tasks.c **** 
 924:../src/RTOS/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
 469              		.loc 1 924 0
 470 0058 7B68     		ldr	r3, [r7, #4]
 471 005a DA6A     		ldr	r2, [r3, #44]
 472 005c 1A4B     		ldr	r3, .L23+16
 473 005e 1B68     		ldr	r3, [r3]
 474 0060 9A42     		cmp	r2, r3
 475 0062 03D9     		bls	.L21
 476              		.loc 1 924 0 is_stmt 0 discriminator 1
 477 0064 7B68     		ldr	r3, [r7, #4]
 478 0066 DB6A     		ldr	r3, [r3, #44]
 479 0068 174A     		ldr	r2, .L23+16
 480 006a 1360     		str	r3, [r2]
 481              	.L21:
 482              		.loc 1 924 0 discriminator 3
 483 006c 7B68     		ldr	r3, [r7, #4]
 484 006e DA6A     		ldr	r2, [r3, #44]
 485 0070 1346     		mov	r3, r2
 486 0072 9B00     		lsls	r3, r3, #2
 487 0074 1344     		add	r3, r3, r2
 488 0076 9B00     		lsls	r3, r3, #2
 489 0078 144A     		ldr	r2, .L23+20
 490 007a 1A44     		add	r2, r2, r3
 491 007c 7B68     		ldr	r3, [r7, #4]
 492 007e 0433     		adds	r3, r3, #4
 493 0080 1046     		mov	r0, r2
 494 0082 1946     		mov	r1, r3
 495 0084 FFF7FEFF 		bl	vListInsertEnd
 925:../src/RTOS/tasks.c **** 
 926:../src/RTOS/tasks.c **** 		portSETUP_TCB( pxNewTCB );
 927:../src/RTOS/tasks.c **** 	}
 928:../src/RTOS/tasks.c **** 	taskEXIT_CRITICAL();
 496              		.loc 1 928 0 is_stmt 1 discriminator 3
 497 0088 FFF7FEFF 		bl	vPortExitCritical
 929:../src/RTOS/tasks.c **** 
 930:../src/RTOS/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
 498              		.loc 1 930 0 discriminator 3
 499 008c 0C4B     		ldr	r3, .L23+8
 500 008e 1B68     		ldr	r3, [r3]
 501 0090 002B     		cmp	r3, #0
 502 0092 0ED0     		beq	.L18
 931:../src/RTOS/tasks.c **** 	{
 932:../src/RTOS/tasks.c **** 		/* If the created task is of a higher priority than the current task
 933:../src/RTOS/tasks.c **** 		then it should run now. */
 934:../src/RTOS/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 503              		.loc 1 934 0
 504 0094 094B     		ldr	r3, .L23+4
 505 0096 1B68     		ldr	r3, [r3]
 506 0098 DA6A     		ldr	r2, [r3, #44]
 507 009a 7B68     		ldr	r3, [r7, #4]
 508 009c DB6A     		ldr	r3, [r3, #44]
 509 009e 9A42     		cmp	r2, r3
 510 00a0 07D2     		bcs	.L18
 935:../src/RTOS/tasks.c **** 		{
 936:../src/RTOS/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
 511              		.loc 1 936 0
 512 00a2 0B4B     		ldr	r3, .L23+24
 513 00a4 4FF08052 		mov	r2, #268435456
 514 00a8 1A60     		str	r2, [r3]
 515              	@ 936 "../src/RTOS/tasks.c" 1
 516 00aa BFF34F8F 		dsb
 517              	@ 0 "" 2
 518              	@ 936 "../src/RTOS/tasks.c" 1
 519 00ae BFF36F8F 		isb
 520              	@ 0 "" 2
 521              		.thumb
 522              	.L18:
 937:../src/RTOS/tasks.c **** 		}
 938:../src/RTOS/tasks.c **** 		else
 939:../src/RTOS/tasks.c **** 		{
 940:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 941:../src/RTOS/tasks.c **** 		}
 942:../src/RTOS/tasks.c **** 	}
 943:../src/RTOS/tasks.c **** 	else
 944:../src/RTOS/tasks.c **** 	{
 945:../src/RTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 946:../src/RTOS/tasks.c **** 	}
 947:../src/RTOS/tasks.c **** }
 523              		.loc 1 947 0
 524 00b2 0837     		adds	r7, r7, #8
 525              		.cfi_def_cfa_offset 8
 526 00b4 BD46     		mov	sp, r7
 527              		.cfi_def_cfa_register 13
 528              		@ sp needed
 529 00b6 80BD     		pop	{r7, pc}
 530              	.L24:
 531              		.align	2
 532              	.L23:
 533 00b8 00000000 		.word	uxCurrentNumberOfTasks
 534 00bc 00000000 		.word	pxCurrentTCB
 535 00c0 00000000 		.word	xSchedulerRunning
 536 00c4 00000000 		.word	uxTaskNumber
 537 00c8 00000000 		.word	uxTopReadyPriority
 538 00cc 00000000 		.word	pxReadyTasksLists
 539 00d0 04ED00E0 		.word	-536810236
 540              		.cfi_endproc
 541              	.LFE6:
 543              		.section	.text.vTaskDelayUntil,"ax",%progbits
 544              		.align	2
 545              		.global	vTaskDelayUntil
 546              		.thumb
 547              		.thumb_func
 549              	vTaskDelayUntil:
 550              	.LFB7:
 948:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
 949:../src/RTOS/tasks.c **** 
 950:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 951:../src/RTOS/tasks.c **** 
 952:../src/RTOS/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
 953:../src/RTOS/tasks.c **** 	{
 954:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
 955:../src/RTOS/tasks.c **** 
 956:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
 957:../src/RTOS/tasks.c **** 		{
 958:../src/RTOS/tasks.c **** 			/* If null is passed in here then it is the calling task that is
 959:../src/RTOS/tasks.c **** 			being deleted. */
 960:../src/RTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 961:../src/RTOS/tasks.c **** 
 962:../src/RTOS/tasks.c **** 			/* Remove task from the ready list. */
 963:../src/RTOS/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 964:../src/RTOS/tasks.c **** 			{
 965:../src/RTOS/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 966:../src/RTOS/tasks.c **** 			}
 967:../src/RTOS/tasks.c **** 			else
 968:../src/RTOS/tasks.c **** 			{
 969:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 970:../src/RTOS/tasks.c **** 			}
 971:../src/RTOS/tasks.c **** 
 972:../src/RTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 973:../src/RTOS/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 974:../src/RTOS/tasks.c **** 			{
 975:../src/RTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 976:../src/RTOS/tasks.c **** 			}
 977:../src/RTOS/tasks.c **** 			else
 978:../src/RTOS/tasks.c **** 			{
 979:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 980:../src/RTOS/tasks.c **** 			}
 981:../src/RTOS/tasks.c **** 
 982:../src/RTOS/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 983:../src/RTOS/tasks.c **** 			{
 984:../src/RTOS/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
 985:../src/RTOS/tasks.c **** 				task itself, as a context switch to another task is required.
 986:../src/RTOS/tasks.c **** 				Place the task in the termination list.  The idle task will
 987:../src/RTOS/tasks.c **** 				check the termination list and free up any memory allocated by
 988:../src/RTOS/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
 989:../src/RTOS/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 990:../src/RTOS/tasks.c **** 
 991:../src/RTOS/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
 992:../src/RTOS/tasks.c **** 				there is a task that has been deleted and that it should therefore
 993:../src/RTOS/tasks.c **** 				check the xTasksWaitingTermination list. */
 994:../src/RTOS/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
 995:../src/RTOS/tasks.c **** 			}
 996:../src/RTOS/tasks.c **** 			else
 997:../src/RTOS/tasks.c **** 			{
 998:../src/RTOS/tasks.c **** 				--uxCurrentNumberOfTasks;
 999:../src/RTOS/tasks.c **** 				prvDeleteTCB( pxTCB );
1000:../src/RTOS/tasks.c **** 			}
1001:../src/RTOS/tasks.c **** 
1002:../src/RTOS/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1003:../src/RTOS/tasks.c **** 			detect that the task lists need re-generating. */
1004:../src/RTOS/tasks.c **** 			uxTaskNumber++;
1005:../src/RTOS/tasks.c **** 
1006:../src/RTOS/tasks.c **** 			traceTASK_DELETE( pxTCB );
1007:../src/RTOS/tasks.c **** 		}
1008:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
1009:../src/RTOS/tasks.c **** 
1010:../src/RTOS/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1011:../src/RTOS/tasks.c **** 		been deleted. */
1012:../src/RTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1013:../src/RTOS/tasks.c **** 		{
1014:../src/RTOS/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1015:../src/RTOS/tasks.c **** 			{
1016:../src/RTOS/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1017:../src/RTOS/tasks.c **** 
1018:../src/RTOS/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1019:../src/RTOS/tasks.c **** 				in which Windows specific clean up operations are performed,
1020:../src/RTOS/tasks.c **** 				after which it is not possible to yield away from this task -
1021:../src/RTOS/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1022:../src/RTOS/tasks.c **** 				required. */
1023:../src/RTOS/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1024:../src/RTOS/tasks.c **** 				portYIELD_WITHIN_API();
1025:../src/RTOS/tasks.c **** 			}
1026:../src/RTOS/tasks.c **** 			else
1027:../src/RTOS/tasks.c **** 			{
1028:../src/RTOS/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1029:../src/RTOS/tasks.c **** 				the task that has just been deleted. */
1030:../src/RTOS/tasks.c **** 				taskENTER_CRITICAL();
1031:../src/RTOS/tasks.c **** 				{
1032:../src/RTOS/tasks.c **** 					prvResetNextTaskUnblockTime();
1033:../src/RTOS/tasks.c **** 				}
1034:../src/RTOS/tasks.c **** 				taskEXIT_CRITICAL();
1035:../src/RTOS/tasks.c **** 			}
1036:../src/RTOS/tasks.c **** 		}
1037:../src/RTOS/tasks.c **** 	}
1038:../src/RTOS/tasks.c **** 
1039:../src/RTOS/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1040:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1041:../src/RTOS/tasks.c **** 
1042:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1043:../src/RTOS/tasks.c **** 
1044:../src/RTOS/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1045:../src/RTOS/tasks.c **** 	{
 551              		.loc 1 1045 0
 552              		.cfi_startproc
 553              		@ args = 0, pretend = 0, frame = 24
 554              		@ frame_needed = 1, uses_anonymous_args = 0
 555 0000 80B5     		push	{r7, lr}
 556              		.cfi_def_cfa_offset 8
 557              		.cfi_offset 7, -8
 558              		.cfi_offset 14, -4
 559 0002 86B0     		sub	sp, sp, #24
 560              		.cfi_def_cfa_offset 32
 561 0004 00AF     		add	r7, sp, #0
 562              		.cfi_def_cfa_register 7
 563 0006 7860     		str	r0, [r7, #4]
 564 0008 3960     		str	r1, [r7]
1046:../src/RTOS/tasks.c **** 	TickType_t xTimeToWake;
1047:../src/RTOS/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 565              		.loc 1 1047 0
 566 000a 0023     		movs	r3, #0
 567 000c 7B61     		str	r3, [r7, #20]
1048:../src/RTOS/tasks.c **** 
1049:../src/RTOS/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 568              		.loc 1 1049 0
 569 000e 7B68     		ldr	r3, [r7, #4]
 570 0010 002B     		cmp	r3, #0
 571 0012 00D1     		bne	.L26
 572              	.L27:
 573              		.loc 1 1049 0 is_stmt 0 discriminator 1
 574 0014 FEE7     		b	.L27
 575              	.L26:
1050:../src/RTOS/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 576              		.loc 1 1050 0 is_stmt 1
 577 0016 3B68     		ldr	r3, [r7]
 578 0018 002B     		cmp	r3, #0
 579 001a 00D1     		bne	.L28
 580              	.L29:
 581              		.loc 1 1050 0 is_stmt 0 discriminator 2
 582 001c FEE7     		b	.L29
 583              	.L28:
1051:../src/RTOS/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 584              		.loc 1 1051 0 is_stmt 1
 585 001e 244B     		ldr	r3, .L37
 586 0020 1B68     		ldr	r3, [r3]
 587 0022 002B     		cmp	r3, #0
 588 0024 00D0     		beq	.L30
 589              	.L31:
 590              		.loc 1 1051 0 is_stmt 0 discriminator 3
 591 0026 FEE7     		b	.L31
 592              	.L30:
1052:../src/RTOS/tasks.c **** 
1053:../src/RTOS/tasks.c **** 		vTaskSuspendAll();
 593              		.loc 1 1053 0 is_stmt 1
 594 0028 FFF7FEFF 		bl	vTaskSuspendAll
 595              	.LBB19:
1054:../src/RTOS/tasks.c **** 		{
1055:../src/RTOS/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1056:../src/RTOS/tasks.c **** 			block. */
1057:../src/RTOS/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 596              		.loc 1 1057 0
 597 002c 214B     		ldr	r3, .L37+4
 598 002e 1B68     		ldr	r3, [r3]
 599 0030 3B61     		str	r3, [r7, #16]
1058:../src/RTOS/tasks.c **** 
1059:../src/RTOS/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1060:../src/RTOS/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 600              		.loc 1 1060 0
 601 0032 7B68     		ldr	r3, [r7, #4]
 602 0034 1A68     		ldr	r2, [r3]
 603 0036 3B68     		ldr	r3, [r7]
 604 0038 1344     		add	r3, r3, r2
 605 003a FB60     		str	r3, [r7, #12]
1061:../src/RTOS/tasks.c **** 
1062:../src/RTOS/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 606              		.loc 1 1062 0
 607 003c 7B68     		ldr	r3, [r7, #4]
 608 003e 1A68     		ldr	r2, [r3]
 609 0040 3B69     		ldr	r3, [r7, #16]
 610 0042 9A42     		cmp	r2, r3
 611 0044 0BD9     		bls	.L32
1063:../src/RTOS/tasks.c **** 			{
1064:../src/RTOS/tasks.c **** 				/* The tick count has overflowed since this function was
1065:../src/RTOS/tasks.c **** 				lasted called.  In this case the only time we should ever
1066:../src/RTOS/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1067:../src/RTOS/tasks.c **** 				and the wake time is greater than the tick time.  When this
1068:../src/RTOS/tasks.c **** 				is the case it is as if neither time had overflowed. */
1069:../src/RTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 612              		.loc 1 1069 0
 613 0046 7B68     		ldr	r3, [r7, #4]
 614 0048 1A68     		ldr	r2, [r3]
 615 004a FB68     		ldr	r3, [r7, #12]
 616 004c 9A42     		cmp	r2, r3
 617 004e 11D9     		bls	.L33
 618              		.loc 1 1069 0 is_stmt 0 discriminator 1
 619 0050 FA68     		ldr	r2, [r7, #12]
 620 0052 3B69     		ldr	r3, [r7, #16]
 621 0054 9A42     		cmp	r2, r3
 622 0056 0DD9     		bls	.L33
1070:../src/RTOS/tasks.c **** 				{
1071:../src/RTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 623              		.loc 1 1071 0 is_stmt 1
 624 0058 0123     		movs	r3, #1
 625 005a 7B61     		str	r3, [r7, #20]
 626 005c 0AE0     		b	.L33
 627              	.L32:
1072:../src/RTOS/tasks.c **** 				}
1073:../src/RTOS/tasks.c **** 				else
1074:../src/RTOS/tasks.c **** 				{
1075:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1076:../src/RTOS/tasks.c **** 				}
1077:../src/RTOS/tasks.c **** 			}
1078:../src/RTOS/tasks.c **** 			else
1079:../src/RTOS/tasks.c **** 			{
1080:../src/RTOS/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1081:../src/RTOS/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1082:../src/RTOS/tasks.c **** 				tick time is less than the wake time. */
1083:../src/RTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 628              		.loc 1 1083 0
 629 005e 7B68     		ldr	r3, [r7, #4]
 630 0060 1A68     		ldr	r2, [r3]
 631 0062 FB68     		ldr	r3, [r7, #12]
 632 0064 9A42     		cmp	r2, r3
 633 0066 03D8     		bhi	.L34
 634              		.loc 1 1083 0 is_stmt 0 discriminator 1
 635 0068 FA68     		ldr	r2, [r7, #12]
 636 006a 3B69     		ldr	r3, [r7, #16]
 637 006c 9A42     		cmp	r2, r3
 638 006e 01D9     		bls	.L33
 639              	.L34:
1084:../src/RTOS/tasks.c **** 				{
1085:../src/RTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 640              		.loc 1 1085 0 is_stmt 1
 641 0070 0123     		movs	r3, #1
 642 0072 7B61     		str	r3, [r7, #20]
 643              	.L33:
1086:../src/RTOS/tasks.c **** 				}
1087:../src/RTOS/tasks.c **** 				else
1088:../src/RTOS/tasks.c **** 				{
1089:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1090:../src/RTOS/tasks.c **** 				}
1091:../src/RTOS/tasks.c **** 			}
1092:../src/RTOS/tasks.c **** 
1093:../src/RTOS/tasks.c **** 			/* Update the wake time ready for the next call. */
1094:../src/RTOS/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 644              		.loc 1 1094 0
 645 0074 7B68     		ldr	r3, [r7, #4]
 646 0076 FA68     		ldr	r2, [r7, #12]
 647 0078 1A60     		str	r2, [r3]
1095:../src/RTOS/tasks.c **** 
1096:../src/RTOS/tasks.c **** 			if( xShouldDelay != pdFALSE )
 648              		.loc 1 1096 0
 649 007a 7B69     		ldr	r3, [r7, #20]
 650 007c 002B     		cmp	r3, #0
 651 007e 06D0     		beq	.L35
1097:../src/RTOS/tasks.c **** 			{
1098:../src/RTOS/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1099:../src/RTOS/tasks.c **** 
1100:../src/RTOS/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1101:../src/RTOS/tasks.c **** 				the time to wake, so subtract the current tick count. */
1102:../src/RTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 652              		.loc 1 1102 0
 653 0080 FA68     		ldr	r2, [r7, #12]
 654 0082 3B69     		ldr	r3, [r7, #16]
 655 0084 D31A     		subs	r3, r2, r3
 656 0086 1846     		mov	r0, r3
 657 0088 0021     		movs	r1, #0
 658 008a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 659              	.L35:
 660              	.LBE19:
1103:../src/RTOS/tasks.c **** 			}
1104:../src/RTOS/tasks.c **** 			else
1105:../src/RTOS/tasks.c **** 			{
1106:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1107:../src/RTOS/tasks.c **** 			}
1108:../src/RTOS/tasks.c **** 		}
1109:../src/RTOS/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 661              		.loc 1 1109 0
 662 008e FFF7FEFF 		bl	xTaskResumeAll
 663 0092 B860     		str	r0, [r7, #8]
1110:../src/RTOS/tasks.c **** 
1111:../src/RTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1112:../src/RTOS/tasks.c **** 		have put ourselves to sleep. */
1113:../src/RTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 664              		.loc 1 1113 0
 665 0094 BB68     		ldr	r3, [r7, #8]
 666 0096 002B     		cmp	r3, #0
 667 0098 07D1     		bne	.L25
1114:../src/RTOS/tasks.c **** 		{
1115:../src/RTOS/tasks.c **** 			portYIELD_WITHIN_API();
 668              		.loc 1 1115 0
 669 009a 074B     		ldr	r3, .L37+8
 670 009c 4FF08052 		mov	r2, #268435456
 671 00a0 1A60     		str	r2, [r3]
 672              	@ 1115 "../src/RTOS/tasks.c" 1
 673 00a2 BFF34F8F 		dsb
 674              	@ 0 "" 2
 675              	@ 1115 "../src/RTOS/tasks.c" 1
 676 00a6 BFF36F8F 		isb
 677              	@ 0 "" 2
 678              		.thumb
 679              	.L25:
1116:../src/RTOS/tasks.c **** 		}
1117:../src/RTOS/tasks.c **** 		else
1118:../src/RTOS/tasks.c **** 		{
1119:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1120:../src/RTOS/tasks.c **** 		}
1121:../src/RTOS/tasks.c **** 	}
 680              		.loc 1 1121 0
 681 00aa 1837     		adds	r7, r7, #24
 682              		.cfi_def_cfa_offset 8
 683 00ac BD46     		mov	sp, r7
 684              		.cfi_def_cfa_register 13
 685              		@ sp needed
 686 00ae 80BD     		pop	{r7, pc}
 687              	.L38:
 688              		.align	2
 689              	.L37:
 690 00b0 00000000 		.word	uxSchedulerSuspended
 691 00b4 00000000 		.word	xTickCount
 692 00b8 04ED00E0 		.word	-536810236
 693              		.cfi_endproc
 694              	.LFE7:
 696              		.section	.text.vTaskDelay,"ax",%progbits
 697              		.align	2
 698              		.global	vTaskDelay
 699              		.thumb
 700              		.thumb_func
 702              	vTaskDelay:
 703              	.LFB8:
1122:../src/RTOS/tasks.c **** 
1123:../src/RTOS/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1124:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1125:../src/RTOS/tasks.c **** 
1126:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1127:../src/RTOS/tasks.c **** 
1128:../src/RTOS/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1129:../src/RTOS/tasks.c **** 	{
 704              		.loc 1 1129 0
 705              		.cfi_startproc
 706              		@ args = 0, pretend = 0, frame = 16
 707              		@ frame_needed = 1, uses_anonymous_args = 0
 708 0000 80B5     		push	{r7, lr}
 709              		.cfi_def_cfa_offset 8
 710              		.cfi_offset 7, -8
 711              		.cfi_offset 14, -4
 712 0002 84B0     		sub	sp, sp, #16
 713              		.cfi_def_cfa_offset 24
 714 0004 00AF     		add	r7, sp, #0
 715              		.cfi_def_cfa_register 7
 716 0006 7860     		str	r0, [r7, #4]
1130:../src/RTOS/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 717              		.loc 1 1130 0
 718 0008 0023     		movs	r3, #0
 719 000a FB60     		str	r3, [r7, #12]
1131:../src/RTOS/tasks.c **** 
1132:../src/RTOS/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1133:../src/RTOS/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 720              		.loc 1 1133 0
 721 000c 7B68     		ldr	r3, [r7, #4]
 722 000e 002B     		cmp	r3, #0
 723 0010 0DD0     		beq	.L40
1134:../src/RTOS/tasks.c **** 		{
1135:../src/RTOS/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
 724              		.loc 1 1135 0
 725 0012 0E4B     		ldr	r3, .L44
 726 0014 1B68     		ldr	r3, [r3]
 727 0016 002B     		cmp	r3, #0
 728 0018 00D0     		beq	.L41
 729              	.L42:
 730              		.loc 1 1135 0 is_stmt 0 discriminator 1
 731 001a FEE7     		b	.L42
 732              	.L41:
1136:../src/RTOS/tasks.c **** 			vTaskSuspendAll();
 733              		.loc 1 1136 0 is_stmt 1
 734 001c FFF7FEFF 		bl	vTaskSuspendAll
1137:../src/RTOS/tasks.c **** 			{
1138:../src/RTOS/tasks.c **** 				traceTASK_DELAY();
1139:../src/RTOS/tasks.c **** 
1140:../src/RTOS/tasks.c **** 				/* A task that is removed from the event list while the
1141:../src/RTOS/tasks.c **** 				scheduler is suspended will not get placed in the ready
1142:../src/RTOS/tasks.c **** 				list or removed from the blocked list until the scheduler
1143:../src/RTOS/tasks.c **** 				is resumed.
1144:../src/RTOS/tasks.c **** 
1145:../src/RTOS/tasks.c **** 				This task cannot be in an event list as it is the currently
1146:../src/RTOS/tasks.c **** 				executing task. */
1147:../src/RTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 735              		.loc 1 1147 0
 736 0020 7868     		ldr	r0, [r7, #4]
 737 0022 0021     		movs	r1, #0
 738 0024 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1148:../src/RTOS/tasks.c **** 			}
1149:../src/RTOS/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 739              		.loc 1 1149 0
 740 0028 FFF7FEFF 		bl	xTaskResumeAll
 741 002c F860     		str	r0, [r7, #12]
 742              	.L40:
1150:../src/RTOS/tasks.c **** 		}
1151:../src/RTOS/tasks.c **** 		else
1152:../src/RTOS/tasks.c **** 		{
1153:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1154:../src/RTOS/tasks.c **** 		}
1155:../src/RTOS/tasks.c **** 
1156:../src/RTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1157:../src/RTOS/tasks.c **** 		have put ourselves to sleep. */
1158:../src/RTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 743              		.loc 1 1158 0
 744 002e FB68     		ldr	r3, [r7, #12]
 745 0030 002B     		cmp	r3, #0
 746 0032 07D1     		bne	.L39
1159:../src/RTOS/tasks.c **** 		{
1160:../src/RTOS/tasks.c **** 			portYIELD_WITHIN_API();
 747              		.loc 1 1160 0
 748 0034 064B     		ldr	r3, .L44+4
 749 0036 4FF08052 		mov	r2, #268435456
 750 003a 1A60     		str	r2, [r3]
 751              	@ 1160 "../src/RTOS/tasks.c" 1
 752 003c BFF34F8F 		dsb
 753              	@ 0 "" 2
 754              	@ 1160 "../src/RTOS/tasks.c" 1
 755 0040 BFF36F8F 		isb
 756              	@ 0 "" 2
 757              		.thumb
 758              	.L39:
1161:../src/RTOS/tasks.c **** 		}
1162:../src/RTOS/tasks.c **** 		else
1163:../src/RTOS/tasks.c **** 		{
1164:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1165:../src/RTOS/tasks.c **** 		}
1166:../src/RTOS/tasks.c **** 	}
 759              		.loc 1 1166 0
 760 0044 1037     		adds	r7, r7, #16
 761              		.cfi_def_cfa_offset 8
 762 0046 BD46     		mov	sp, r7
 763              		.cfi_def_cfa_register 13
 764              		@ sp needed
 765 0048 80BD     		pop	{r7, pc}
 766              	.L45:
 767 004a 00BF     		.align	2
 768              	.L44:
 769 004c 00000000 		.word	uxSchedulerSuspended
 770 0050 04ED00E0 		.word	-536810236
 771              		.cfi_endproc
 772              	.LFE8:
 774              		.section	.text.vTaskSuspend,"ax",%progbits
 775              		.align	2
 776              		.global	vTaskSuspend
 777              		.thumb
 778              		.thumb_func
 780              	vTaskSuspend:
 781              	.LFB9:
1167:../src/RTOS/tasks.c **** 
1168:../src/RTOS/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1169:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1170:../src/RTOS/tasks.c **** 
1171:../src/RTOS/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1172:../src/RTOS/tasks.c **** 
1173:../src/RTOS/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1174:../src/RTOS/tasks.c **** 	{
1175:../src/RTOS/tasks.c **** 	eTaskState eReturn;
1176:../src/RTOS/tasks.c **** 	List_t *pxStateList;
1177:../src/RTOS/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1178:../src/RTOS/tasks.c **** 
1179:../src/RTOS/tasks.c **** 		configASSERT( pxTCB );
1180:../src/RTOS/tasks.c **** 
1181:../src/RTOS/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1182:../src/RTOS/tasks.c **** 		{
1183:../src/RTOS/tasks.c **** 			/* The task calling this function is querying its own state. */
1184:../src/RTOS/tasks.c **** 			eReturn = eRunning;
1185:../src/RTOS/tasks.c **** 		}
1186:../src/RTOS/tasks.c **** 		else
1187:../src/RTOS/tasks.c **** 		{
1188:../src/RTOS/tasks.c **** 			taskENTER_CRITICAL();
1189:../src/RTOS/tasks.c **** 			{
1190:../src/RTOS/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1191:../src/RTOS/tasks.c **** 			}
1192:../src/RTOS/tasks.c **** 			taskEXIT_CRITICAL();
1193:../src/RTOS/tasks.c **** 
1194:../src/RTOS/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
1195:../src/RTOS/tasks.c **** 			{
1196:../src/RTOS/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1197:../src/RTOS/tasks.c **** 				lists. */
1198:../src/RTOS/tasks.c **** 				eReturn = eBlocked;
1199:../src/RTOS/tasks.c **** 			}
1200:../src/RTOS/tasks.c **** 
1201:../src/RTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1202:../src/RTOS/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1203:../src/RTOS/tasks.c **** 				{
1204:../src/RTOS/tasks.c **** 					/* The task being queried is referenced from the suspended
1205:../src/RTOS/tasks.c **** 					list.  Is it genuinely suspended or is it block
1206:../src/RTOS/tasks.c **** 					indefinitely? */
1207:../src/RTOS/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1208:../src/RTOS/tasks.c **** 					{
1209:../src/RTOS/tasks.c **** 						eReturn = eSuspended;
1210:../src/RTOS/tasks.c **** 					}
1211:../src/RTOS/tasks.c **** 					else
1212:../src/RTOS/tasks.c **** 					{
1213:../src/RTOS/tasks.c **** 						eReturn = eBlocked;
1214:../src/RTOS/tasks.c **** 					}
1215:../src/RTOS/tasks.c **** 				}
1216:../src/RTOS/tasks.c **** 			#endif
1217:../src/RTOS/tasks.c **** 
1218:../src/RTOS/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1219:../src/RTOS/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1220:../src/RTOS/tasks.c **** 				{
1221:../src/RTOS/tasks.c **** 					/* The task being queried is referenced from the deleted
1222:../src/RTOS/tasks.c **** 					tasks list, or it is not referenced from any lists at
1223:../src/RTOS/tasks.c **** 					all. */
1224:../src/RTOS/tasks.c **** 					eReturn = eDeleted;
1225:../src/RTOS/tasks.c **** 				}
1226:../src/RTOS/tasks.c **** 			#endif
1227:../src/RTOS/tasks.c **** 
1228:../src/RTOS/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1229:../src/RTOS/tasks.c **** 			{
1230:../src/RTOS/tasks.c **** 				/* If the task is not in any other state, it must be in the
1231:../src/RTOS/tasks.c **** 				Ready (including pending ready) state. */
1232:../src/RTOS/tasks.c **** 				eReturn = eReady;
1233:../src/RTOS/tasks.c **** 			}
1234:../src/RTOS/tasks.c **** 		}
1235:../src/RTOS/tasks.c **** 
1236:../src/RTOS/tasks.c **** 		return eReturn;
1237:../src/RTOS/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1238:../src/RTOS/tasks.c **** 
1239:../src/RTOS/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1240:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1241:../src/RTOS/tasks.c **** 
1242:../src/RTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1243:../src/RTOS/tasks.c **** 
1244:../src/RTOS/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1245:../src/RTOS/tasks.c **** 	{
1246:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
1247:../src/RTOS/tasks.c **** 	UBaseType_t uxReturn;
1248:../src/RTOS/tasks.c **** 
1249:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
1250:../src/RTOS/tasks.c **** 		{
1251:../src/RTOS/tasks.c **** 			/* If null is passed in here then it is the priority of the that
1252:../src/RTOS/tasks.c **** 			called uxTaskPriorityGet() that is being queried. */
1253:../src/RTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1254:../src/RTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1255:../src/RTOS/tasks.c **** 		}
1256:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
1257:../src/RTOS/tasks.c **** 
1258:../src/RTOS/tasks.c **** 		return uxReturn;
1259:../src/RTOS/tasks.c **** 	}
1260:../src/RTOS/tasks.c **** 
1261:../src/RTOS/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1262:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1263:../src/RTOS/tasks.c **** 
1264:../src/RTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1265:../src/RTOS/tasks.c **** 
1266:../src/RTOS/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1267:../src/RTOS/tasks.c **** 	{
1268:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
1269:../src/RTOS/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1270:../src/RTOS/tasks.c **** 
1271:../src/RTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1272:../src/RTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1273:../src/RTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1274:../src/RTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1275:../src/RTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1276:../src/RTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
1277:../src/RTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1278:../src/RTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1279:../src/RTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
1280:../src/RTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1281:../src/RTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1282:../src/RTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1283:../src/RTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1284:../src/RTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1285:../src/RTOS/tasks.c **** 		provided on the following link:
1286:../src/RTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1287:../src/RTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1288:../src/RTOS/tasks.c **** 
1289:../src/RTOS/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1290:../src/RTOS/tasks.c **** 		{
1291:../src/RTOS/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1292:../src/RTOS/tasks.c **** 			task that is being queried. */
1293:../src/RTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1294:../src/RTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1295:../src/RTOS/tasks.c **** 		}
1296:../src/RTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1297:../src/RTOS/tasks.c **** 
1298:../src/RTOS/tasks.c **** 		return uxReturn;
1299:../src/RTOS/tasks.c **** 	}
1300:../src/RTOS/tasks.c **** 
1301:../src/RTOS/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1302:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1303:../src/RTOS/tasks.c **** 
1304:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1305:../src/RTOS/tasks.c **** 
1306:../src/RTOS/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1307:../src/RTOS/tasks.c **** 	{
1308:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
1309:../src/RTOS/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1310:../src/RTOS/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1311:../src/RTOS/tasks.c **** 
1312:../src/RTOS/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1313:../src/RTOS/tasks.c **** 
1314:../src/RTOS/tasks.c **** 		/* Ensure the new priority is valid. */
1315:../src/RTOS/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1316:../src/RTOS/tasks.c **** 		{
1317:../src/RTOS/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1318:../src/RTOS/tasks.c **** 		}
1319:../src/RTOS/tasks.c **** 		else
1320:../src/RTOS/tasks.c **** 		{
1321:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1322:../src/RTOS/tasks.c **** 		}
1323:../src/RTOS/tasks.c **** 
1324:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
1325:../src/RTOS/tasks.c **** 		{
1326:../src/RTOS/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1327:../src/RTOS/tasks.c **** 			task that is being changed. */
1328:../src/RTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1329:../src/RTOS/tasks.c **** 
1330:../src/RTOS/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1331:../src/RTOS/tasks.c **** 
1332:../src/RTOS/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1333:../src/RTOS/tasks.c **** 			{
1334:../src/RTOS/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1335:../src/RTOS/tasks.c **** 			}
1336:../src/RTOS/tasks.c **** 			#else
1337:../src/RTOS/tasks.c **** 			{
1338:../src/RTOS/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1339:../src/RTOS/tasks.c **** 			}
1340:../src/RTOS/tasks.c **** 			#endif
1341:../src/RTOS/tasks.c **** 
1342:../src/RTOS/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1343:../src/RTOS/tasks.c **** 			{
1344:../src/RTOS/tasks.c **** 				/* The priority change may have readied a task of higher
1345:../src/RTOS/tasks.c **** 				priority than the calling task. */
1346:../src/RTOS/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1347:../src/RTOS/tasks.c **** 				{
1348:../src/RTOS/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1349:../src/RTOS/tasks.c **** 					{
1350:../src/RTOS/tasks.c **** 						/* The priority of a task other than the currently
1351:../src/RTOS/tasks.c **** 						running task is being raised.  Is the priority being
1352:../src/RTOS/tasks.c **** 						raised above that of the running task? */
1353:../src/RTOS/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1354:../src/RTOS/tasks.c **** 						{
1355:../src/RTOS/tasks.c **** 							xYieldRequired = pdTRUE;
1356:../src/RTOS/tasks.c **** 						}
1357:../src/RTOS/tasks.c **** 						else
1358:../src/RTOS/tasks.c **** 						{
1359:../src/RTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1360:../src/RTOS/tasks.c **** 						}
1361:../src/RTOS/tasks.c **** 					}
1362:../src/RTOS/tasks.c **** 					else
1363:../src/RTOS/tasks.c **** 					{
1364:../src/RTOS/tasks.c **** 						/* The priority of the running task is being raised,
1365:../src/RTOS/tasks.c **** 						but the running task must already be the highest
1366:../src/RTOS/tasks.c **** 						priority task able to run so no yield is required. */
1367:../src/RTOS/tasks.c **** 					}
1368:../src/RTOS/tasks.c **** 				}
1369:../src/RTOS/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1370:../src/RTOS/tasks.c **** 				{
1371:../src/RTOS/tasks.c **** 					/* Setting the priority of the running task down means
1372:../src/RTOS/tasks.c **** 					there may now be another task of higher priority that
1373:../src/RTOS/tasks.c **** 					is ready to execute. */
1374:../src/RTOS/tasks.c **** 					xYieldRequired = pdTRUE;
1375:../src/RTOS/tasks.c **** 				}
1376:../src/RTOS/tasks.c **** 				else
1377:../src/RTOS/tasks.c **** 				{
1378:../src/RTOS/tasks.c **** 					/* Setting the priority of any other task down does not
1379:../src/RTOS/tasks.c **** 					require a yield as the running task must be above the
1380:../src/RTOS/tasks.c **** 					new priority of the task being modified. */
1381:../src/RTOS/tasks.c **** 				}
1382:../src/RTOS/tasks.c **** 
1383:../src/RTOS/tasks.c **** 				/* Remember the ready list the task might be referenced from
1384:../src/RTOS/tasks.c **** 				before its uxPriority member is changed so the
1385:../src/RTOS/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1386:../src/RTOS/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1387:../src/RTOS/tasks.c **** 
1388:../src/RTOS/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1389:../src/RTOS/tasks.c **** 				{
1390:../src/RTOS/tasks.c **** 					/* Only change the priority being used if the task is not
1391:../src/RTOS/tasks.c **** 					currently using an inherited priority. */
1392:../src/RTOS/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1393:../src/RTOS/tasks.c **** 					{
1394:../src/RTOS/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1395:../src/RTOS/tasks.c **** 					}
1396:../src/RTOS/tasks.c **** 					else
1397:../src/RTOS/tasks.c **** 					{
1398:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1399:../src/RTOS/tasks.c **** 					}
1400:../src/RTOS/tasks.c **** 
1401:../src/RTOS/tasks.c **** 					/* The base priority gets set whatever. */
1402:../src/RTOS/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1403:../src/RTOS/tasks.c **** 				}
1404:../src/RTOS/tasks.c **** 				#else
1405:../src/RTOS/tasks.c **** 				{
1406:../src/RTOS/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1407:../src/RTOS/tasks.c **** 				}
1408:../src/RTOS/tasks.c **** 				#endif
1409:../src/RTOS/tasks.c **** 
1410:../src/RTOS/tasks.c **** 				/* Only reset the event list item value if the value is not
1411:../src/RTOS/tasks.c **** 				being used for anything else. */
1412:../src/RTOS/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1413:../src/RTOS/tasks.c **** 				{
1414:../src/RTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1415:../src/RTOS/tasks.c **** 				}
1416:../src/RTOS/tasks.c **** 				else
1417:../src/RTOS/tasks.c **** 				{
1418:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1419:../src/RTOS/tasks.c **** 				}
1420:../src/RTOS/tasks.c **** 
1421:../src/RTOS/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1422:../src/RTOS/tasks.c **** 				nothing more than change it's priority variable. However, if
1423:../src/RTOS/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1424:../src/RTOS/tasks.c **** 				in the list appropriate to its new priority. */
1425:../src/RTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
1426:../src/RTOS/tasks.c **** 				{
1427:../src/RTOS/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1428:../src/RTOS/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1429:../src/RTOS/tasks.c **** 					can do this even if the scheduler is suspended. */
1430:../src/RTOS/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1431:../src/RTOS/tasks.c **** 					{
1432:../src/RTOS/tasks.c **** 						/* It is known that the task is in its ready list so
1433:../src/RTOS/tasks.c **** 						there is no need to check again and the port level
1434:../src/RTOS/tasks.c **** 						reset macro can be called directly. */
1435:../src/RTOS/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1436:../src/RTOS/tasks.c **** 					}
1437:../src/RTOS/tasks.c **** 					else
1438:../src/RTOS/tasks.c **** 					{
1439:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1440:../src/RTOS/tasks.c **** 					}
1441:../src/RTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1442:../src/RTOS/tasks.c **** 				}
1443:../src/RTOS/tasks.c **** 				else
1444:../src/RTOS/tasks.c **** 				{
1445:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1446:../src/RTOS/tasks.c **** 				}
1447:../src/RTOS/tasks.c **** 
1448:../src/RTOS/tasks.c **** 				if( xYieldRequired != pdFALSE )
1449:../src/RTOS/tasks.c **** 				{
1450:../src/RTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1451:../src/RTOS/tasks.c **** 				}
1452:../src/RTOS/tasks.c **** 				else
1453:../src/RTOS/tasks.c **** 				{
1454:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1455:../src/RTOS/tasks.c **** 				}
1456:../src/RTOS/tasks.c **** 
1457:../src/RTOS/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1458:../src/RTOS/tasks.c **** 				optimised task selection is not being used. */
1459:../src/RTOS/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1460:../src/RTOS/tasks.c **** 			}
1461:../src/RTOS/tasks.c **** 		}
1462:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
1463:../src/RTOS/tasks.c **** 	}
1464:../src/RTOS/tasks.c **** 
1465:../src/RTOS/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1466:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1467:../src/RTOS/tasks.c **** 
1468:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1469:../src/RTOS/tasks.c **** 
1470:../src/RTOS/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1471:../src/RTOS/tasks.c **** 	{
 782              		.loc 1 1471 0
 783              		.cfi_startproc
 784              		@ args = 0, pretend = 0, frame = 16
 785              		@ frame_needed = 1, uses_anonymous_args = 0
 786 0000 80B5     		push	{r7, lr}
 787              		.cfi_def_cfa_offset 8
 788              		.cfi_offset 7, -8
 789              		.cfi_offset 14, -4
 790 0002 84B0     		sub	sp, sp, #16
 791              		.cfi_def_cfa_offset 24
 792 0004 00AF     		add	r7, sp, #0
 793              		.cfi_def_cfa_register 7
 794 0006 7860     		str	r0, [r7, #4]
1472:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
1473:../src/RTOS/tasks.c **** 
1474:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
 795              		.loc 1 1474 0
 796 0008 FFF7FEFF 		bl	vPortEnterCritical
1475:../src/RTOS/tasks.c **** 		{
1476:../src/RTOS/tasks.c **** 			/* If null is passed in here then it is the running task that is
1477:../src/RTOS/tasks.c **** 			being suspended. */
1478:../src/RTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 797              		.loc 1 1478 0
 798 000c 7B68     		ldr	r3, [r7, #4]
 799 000e 002B     		cmp	r3, #0
 800 0010 02D1     		bne	.L47
 801              		.loc 1 1478 0 is_stmt 0 discriminator 1
 802 0012 254B     		ldr	r3, .L57
 803 0014 1B68     		ldr	r3, [r3]
 804 0016 00E0     		b	.L48
 805              	.L47:
 806              		.loc 1 1478 0 discriminator 2
 807 0018 7B68     		ldr	r3, [r7, #4]
 808              	.L48:
 809              		.loc 1 1478 0 discriminator 4
 810 001a FB60     		str	r3, [r7, #12]
1479:../src/RTOS/tasks.c **** 
1480:../src/RTOS/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1481:../src/RTOS/tasks.c **** 
1482:../src/RTOS/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1483:../src/RTOS/tasks.c **** 			suspended list. */
1484:../src/RTOS/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 811              		.loc 1 1484 0 is_stmt 1 discriminator 4
 812 001c FB68     		ldr	r3, [r7, #12]
 813 001e 0433     		adds	r3, r3, #4
 814 0020 1846     		mov	r0, r3
 815 0022 FFF7FEFF 		bl	uxListRemove
1485:../src/RTOS/tasks.c **** 			{
1486:../src/RTOS/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1487:../src/RTOS/tasks.c **** 			}
1488:../src/RTOS/tasks.c **** 			else
1489:../src/RTOS/tasks.c **** 			{
1490:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1491:../src/RTOS/tasks.c **** 			}
1492:../src/RTOS/tasks.c **** 
1493:../src/RTOS/tasks.c **** 			/* Is the task waiting on an event also? */
1494:../src/RTOS/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 816              		.loc 1 1494 0 discriminator 4
 817 0026 FB68     		ldr	r3, [r7, #12]
 818 0028 9B6A     		ldr	r3, [r3, #40]
 819 002a 002B     		cmp	r3, #0
 820 002c 04D0     		beq	.L49
1495:../src/RTOS/tasks.c **** 			{
1496:../src/RTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 821              		.loc 1 1496 0
 822 002e FB68     		ldr	r3, [r7, #12]
 823 0030 1833     		adds	r3, r3, #24
 824 0032 1846     		mov	r0, r3
 825 0034 FFF7FEFF 		bl	uxListRemove
 826              	.L49:
1497:../src/RTOS/tasks.c **** 			}
1498:../src/RTOS/tasks.c **** 			else
1499:../src/RTOS/tasks.c **** 			{
1500:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1501:../src/RTOS/tasks.c **** 			}
1502:../src/RTOS/tasks.c **** 
1503:../src/RTOS/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 827              		.loc 1 1503 0
 828 0038 FB68     		ldr	r3, [r7, #12]
 829 003a 0433     		adds	r3, r3, #4
 830 003c 1B48     		ldr	r0, .L57+4
 831 003e 1946     		mov	r1, r3
 832 0040 FFF7FEFF 		bl	vListInsertEnd
1504:../src/RTOS/tasks.c **** 		}
1505:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
 833              		.loc 1 1505 0
 834 0044 FFF7FEFF 		bl	vPortExitCritical
1506:../src/RTOS/tasks.c **** 
1507:../src/RTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 835              		.loc 1 1507 0
 836 0048 194B     		ldr	r3, .L57+8
 837 004a 1B68     		ldr	r3, [r3]
 838 004c 002B     		cmp	r3, #0
 839 004e 05D0     		beq	.L50
1508:../src/RTOS/tasks.c **** 		{
1509:../src/RTOS/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1510:../src/RTOS/tasks.c **** 			task that is now in the Suspended state. */
1511:../src/RTOS/tasks.c **** 			taskENTER_CRITICAL();
 840              		.loc 1 1511 0
 841 0050 FFF7FEFF 		bl	vPortEnterCritical
1512:../src/RTOS/tasks.c **** 			{
1513:../src/RTOS/tasks.c **** 				prvResetNextTaskUnblockTime();
 842              		.loc 1 1513 0
 843 0054 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
1514:../src/RTOS/tasks.c **** 			}
1515:../src/RTOS/tasks.c **** 			taskEXIT_CRITICAL();
 844              		.loc 1 1515 0
 845 0058 FFF7FEFF 		bl	vPortExitCritical
 846              	.L50:
1516:../src/RTOS/tasks.c **** 		}
1517:../src/RTOS/tasks.c **** 		else
1518:../src/RTOS/tasks.c **** 		{
1519:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1520:../src/RTOS/tasks.c **** 		}
1521:../src/RTOS/tasks.c **** 
1522:../src/RTOS/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 847              		.loc 1 1522 0
 848 005c 124B     		ldr	r3, .L57
 849 005e 1B68     		ldr	r3, [r3]
 850 0060 FA68     		ldr	r2, [r7, #12]
 851 0062 9A42     		cmp	r2, r3
 852 0064 1DD1     		bne	.L46
1523:../src/RTOS/tasks.c **** 		{
1524:../src/RTOS/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 853              		.loc 1 1524 0
 854 0066 124B     		ldr	r3, .L57+8
 855 0068 1B68     		ldr	r3, [r3]
 856 006a 002B     		cmp	r3, #0
 857 006c 0DD0     		beq	.L52
1525:../src/RTOS/tasks.c **** 			{
1526:../src/RTOS/tasks.c **** 				/* The current task has just been suspended. */
1527:../src/RTOS/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 858              		.loc 1 1527 0
 859 006e 114B     		ldr	r3, .L57+12
 860 0070 1B68     		ldr	r3, [r3]
 861 0072 002B     		cmp	r3, #0
 862 0074 00D0     		beq	.L53
 863              	.L54:
 864              		.loc 1 1527 0 is_stmt 0 discriminator 1
 865 0076 FEE7     		b	.L54
 866              	.L53:
1528:../src/RTOS/tasks.c **** 				portYIELD_WITHIN_API();
 867              		.loc 1 1528 0 is_stmt 1
 868 0078 0F4B     		ldr	r3, .L57+16
 869 007a 4FF08052 		mov	r2, #268435456
 870 007e 1A60     		str	r2, [r3]
 871              	@ 1528 "../src/RTOS/tasks.c" 1
 872 0080 BFF34F8F 		dsb
 873              	@ 0 "" 2
 874              	@ 1528 "../src/RTOS/tasks.c" 1
 875 0084 BFF36F8F 		isb
 876              	@ 0 "" 2
 877              		.thumb
 878 0088 0BE0     		b	.L46
 879              	.L52:
1529:../src/RTOS/tasks.c **** 			}
1530:../src/RTOS/tasks.c **** 			else
1531:../src/RTOS/tasks.c **** 			{
1532:../src/RTOS/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1533:../src/RTOS/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1534:../src/RTOS/tasks.c **** 				must be adjusted to point to a different task. */
1535:../src/RTOS/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 880              		.loc 1 1535 0
 881 008a 084B     		ldr	r3, .L57+4
 882 008c 1A68     		ldr	r2, [r3]
 883 008e 0B4B     		ldr	r3, .L57+20
 884 0090 1B68     		ldr	r3, [r3]
 885 0092 9A42     		cmp	r2, r3
 886 0094 03D1     		bne	.L56
1536:../src/RTOS/tasks.c **** 				{
1537:../src/RTOS/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1538:../src/RTOS/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1539:../src/RTOS/tasks.c **** 					be set to point to it no matter what its relative priority
1540:../src/RTOS/tasks.c **** 					is. */
1541:../src/RTOS/tasks.c **** 					pxCurrentTCB = NULL;
 887              		.loc 1 1541 0
 888 0096 044B     		ldr	r3, .L57
 889 0098 0022     		movs	r2, #0
 890 009a 1A60     		str	r2, [r3]
 891 009c 01E0     		b	.L46
 892              	.L56:
1542:../src/RTOS/tasks.c **** 				}
1543:../src/RTOS/tasks.c **** 				else
1544:../src/RTOS/tasks.c **** 				{
1545:../src/RTOS/tasks.c **** 					vTaskSwitchContext();
 893              		.loc 1 1545 0
 894 009e FFF7FEFF 		bl	vTaskSwitchContext
 895              	.L46:
1546:../src/RTOS/tasks.c **** 				}
1547:../src/RTOS/tasks.c **** 			}
1548:../src/RTOS/tasks.c **** 		}
1549:../src/RTOS/tasks.c **** 		else
1550:../src/RTOS/tasks.c **** 		{
1551:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1552:../src/RTOS/tasks.c **** 		}
1553:../src/RTOS/tasks.c **** 	}
 896              		.loc 1 1553 0
 897 00a2 1037     		adds	r7, r7, #16
 898              		.cfi_def_cfa_offset 8
 899 00a4 BD46     		mov	sp, r7
 900              		.cfi_def_cfa_register 13
 901              		@ sp needed
 902 00a6 80BD     		pop	{r7, pc}
 903              	.L58:
 904              		.align	2
 905              	.L57:
 906 00a8 00000000 		.word	pxCurrentTCB
 907 00ac 00000000 		.word	xSuspendedTaskList
 908 00b0 00000000 		.word	xSchedulerRunning
 909 00b4 00000000 		.word	uxSchedulerSuspended
 910 00b8 04ED00E0 		.word	-536810236
 911 00bc 00000000 		.word	uxCurrentNumberOfTasks
 912              		.cfi_endproc
 913              	.LFE9:
 915              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
 916              		.align	2
 917              		.thumb
 918              		.thumb_func
 920              	prvTaskIsTaskSuspended:
 921              	.LFB10:
1554:../src/RTOS/tasks.c **** 
1555:../src/RTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1556:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1557:../src/RTOS/tasks.c **** 
1558:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1559:../src/RTOS/tasks.c **** 
1560:../src/RTOS/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1561:../src/RTOS/tasks.c **** 	{
 922              		.loc 1 1561 0
 923              		.cfi_startproc
 924              		@ args = 0, pretend = 0, frame = 16
 925              		@ frame_needed = 1, uses_anonymous_args = 0
 926              		@ link register save eliminated.
 927 0000 80B4     		push	{r7}
 928              		.cfi_def_cfa_offset 4
 929              		.cfi_offset 7, -4
 930 0002 85B0     		sub	sp, sp, #20
 931              		.cfi_def_cfa_offset 24
 932 0004 00AF     		add	r7, sp, #0
 933              		.cfi_def_cfa_register 7
 934 0006 7860     		str	r0, [r7, #4]
1562:../src/RTOS/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 935              		.loc 1 1562 0
 936 0008 0023     		movs	r3, #0
 937 000a FB60     		str	r3, [r7, #12]
1563:../src/RTOS/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 938              		.loc 1 1563 0
 939 000c 7B68     		ldr	r3, [r7, #4]
 940 000e BB60     		str	r3, [r7, #8]
1564:../src/RTOS/tasks.c **** 
1565:../src/RTOS/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1566:../src/RTOS/tasks.c **** 		section. */
1567:../src/RTOS/tasks.c **** 
1568:../src/RTOS/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1569:../src/RTOS/tasks.c **** 		configASSERT( xTask );
 941              		.loc 1 1569 0
 942 0010 7B68     		ldr	r3, [r7, #4]
 943 0012 002B     		cmp	r3, #0
 944 0014 00D1     		bne	.L60
 945              	.L61:
 946              		.loc 1 1569 0 is_stmt 0 discriminator 1
 947 0016 FEE7     		b	.L61
 948              	.L60:
1570:../src/RTOS/tasks.c **** 
1571:../src/RTOS/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1572:../src/RTOS/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 949              		.loc 1 1572 0 is_stmt 1
 950 0018 BB68     		ldr	r3, [r7, #8]
 951 001a 5B69     		ldr	r3, [r3, #20]
 952 001c 0F4A     		ldr	r2, .L68
 953 001e 9342     		cmp	r3, r2
 954 0020 01D1     		bne	.L62
 955              		.loc 1 1572 0 is_stmt 0 discriminator 1
 956 0022 0123     		movs	r3, #1
 957 0024 00E0     		b	.L63
 958              	.L62:
 959              		.loc 1 1572 0 discriminator 2
 960 0026 0023     		movs	r3, #0
 961              	.L63:
 962              		.loc 1 1572 0 discriminator 4
 963 0028 002B     		cmp	r3, #0
 964 002a 0FD0     		beq	.L64
1573:../src/RTOS/tasks.c **** 		{
1574:../src/RTOS/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1575:../src/RTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 965              		.loc 1 1575 0 is_stmt 1
 966 002c BB68     		ldr	r3, [r7, #8]
 967 002e 9B6A     		ldr	r3, [r3, #40]
 968 0030 0B4A     		ldr	r2, .L68+4
 969 0032 9342     		cmp	r3, r2
 970 0034 0AD0     		beq	.L64
1576:../src/RTOS/tasks.c **** 			{
1577:../src/RTOS/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1578:../src/RTOS/tasks.c **** 				state, or because is is blocked with no timeout? */
1579:../src/RTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 971              		.loc 1 1579 0
 972 0036 BB68     		ldr	r3, [r7, #8]
 973 0038 9B6A     		ldr	r3, [r3, #40]
 974 003a 002B     		cmp	r3, #0
 975 003c 01D1     		bne	.L65
 976              		.loc 1 1579 0 is_stmt 0 discriminator 1
 977 003e 0123     		movs	r3, #1
 978 0040 00E0     		b	.L66
 979              	.L65:
 980              		.loc 1 1579 0 discriminator 2
 981 0042 0023     		movs	r3, #0
 982              	.L66:
 983              		.loc 1 1579 0 discriminator 4
 984 0044 002B     		cmp	r3, #0
 985 0046 01D0     		beq	.L64
1580:../src/RTOS/tasks.c **** 				{
1581:../src/RTOS/tasks.c **** 					xReturn = pdTRUE;
 986              		.loc 1 1581 0 is_stmt 1
 987 0048 0123     		movs	r3, #1
 988 004a FB60     		str	r3, [r7, #12]
 989              	.L64:
1582:../src/RTOS/tasks.c **** 				}
1583:../src/RTOS/tasks.c **** 				else
1584:../src/RTOS/tasks.c **** 				{
1585:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1586:../src/RTOS/tasks.c **** 				}
1587:../src/RTOS/tasks.c **** 			}
1588:../src/RTOS/tasks.c **** 			else
1589:../src/RTOS/tasks.c **** 			{
1590:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1591:../src/RTOS/tasks.c **** 			}
1592:../src/RTOS/tasks.c **** 		}
1593:../src/RTOS/tasks.c **** 		else
1594:../src/RTOS/tasks.c **** 		{
1595:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1596:../src/RTOS/tasks.c **** 		}
1597:../src/RTOS/tasks.c **** 
1598:../src/RTOS/tasks.c **** 		return xReturn;
 990              		.loc 1 1598 0
 991 004c FB68     		ldr	r3, [r7, #12]
1599:../src/RTOS/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 992              		.loc 1 1599 0
 993 004e 1846     		mov	r0, r3
 994 0050 1437     		adds	r7, r7, #20
 995              		.cfi_def_cfa_offset 4
 996 0052 BD46     		mov	sp, r7
 997              		.cfi_def_cfa_register 13
 998              		@ sp needed
 999 0054 5DF8047B 		ldr	r7, [sp], #4
 1000              		.cfi_restore 7
 1001              		.cfi_def_cfa_offset 0
 1002 0058 7047     		bx	lr
 1003              	.L69:
 1004 005a 00BF     		.align	2
 1005              	.L68:
 1006 005c 00000000 		.word	xSuspendedTaskList
 1007 0060 00000000 		.word	xPendingReadyList
 1008              		.cfi_endproc
 1009              	.LFE10:
 1011              		.section	.text.vTaskResume,"ax",%progbits
 1012              		.align	2
 1013              		.global	vTaskResume
 1014              		.thumb
 1015              		.thumb_func
 1017              	vTaskResume:
 1018              	.LFB11:
1600:../src/RTOS/tasks.c **** 
1601:../src/RTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1602:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1603:../src/RTOS/tasks.c **** 
1604:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1605:../src/RTOS/tasks.c **** 
1606:../src/RTOS/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1607:../src/RTOS/tasks.c **** 	{
 1019              		.loc 1 1607 0
 1020              		.cfi_startproc
 1021              		@ args = 0, pretend = 0, frame = 16
 1022              		@ frame_needed = 1, uses_anonymous_args = 0
 1023 0000 80B5     		push	{r7, lr}
 1024              		.cfi_def_cfa_offset 8
 1025              		.cfi_offset 7, -8
 1026              		.cfi_offset 14, -4
 1027 0002 84B0     		sub	sp, sp, #16
 1028              		.cfi_def_cfa_offset 24
 1029 0004 00AF     		add	r7, sp, #0
 1030              		.cfi_def_cfa_register 7
 1031 0006 7860     		str	r0, [r7, #4]
1608:../src/RTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1032              		.loc 1 1608 0
 1033 0008 7B68     		ldr	r3, [r7, #4]
 1034 000a FB60     		str	r3, [r7, #12]
1609:../src/RTOS/tasks.c **** 
1610:../src/RTOS/tasks.c **** 		/* It does not make sense to resume the calling task. */
1611:../src/RTOS/tasks.c **** 		configASSERT( xTaskToResume );
 1035              		.loc 1 1611 0
 1036 000c 7B68     		ldr	r3, [r7, #4]
 1037 000e 002B     		cmp	r3, #0
 1038 0010 00D1     		bne	.L71
 1039              	.L72:
 1040              		.loc 1 1611 0 is_stmt 0 discriminator 1
 1041 0012 FEE7     		b	.L72
 1042              	.L71:
1612:../src/RTOS/tasks.c **** 
1613:../src/RTOS/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1614:../src/RTOS/tasks.c **** 		currently executing task. */
1615:../src/RTOS/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1043              		.loc 1 1615 0 is_stmt 1
 1044 0014 FB68     		ldr	r3, [r7, #12]
 1045 0016 002B     		cmp	r3, #0
 1046 0018 3AD0     		beq	.L70
 1047              		.loc 1 1615 0 is_stmt 0 discriminator 1
 1048 001a 1F4B     		ldr	r3, .L76
 1049 001c 1B68     		ldr	r3, [r3]
 1050 001e FA68     		ldr	r2, [r7, #12]
 1051 0020 9A42     		cmp	r2, r3
 1052 0022 35D0     		beq	.L70
1616:../src/RTOS/tasks.c **** 		{
1617:../src/RTOS/tasks.c **** 			taskENTER_CRITICAL();
 1053              		.loc 1 1617 0 is_stmt 1
 1054 0024 FFF7FEFF 		bl	vPortEnterCritical
1618:../src/RTOS/tasks.c **** 			{
1619:../src/RTOS/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1055              		.loc 1 1619 0
 1056 0028 F868     		ldr	r0, [r7, #12]
 1057 002a FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1058 002e 0346     		mov	r3, r0
 1059 0030 002B     		cmp	r3, #0
 1060 0032 2BD0     		beq	.L74
1620:../src/RTOS/tasks.c **** 				{
1621:../src/RTOS/tasks.c **** 					traceTASK_RESUME( pxTCB );
1622:../src/RTOS/tasks.c **** 
1623:../src/RTOS/tasks.c **** 					/* As we are in a critical section we can access the ready
1624:../src/RTOS/tasks.c **** 					lists even if the scheduler is suspended. */
1625:../src/RTOS/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 1061              		.loc 1 1625 0
 1062 0034 FB68     		ldr	r3, [r7, #12]
 1063 0036 0433     		adds	r3, r3, #4
 1064 0038 1846     		mov	r0, r3
 1065 003a FFF7FEFF 		bl	uxListRemove
1626:../src/RTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1066              		.loc 1 1626 0
 1067 003e FB68     		ldr	r3, [r7, #12]
 1068 0040 DA6A     		ldr	r2, [r3, #44]
 1069 0042 164B     		ldr	r3, .L76+4
 1070 0044 1B68     		ldr	r3, [r3]
 1071 0046 9A42     		cmp	r2, r3
 1072 0048 03D9     		bls	.L75
 1073              		.loc 1 1626 0 is_stmt 0 discriminator 1
 1074 004a FB68     		ldr	r3, [r7, #12]
 1075 004c DB6A     		ldr	r3, [r3, #44]
 1076 004e 134A     		ldr	r2, .L76+4
 1077 0050 1360     		str	r3, [r2]
 1078              	.L75:
 1079              		.loc 1 1626 0 discriminator 3
 1080 0052 FB68     		ldr	r3, [r7, #12]
 1081 0054 DA6A     		ldr	r2, [r3, #44]
 1082 0056 1346     		mov	r3, r2
 1083 0058 9B00     		lsls	r3, r3, #2
 1084 005a 1344     		add	r3, r3, r2
 1085 005c 9B00     		lsls	r3, r3, #2
 1086 005e 104A     		ldr	r2, .L76+8
 1087 0060 1A44     		add	r2, r2, r3
 1088 0062 FB68     		ldr	r3, [r7, #12]
 1089 0064 0433     		adds	r3, r3, #4
 1090 0066 1046     		mov	r0, r2
 1091 0068 1946     		mov	r1, r3
 1092 006a FFF7FEFF 		bl	vListInsertEnd
1627:../src/RTOS/tasks.c **** 
1628:../src/RTOS/tasks.c **** 					/* We may have just resumed a higher priority task. */
1629:../src/RTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1093              		.loc 1 1629 0 is_stmt 1 discriminator 3
 1094 006e FB68     		ldr	r3, [r7, #12]
 1095 0070 DA6A     		ldr	r2, [r3, #44]
 1096 0072 094B     		ldr	r3, .L76
 1097 0074 1B68     		ldr	r3, [r3]
 1098 0076 DB6A     		ldr	r3, [r3, #44]
 1099 0078 9A42     		cmp	r2, r3
 1100 007a 07D3     		bcc	.L74
1630:../src/RTOS/tasks.c **** 					{
1631:../src/RTOS/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1632:../src/RTOS/tasks.c **** 						but will leave the lists in the correct state for the
1633:../src/RTOS/tasks.c **** 						next yield. */
1634:../src/RTOS/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
 1101              		.loc 1 1634 0
 1102 007c 094B     		ldr	r3, .L76+12
 1103 007e 4FF08052 		mov	r2, #268435456
 1104 0082 1A60     		str	r2, [r3]
 1105              	@ 1634 "../src/RTOS/tasks.c" 1
 1106 0084 BFF34F8F 		dsb
 1107              	@ 0 "" 2
 1108              	@ 1634 "../src/RTOS/tasks.c" 1
 1109 0088 BFF36F8F 		isb
 1110              	@ 0 "" 2
 1111              		.thumb
 1112              	.L74:
1635:../src/RTOS/tasks.c **** 					}
1636:../src/RTOS/tasks.c **** 					else
1637:../src/RTOS/tasks.c **** 					{
1638:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1639:../src/RTOS/tasks.c **** 					}
1640:../src/RTOS/tasks.c **** 				}
1641:../src/RTOS/tasks.c **** 				else
1642:../src/RTOS/tasks.c **** 				{
1643:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1644:../src/RTOS/tasks.c **** 				}
1645:../src/RTOS/tasks.c **** 			}
1646:../src/RTOS/tasks.c **** 			taskEXIT_CRITICAL();
 1113              		.loc 1 1646 0
 1114 008c FFF7FEFF 		bl	vPortExitCritical
 1115              	.L70:
1647:../src/RTOS/tasks.c **** 		}
1648:../src/RTOS/tasks.c **** 		else
1649:../src/RTOS/tasks.c **** 		{
1650:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1651:../src/RTOS/tasks.c **** 		}
1652:../src/RTOS/tasks.c **** 	}
 1116              		.loc 1 1652 0
 1117 0090 1037     		adds	r7, r7, #16
 1118              		.cfi_def_cfa_offset 8
 1119 0092 BD46     		mov	sp, r7
 1120              		.cfi_def_cfa_register 13
 1121              		@ sp needed
 1122 0094 80BD     		pop	{r7, pc}
 1123              	.L77:
 1124 0096 00BF     		.align	2
 1125              	.L76:
 1126 0098 00000000 		.word	pxCurrentTCB
 1127 009c 00000000 		.word	uxTopReadyPriority
 1128 00a0 00000000 		.word	pxReadyTasksLists
 1129 00a4 04ED00E0 		.word	-536810236
 1130              		.cfi_endproc
 1131              	.LFE11:
 1133              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1134              		.align	2
 1135              		.global	xTaskResumeFromISR
 1136              		.thumb
 1137              		.thumb_func
 1139              	xTaskResumeFromISR:
 1140              	.LFB12:
1653:../src/RTOS/tasks.c **** 
1654:../src/RTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1655:../src/RTOS/tasks.c **** 
1656:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1657:../src/RTOS/tasks.c **** 
1658:../src/RTOS/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1659:../src/RTOS/tasks.c **** 
1660:../src/RTOS/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1661:../src/RTOS/tasks.c **** 	{
 1141              		.loc 1 1661 0
 1142              		.cfi_startproc
 1143              		@ args = 0, pretend = 0, frame = 32
 1144              		@ frame_needed = 1, uses_anonymous_args = 0
 1145 0000 80B5     		push	{r7, lr}
 1146              		.cfi_def_cfa_offset 8
 1147              		.cfi_offset 7, -8
 1148              		.cfi_offset 14, -4
 1149 0002 88B0     		sub	sp, sp, #32
 1150              		.cfi_def_cfa_offset 40
 1151 0004 00AF     		add	r7, sp, #0
 1152              		.cfi_def_cfa_register 7
 1153 0006 7860     		str	r0, [r7, #4]
1662:../src/RTOS/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1154              		.loc 1 1662 0
 1155 0008 0023     		movs	r3, #0
 1156 000a FB61     		str	r3, [r7, #28]
1663:../src/RTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1157              		.loc 1 1663 0
 1158 000c 7B68     		ldr	r3, [r7, #4]
 1159 000e BB61     		str	r3, [r7, #24]
1664:../src/RTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1665:../src/RTOS/tasks.c **** 
1666:../src/RTOS/tasks.c **** 		configASSERT( xTaskToResume );
 1160              		.loc 1 1666 0
 1161 0010 7B68     		ldr	r3, [r7, #4]
 1162 0012 002B     		cmp	r3, #0
 1163 0014 00D1     		bne	.L79
 1164              	.L80:
 1165              		.loc 1 1666 0 is_stmt 0 discriminator 1
 1166 0016 FEE7     		b	.L80
 1167              	.L79:
1667:../src/RTOS/tasks.c **** 
1668:../src/RTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1669:../src/RTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1670:../src/RTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1671:../src/RTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1672:../src/RTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1673:../src/RTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
1674:../src/RTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1675:../src/RTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1676:../src/RTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
1677:../src/RTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1678:../src/RTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1679:../src/RTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1680:../src/RTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1681:../src/RTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1682:../src/RTOS/tasks.c **** 		provided on the following link:
1683:../src/RTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1684:../src/RTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1168              		.loc 1 1684 0 is_stmt 1
 1169 0018 FFF7FEFF 		bl	vPortValidateInterruptPriority
 1170              	.LBB20:
 1171              	.LBB21:
 1172              		.file 2 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h"
   1:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*
   2:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     FreeRTOS V9.0.0rc2 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     All rights reserved
   4:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
   5:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
   7:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     This file is part of the FreeRTOS distribution.
   8:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
   9:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     the terms of the GNU General Public License (version 2) as published by the
  11:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  13:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     ***************************************************************************
  14:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     ***************************************************************************
  19:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  20:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     link: http://www.freertos.org/a00114.html
  24:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  25:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     ***************************************************************************
  26:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *                                                                       *
  27:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    robust, strictly quality controlled, supported, and cross          *
  29:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    platform software that is more than just the market leader, it     *
  30:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    is the industry's de facto standard.                               *
  31:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *                                                                       *
  32:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    Help yourself get started quickly while simultaneously helping     *
  33:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    tutorial book, reference manual, or both:                          *
  35:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****      *                                                                       *
  37:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     ***************************************************************************
  38:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  39:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     defined configASSERT()?
  42:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  43:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     embedded software for free we request you assist our global community by
  45:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     participating in the support forum.
  46:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  47:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     be as productive as possible as early as possible.  Now you can receive
  49:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  52:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  56:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  59:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  63:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     engineered and independently SIL3 certified version for use in safety and
  65:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     mission critical applications that require provable dependability.
  66:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  67:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****     1 tab == 4 spaces!
  68:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** */
  69:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  70:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  71:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifndef PORTMACRO_H
  72:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define PORTMACRO_H
  73:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  74:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifdef __cplusplus
  75:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** extern "C" {
  76:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
  77:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  78:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------
  79:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  * Port specific definitions.
  80:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  *
  81:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  82:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  * given hardware and compiler.
  83:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  *
  84:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  * These settings should not be altered.
  85:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  *-----------------------------------------------------------
  86:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h ****  */
  87:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  88:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Type definitions. */
  89:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portCHAR		char
  90:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portFLOAT		float
  91:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portDOUBLE		double
  92:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portLONG		long
  93:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portSHORT		short
  94:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portSTACK_TYPE	uint32_t
  95:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portBASE_TYPE	long
  96:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
  97:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** typedef portSTACK_TYPE StackType_t;
  98:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** typedef long BaseType_t;
  99:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** typedef unsigned long UBaseType_t;
 100:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 101:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
 102:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	typedef uint16_t TickType_t;
 103:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
 104:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #else
 105:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	typedef uint32_t TickType_t;
 106:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
 107:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 108:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
 109:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	not need to be guarded with a critical section. */
 110:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
 111:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
 112:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 113:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 114:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Architecture specifics. */
 115:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portSTACK_GROWTH			( -1 )
 116:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
 117:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portBYTE_ALIGNMENT			8
 118:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 119:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 120:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Scheduler utilities. */
 121:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portYIELD() 															\
 122:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** {																				\
 123:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
 124:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
 125:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 																				\
 126:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
 127:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	within the specified behaviour for the architecture. */						\
 128:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile( "dsb" );													\
 129:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile( "isb" );													\
 130:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 131:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 132:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
 133:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
 134:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
 135:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
 136:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 137:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 138:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Critical section management. */
 139:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** extern void vPortEnterCritical( void );
 140:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** extern void vPortExitCritical( void );
 141:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 142:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 143:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 144:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 145:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 146:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 147:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 148:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 149:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 150:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 151:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 152:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** (which build with all the ports) will build. */
 153:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 154:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 155:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 156:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 157:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Tickless idle/low power functionality. */
 158:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 159:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 160:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 161:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
 162:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 163:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 164:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* Architecture specific optimisations. */
 165:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 166:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 167:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
 168:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 169:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 170:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 171:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Generic helper function. */
 172:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 173:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	{
 174:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	uint8_t ucReturn;
 175:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 176:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 177:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		return ucReturn;
 178:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	}
 179:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 180:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Check the configuration. */
 181:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 182:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 183:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#endif
 184:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 185:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 186:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 187:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 188:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 189:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/*-----------------------------------------------------------*/
 190:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 191:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 192:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 193:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 194:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 195:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 196:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 197:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifdef configASSERT
 198:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	void vPortValidateInterruptPriority( void );
 199:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 200:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
 201:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 202:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /* portNOP() is not required by this port. */
 203:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portNOP()
 204:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 205:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #define portINLINE	__inline
 206:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 207:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #ifndef portFORCE_INLINE
 208:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 209:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** #endif
 210:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 211:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 212:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** {
 213:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** uint32_t ulCurrentInterrupt;
 214:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** BaseType_t xReturn;
 215:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 216:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 217:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 218:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 219:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 220:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	{
 221:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		xReturn = pdFALSE;
 222:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	}
 223:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	else
 224:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	{
 225:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		xReturn = pdTRUE;
 226:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	}
 227:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 228:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	return xReturn;
 229:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 230:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 231:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 232:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 233:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 234:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** {
 235:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** uint32_t ulNewBASEPRI;
 236:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 237:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile
 238:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 239:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	mov %0, %1												\n"	\
 240:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	msr basepri, %0											\n" \
 241:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	isb														\n" \
 242:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	dsb														\n" \
 243:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 244:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	);
 245:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 246:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 247:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 248:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 249:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 250:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** {
 251:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 252:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 253:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile
 1173              		.loc 2 253 0
 1174              	@ 253 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 1175 001c EFF31182 			mrs r2, basepri											
 1176 0020 4FF0BF03 		mov r3, #191												
 1177 0024 83F31188 		msr basepri, r3											
 1178 0028 BFF36F8F 		isb														
 1179 002c BFF34F8F 		dsb														
 1180              	
 1181              	@ 0 "" 2
 1182              		.thumb
 1183 0030 3A61     		str	r2, [r7, #16]
 1184 0032 FB60     		str	r3, [r7, #12]
 254:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 255:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	mrs %0, basepri											\n" \
 256:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	mov %1, %2												\n"	\
 257:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	msr basepri, %1											\n" \
 258:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	isb														\n" \
 259:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		"	dsb														\n" \
 260:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 261:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	);
 262:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 263:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 264:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	warnings. */
 265:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	return ulOriginalBASEPRI;
 1185              		.loc 2 265 0
 1186 0034 3B69     		ldr	r3, [r7, #16]
 1187              	.LBE21:
 1188              	.LBE20:
1685:../src/RTOS/tasks.c **** 
1686:../src/RTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1189              		.loc 1 1686 0
 1190 0036 7B61     		str	r3, [r7, #20]
1687:../src/RTOS/tasks.c **** 		{
1688:../src/RTOS/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1191              		.loc 1 1688 0
 1192 0038 B869     		ldr	r0, [r7, #24]
 1193 003a FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1194 003e 0346     		mov	r3, r0
 1195 0040 002B     		cmp	r3, #0
 1196 0042 30D0     		beq	.L82
1689:../src/RTOS/tasks.c **** 			{
1690:../src/RTOS/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1691:../src/RTOS/tasks.c **** 
1692:../src/RTOS/tasks.c **** 				/* Check the ready lists can be accessed. */
1693:../src/RTOS/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1197              		.loc 1 1693 0
 1198 0044 1D4B     		ldr	r3, .L88
 1199 0046 1B68     		ldr	r3, [r3]
 1200 0048 002B     		cmp	r3, #0
 1201 004a 26D1     		bne	.L83
1694:../src/RTOS/tasks.c **** 				{
1695:../src/RTOS/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1696:../src/RTOS/tasks.c **** 					suspended list to the ready list directly. */
1697:../src/RTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1202              		.loc 1 1697 0
 1203 004c BB69     		ldr	r3, [r7, #24]
 1204 004e DA6A     		ldr	r2, [r3, #44]
 1205 0050 1B4B     		ldr	r3, .L88+4
 1206 0052 1B68     		ldr	r3, [r3]
 1207 0054 DB6A     		ldr	r3, [r3, #44]
 1208 0056 9A42     		cmp	r2, r3
 1209 0058 01D3     		bcc	.L84
1698:../src/RTOS/tasks.c **** 					{
1699:../src/RTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 1210              		.loc 1 1699 0
 1211 005a 0123     		movs	r3, #1
 1212 005c FB61     		str	r3, [r7, #28]
 1213              	.L84:
1700:../src/RTOS/tasks.c **** 					}
1701:../src/RTOS/tasks.c **** 					else
1702:../src/RTOS/tasks.c **** 					{
1703:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1704:../src/RTOS/tasks.c **** 					}
1705:../src/RTOS/tasks.c **** 
1706:../src/RTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1214              		.loc 1 1706 0
 1215 005e BB69     		ldr	r3, [r7, #24]
 1216 0060 0433     		adds	r3, r3, #4
 1217 0062 1846     		mov	r0, r3
 1218 0064 FFF7FEFF 		bl	uxListRemove
1707:../src/RTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1219              		.loc 1 1707 0
 1220 0068 BB69     		ldr	r3, [r7, #24]
 1221 006a DA6A     		ldr	r2, [r3, #44]
 1222 006c 154B     		ldr	r3, .L88+8
 1223 006e 1B68     		ldr	r3, [r3]
 1224 0070 9A42     		cmp	r2, r3
 1225 0072 03D9     		bls	.L85
 1226              		.loc 1 1707 0 is_stmt 0 discriminator 1
 1227 0074 BB69     		ldr	r3, [r7, #24]
 1228 0076 DB6A     		ldr	r3, [r3, #44]
 1229 0078 124A     		ldr	r2, .L88+8
 1230 007a 1360     		str	r3, [r2]
 1231              	.L85:
 1232              		.loc 1 1707 0 discriminator 3
 1233 007c BB69     		ldr	r3, [r7, #24]
 1234 007e DA6A     		ldr	r2, [r3, #44]
 1235 0080 1346     		mov	r3, r2
 1236 0082 9B00     		lsls	r3, r3, #2
 1237 0084 1344     		add	r3, r3, r2
 1238 0086 9B00     		lsls	r3, r3, #2
 1239 0088 0F4A     		ldr	r2, .L88+12
 1240 008a 1A44     		add	r2, r2, r3
 1241 008c BB69     		ldr	r3, [r7, #24]
 1242 008e 0433     		adds	r3, r3, #4
 1243 0090 1046     		mov	r0, r2
 1244 0092 1946     		mov	r1, r3
 1245 0094 FFF7FEFF 		bl	vListInsertEnd
 1246 0098 05E0     		b	.L82
 1247              	.L83:
1708:../src/RTOS/tasks.c **** 				}
1709:../src/RTOS/tasks.c **** 				else
1710:../src/RTOS/tasks.c **** 				{
1711:../src/RTOS/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1712:../src/RTOS/tasks.c **** 					is held in the pending ready list until the scheduler is
1713:../src/RTOS/tasks.c **** 					unsuspended. */
1714:../src/RTOS/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1248              		.loc 1 1714 0 is_stmt 1
 1249 009a BB69     		ldr	r3, [r7, #24]
 1250 009c 1833     		adds	r3, r3, #24
 1251 009e 0B48     		ldr	r0, .L88+16
 1252 00a0 1946     		mov	r1, r3
 1253 00a2 FFF7FEFF 		bl	vListInsertEnd
 1254              	.L82:
 1255 00a6 7B69     		ldr	r3, [r7, #20]
 1256 00a8 BB60     		str	r3, [r7, #8]
 1257              	.LBB22:
 1258              	.LBB23:
 266:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 267:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** /*-----------------------------------------------------------*/
 268:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 
 269:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 270:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** {
 271:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	__asm volatile
 1259              		.loc 2 271 0
 1260 00aa BB68     		ldr	r3, [r7, #8]
 1261              	@ 271 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 1262 00ac 83F31188 			msr basepri, r3	
 1263              	@ 0 "" 2
 1264              		.thumb
 1265              	.LBE23:
 1266              	.LBE22:
1715:../src/RTOS/tasks.c **** 				}
1716:../src/RTOS/tasks.c **** 			}
1717:../src/RTOS/tasks.c **** 			else
1718:../src/RTOS/tasks.c **** 			{
1719:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1720:../src/RTOS/tasks.c **** 			}
1721:../src/RTOS/tasks.c **** 		}
1722:../src/RTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1723:../src/RTOS/tasks.c **** 
1724:../src/RTOS/tasks.c **** 		return xYieldRequired;
 1267              		.loc 1 1724 0
 1268 00b0 FB69     		ldr	r3, [r7, #28]
1725:../src/RTOS/tasks.c **** 	}
 1269              		.loc 1 1725 0
 1270 00b2 1846     		mov	r0, r3
 1271 00b4 2037     		adds	r7, r7, #32
 1272              		.cfi_def_cfa_offset 8
 1273 00b6 BD46     		mov	sp, r7
 1274              		.cfi_def_cfa_register 13
 1275              		@ sp needed
 1276 00b8 80BD     		pop	{r7, pc}
 1277              	.L89:
 1278 00ba 00BF     		.align	2
 1279              	.L88:
 1280 00bc 00000000 		.word	uxSchedulerSuspended
 1281 00c0 00000000 		.word	pxCurrentTCB
 1282 00c4 00000000 		.word	uxTopReadyPriority
 1283 00c8 00000000 		.word	pxReadyTasksLists
 1284 00cc 00000000 		.word	xPendingReadyList
 1285              		.cfi_endproc
 1286              	.LFE12:
 1288              		.section	.rodata
 1289              		.align	2
 1290              	.LC0:
 1291 0000 49444C45 		.ascii	"IDLE\000"
 1291      00
 1292 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1293              		.align	2
 1294              		.global	vTaskStartScheduler
 1295              		.thumb
 1296              		.thumb_func
 1298              	vTaskStartScheduler:
 1299              	.LFB13:
1726:../src/RTOS/tasks.c **** 
1727:../src/RTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1728:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1729:../src/RTOS/tasks.c **** 
1730:../src/RTOS/tasks.c **** void vTaskStartScheduler( void )
1731:../src/RTOS/tasks.c **** {
 1300              		.loc 1 1731 0
 1301              		.cfi_startproc
 1302              		@ args = 0, pretend = 0, frame = 16
 1303              		@ frame_needed = 1, uses_anonymous_args = 0
 1304 0000 80B5     		push	{r7, lr}
 1305              		.cfi_def_cfa_offset 8
 1306              		.cfi_offset 7, -8
 1307              		.cfi_offset 14, -4
 1308 0002 86B0     		sub	sp, sp, #24
 1309              		.cfi_def_cfa_offset 32
 1310 0004 02AF     		add	r7, sp, #8
 1311              		.cfi_def_cfa 7, 24
1732:../src/RTOS/tasks.c **** BaseType_t xReturn;
1733:../src/RTOS/tasks.c **** uint16_t usIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 1312              		.loc 1 1733 0
 1313 0006 8223     		movs	r3, #130
 1314 0008 FB81     		strh	r3, [r7, #14]	@ movhi
1734:../src/RTOS/tasks.c **** 
1735:../src/RTOS/tasks.c **** 	/* Add the idle task at the lowest priority. */
1736:../src/RTOS/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1737:../src/RTOS/tasks.c **** 	{
1738:../src/RTOS/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1739:../src/RTOS/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1740:../src/RTOS/tasks.c **** 
1741:../src/RTOS/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1742:../src/RTOS/tasks.c **** 		address of the RAM then create the idle task. */
1743:../src/RTOS/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &usIdleTaskStackSize
1744:../src/RTOS/tasks.c **** 		xReturn = xTaskCreateStatic( prvIdleTask, "IDLE", usIdleTaskStackSize, ( void * ) NULL, ( tskIDLE
1745:../src/RTOS/tasks.c **** 	}
1746:../src/RTOS/tasks.c **** 	#else
1747:../src/RTOS/tasks.c **** 	{
1748:../src/RTOS/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1749:../src/RTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", usIdleTaskStackSize, ( void * ) NULL, ( tskIDLE_PRIOR
 1315              		.loc 1 1749 0
 1316 000a FA89     		ldrh	r2, [r7, #14]
 1317 000c 0023     		movs	r3, #0
 1318 000e 0093     		str	r3, [sp]
 1319 0010 134B     		ldr	r3, .L94
 1320 0012 0193     		str	r3, [sp, #4]
 1321 0014 1348     		ldr	r0, .L94+4
 1322 0016 1449     		ldr	r1, .L94+8
 1323 0018 0023     		movs	r3, #0
 1324 001a FFF7FEFF 		bl	xTaskCreate
 1325 001e B860     		str	r0, [r7, #8]
1750:../src/RTOS/tasks.c **** 	}
1751:../src/RTOS/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1752:../src/RTOS/tasks.c **** 
1753:../src/RTOS/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1754:../src/RTOS/tasks.c **** 	{
1755:../src/RTOS/tasks.c **** 		if( xReturn == pdPASS )
1756:../src/RTOS/tasks.c **** 		{
1757:../src/RTOS/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1758:../src/RTOS/tasks.c **** 		}
1759:../src/RTOS/tasks.c **** 		else
1760:../src/RTOS/tasks.c **** 		{
1761:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1762:../src/RTOS/tasks.c **** 		}
1763:../src/RTOS/tasks.c **** 	}
1764:../src/RTOS/tasks.c **** 	#endif /* configUSE_TIMERS */
1765:../src/RTOS/tasks.c **** 
1766:../src/RTOS/tasks.c **** 	if( xReturn == pdPASS )
 1326              		.loc 1 1766 0
 1327 0020 BB68     		ldr	r3, [r7, #8]
 1328 0022 012B     		cmp	r3, #1
 1329 0024 15D1     		bne	.L91
 1330              	.LBB24:
 1331              	.LBB25:
 237:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 1332              		.loc 2 237 0
 1333              	@ 237 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 1334 0026 4FF0BF03 			mov r3, #191												
 1335 002a 83F31188 		msr basepri, r3											
 1336 002e BFF36F8F 		isb														
 1337 0032 BFF34F8F 		dsb														
 1338              	
 1339              	@ 0 "" 2
 1340              		.thumb
 1341 0036 7B60     		str	r3, [r7, #4]
 1342              	.LBE25:
 1343              	.LBE24:
1767:../src/RTOS/tasks.c **** 	{
1768:../src/RTOS/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1769:../src/RTOS/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1770:../src/RTOS/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1771:../src/RTOS/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1772:../src/RTOS/tasks.c **** 		starts to run. */
1773:../src/RTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
1774:../src/RTOS/tasks.c **** 
1775:../src/RTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1776:../src/RTOS/tasks.c **** 		{
1777:../src/RTOS/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1778:../src/RTOS/tasks.c **** 			structure specific to the task that will run first. */
1779:../src/RTOS/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1780:../src/RTOS/tasks.c **** 		}
1781:../src/RTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1782:../src/RTOS/tasks.c **** 
1783:../src/RTOS/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 1344              		.loc 1 1783 0
 1345 0038 0C4B     		ldr	r3, .L94+12
 1346 003a 4FF0FF32 		mov	r2, #-1
 1347 003e 1A60     		str	r2, [r3]
1784:../src/RTOS/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1348              		.loc 1 1784 0
 1349 0040 0B4B     		ldr	r3, .L94+16
 1350 0042 0122     		movs	r2, #1
 1351 0044 1A60     		str	r2, [r3]
1785:../src/RTOS/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1352              		.loc 1 1785 0
 1353 0046 0B4B     		ldr	r3, .L94+20
 1354 0048 0022     		movs	r2, #0
 1355 004a 1A60     		str	r2, [r3]
1786:../src/RTOS/tasks.c **** 
1787:../src/RTOS/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1788:../src/RTOS/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1789:../src/RTOS/tasks.c **** 		the run time counter time base. */
1790:../src/RTOS/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1791:../src/RTOS/tasks.c **** 
1792:../src/RTOS/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1793:../src/RTOS/tasks.c **** 		portable interface. */
1794:../src/RTOS/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1356              		.loc 1 1794 0
 1357 004c FFF7FEFF 		bl	xPortStartScheduler
 1358 0050 03E0     		b	.L90
 1359              	.L91:
1795:../src/RTOS/tasks.c **** 		{
1796:../src/RTOS/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1797:../src/RTOS/tasks.c **** 			function will not return. */
1798:../src/RTOS/tasks.c **** 		}
1799:../src/RTOS/tasks.c **** 		else
1800:../src/RTOS/tasks.c **** 		{
1801:../src/RTOS/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1802:../src/RTOS/tasks.c **** 		}
1803:../src/RTOS/tasks.c **** 	}
1804:../src/RTOS/tasks.c **** 	else
1805:../src/RTOS/tasks.c **** 	{
1806:../src/RTOS/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1807:../src/RTOS/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1808:../src/RTOS/tasks.c **** 		or the timer task. */
1809:../src/RTOS/tasks.c **** 		configASSERT( xReturn );
 1360              		.loc 1 1809 0
 1361 0052 BB68     		ldr	r3, [r7, #8]
 1362 0054 002B     		cmp	r3, #0
 1363 0056 00D1     		bne	.L90
 1364              	.L93:
 1365              		.loc 1 1809 0 is_stmt 0 discriminator 2
 1366 0058 FEE7     		b	.L93
 1367              	.L90:
1810:../src/RTOS/tasks.c **** 	}
1811:../src/RTOS/tasks.c **** 
1812:../src/RTOS/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
1813:../src/RTOS/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
1814:../src/RTOS/tasks.c **** 	( void ) xIdleTaskHandle;
1815:../src/RTOS/tasks.c **** }
 1368              		.loc 1 1815 0 is_stmt 1
 1369 005a 1037     		adds	r7, r7, #16
 1370              		.cfi_def_cfa_offset 8
 1371 005c BD46     		mov	sp, r7
 1372              		.cfi_def_cfa_register 13
 1373              		@ sp needed
 1374 005e 80BD     		pop	{r7, pc}
 1375              	.L95:
 1376              		.align	2
 1377              	.L94:
 1378 0060 00000000 		.word	xIdleTaskHandle
 1379 0064 00000000 		.word	prvIdleTask
 1380 0068 00000000 		.word	.LC0
 1381 006c 00000000 		.word	xNextTaskUnblockTime
 1382 0070 00000000 		.word	xSchedulerRunning
 1383 0074 00000000 		.word	xTickCount
 1384              		.cfi_endproc
 1385              	.LFE13:
 1387              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1388              		.align	2
 1389              		.global	vTaskEndScheduler
 1390              		.thumb
 1391              		.thumb_func
 1393              	vTaskEndScheduler:
 1394              	.LFB14:
1816:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
1817:../src/RTOS/tasks.c **** 
1818:../src/RTOS/tasks.c **** void vTaskEndScheduler( void )
1819:../src/RTOS/tasks.c **** {
 1395              		.loc 1 1819 0
 1396              		.cfi_startproc
 1397              		@ args = 0, pretend = 0, frame = 8
 1398              		@ frame_needed = 1, uses_anonymous_args = 0
 1399 0000 80B5     		push	{r7, lr}
 1400              		.cfi_def_cfa_offset 8
 1401              		.cfi_offset 7, -8
 1402              		.cfi_offset 14, -4
 1403 0002 82B0     		sub	sp, sp, #8
 1404              		.cfi_def_cfa_offset 16
 1405 0004 00AF     		add	r7, sp, #0
 1406              		.cfi_def_cfa_register 7
 1407              	.LBB26:
 1408              	.LBB27:
 237:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 1409              		.loc 2 237 0
 1410              	@ 237 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 1411 0006 4FF0BF03 			mov r3, #191												
 1412 000a 83F31188 		msr basepri, r3											
 1413 000e BFF36F8F 		isb														
 1414 0012 BFF34F8F 		dsb														
 1415              	
 1416              	@ 0 "" 2
 1417              		.thumb
 1418 0016 7B60     		str	r3, [r7, #4]
 1419              	.LBE27:
 1420              	.LBE26:
1820:../src/RTOS/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1821:../src/RTOS/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1822:../src/RTOS/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1823:../src/RTOS/tasks.c **** 	portDISABLE_INTERRUPTS();
1824:../src/RTOS/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1421              		.loc 1 1824 0
 1422 0018 034B     		ldr	r3, .L97
 1423 001a 0022     		movs	r2, #0
 1424 001c 1A60     		str	r2, [r3]
1825:../src/RTOS/tasks.c **** 	vPortEndScheduler();
 1425              		.loc 1 1825 0
 1426 001e FFF7FEFF 		bl	vPortEndScheduler
1826:../src/RTOS/tasks.c **** }
 1427              		.loc 1 1826 0
 1428 0022 0837     		adds	r7, r7, #8
 1429              		.cfi_def_cfa_offset 8
 1430 0024 BD46     		mov	sp, r7
 1431              		.cfi_def_cfa_register 13
 1432              		@ sp needed
 1433 0026 80BD     		pop	{r7, pc}
 1434              	.L98:
 1435              		.align	2
 1436              	.L97:
 1437 0028 00000000 		.word	xSchedulerRunning
 1438              		.cfi_endproc
 1439              	.LFE14:
 1441              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1442              		.align	2
 1443              		.global	vTaskSuspendAll
 1444              		.thumb
 1445              		.thumb_func
 1447              	vTaskSuspendAll:
 1448              	.LFB15:
1827:../src/RTOS/tasks.c **** /*----------------------------------------------------------*/
1828:../src/RTOS/tasks.c **** 
1829:../src/RTOS/tasks.c **** void vTaskSuspendAll( void )
1830:../src/RTOS/tasks.c **** {
 1449              		.loc 1 1830 0
 1450              		.cfi_startproc
 1451              		@ args = 0, pretend = 0, frame = 0
 1452              		@ frame_needed = 1, uses_anonymous_args = 0
 1453              		@ link register save eliminated.
 1454 0000 80B4     		push	{r7}
 1455              		.cfi_def_cfa_offset 4
 1456              		.cfi_offset 7, -4
 1457 0002 00AF     		add	r7, sp, #0
 1458              		.cfi_def_cfa_register 7
1831:../src/RTOS/tasks.c **** 	/* A critical section is not required as the variable is of type
1832:../src/RTOS/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
1833:../src/RTOS/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
1834:../src/RTOS/tasks.c **** 	http://goo.gl/wu4acr */
1835:../src/RTOS/tasks.c **** 	++uxSchedulerSuspended;
 1459              		.loc 1 1835 0
 1460 0004 044B     		ldr	r3, .L100
 1461 0006 1B68     		ldr	r3, [r3]
 1462 0008 0133     		adds	r3, r3, #1
 1463 000a 034A     		ldr	r2, .L100
 1464 000c 1360     		str	r3, [r2]
1836:../src/RTOS/tasks.c **** }
 1465              		.loc 1 1836 0
 1466 000e BD46     		mov	sp, r7
 1467              		.cfi_def_cfa_register 13
 1468              		@ sp needed
 1469 0010 5DF8047B 		ldr	r7, [sp], #4
 1470              		.cfi_restore 7
 1471              		.cfi_def_cfa_offset 0
 1472 0014 7047     		bx	lr
 1473              	.L101:
 1474 0016 00BF     		.align	2
 1475              	.L100:
 1476 0018 00000000 		.word	uxSchedulerSuspended
 1477              		.cfi_endproc
 1478              	.LFE15:
 1480              		.section	.text.xTaskResumeAll,"ax",%progbits
 1481              		.align	2
 1482              		.global	xTaskResumeAll
 1483              		.thumb
 1484              		.thumb_func
 1486              	xTaskResumeAll:
 1487              	.LFB16:
1837:../src/RTOS/tasks.c **** /*----------------------------------------------------------*/
1838:../src/RTOS/tasks.c **** 
1839:../src/RTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1840:../src/RTOS/tasks.c **** 
1841:../src/RTOS/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
1842:../src/RTOS/tasks.c **** 	{
1843:../src/RTOS/tasks.c **** 	TickType_t xReturn;
1844:../src/RTOS/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
1845:../src/RTOS/tasks.c **** 
1846:../src/RTOS/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
1847:../src/RTOS/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
1848:../src/RTOS/tasks.c **** 		task that are in the Ready state, even though the idle task is
1849:../src/RTOS/tasks.c **** 		running. */
1850:../src/RTOS/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
1851:../src/RTOS/tasks.c **** 		{
1852:../src/RTOS/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
1853:../src/RTOS/tasks.c **** 			{
1854:../src/RTOS/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
1855:../src/RTOS/tasks.c **** 			}
1856:../src/RTOS/tasks.c **** 		}
1857:../src/RTOS/tasks.c **** 		#else
1858:../src/RTOS/tasks.c **** 		{
1859:../src/RTOS/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
1860:../src/RTOS/tasks.c **** 
1861:../src/RTOS/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
1862:../src/RTOS/tasks.c **** 			variable is used as a bit map.  If bits other than the least
1863:../src/RTOS/tasks.c **** 			significant bit are set then there are tasks that have a priority
1864:../src/RTOS/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
1865:../src/RTOS/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
1866:../src/RTOS/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
1867:../src/RTOS/tasks.c **** 			{
1868:../src/RTOS/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
1869:../src/RTOS/tasks.c **** 			}
1870:../src/RTOS/tasks.c **** 		}
1871:../src/RTOS/tasks.c **** 		#endif
1872:../src/RTOS/tasks.c **** 
1873:../src/RTOS/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1874:../src/RTOS/tasks.c **** 		{
1875:../src/RTOS/tasks.c **** 			xReturn = 0;
1876:../src/RTOS/tasks.c **** 		}
1877:../src/RTOS/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1878:../src/RTOS/tasks.c **** 		{
1879:../src/RTOS/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1880:../src/RTOS/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1881:../src/RTOS/tasks.c **** 			processed. */
1882:../src/RTOS/tasks.c **** 			xReturn = 0;
1883:../src/RTOS/tasks.c **** 		}
1884:../src/RTOS/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
1885:../src/RTOS/tasks.c **** 		{
1886:../src/RTOS/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
1887:../src/RTOS/tasks.c **** 			idle priority.  This path can only be reached if
1888:../src/RTOS/tasks.c **** 			configUSE_PREEMPTION is 0. */
1889:../src/RTOS/tasks.c **** 			xReturn = 0;
1890:../src/RTOS/tasks.c **** 		}
1891:../src/RTOS/tasks.c **** 		else
1892:../src/RTOS/tasks.c **** 		{
1893:../src/RTOS/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1894:../src/RTOS/tasks.c **** 		}
1895:../src/RTOS/tasks.c **** 
1896:../src/RTOS/tasks.c **** 		return xReturn;
1897:../src/RTOS/tasks.c **** 	}
1898:../src/RTOS/tasks.c **** 
1899:../src/RTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1900:../src/RTOS/tasks.c **** /*----------------------------------------------------------*/
1901:../src/RTOS/tasks.c **** 
1902:../src/RTOS/tasks.c **** BaseType_t xTaskResumeAll( void )
1903:../src/RTOS/tasks.c **** {
 1488              		.loc 1 1903 0
 1489              		.cfi_startproc
 1490              		@ args = 0, pretend = 0, frame = 16
 1491              		@ frame_needed = 1, uses_anonymous_args = 0
 1492 0000 80B5     		push	{r7, lr}
 1493              		.cfi_def_cfa_offset 8
 1494              		.cfi_offset 7, -8
 1495              		.cfi_offset 14, -4
 1496 0002 84B0     		sub	sp, sp, #16
 1497              		.cfi_def_cfa_offset 24
 1498 0004 00AF     		add	r7, sp, #0
 1499              		.cfi_def_cfa_register 7
1904:../src/RTOS/tasks.c **** TCB_t *pxTCB = NULL;
 1500              		.loc 1 1904 0
 1501 0006 0023     		movs	r3, #0
 1502 0008 FB60     		str	r3, [r7, #12]
1905:../src/RTOS/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 1503              		.loc 1 1905 0
 1504 000a 0023     		movs	r3, #0
 1505 000c BB60     		str	r3, [r7, #8]
1906:../src/RTOS/tasks.c **** 
1907:../src/RTOS/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1908:../src/RTOS/tasks.c **** 	previous call to vTaskSuspendAll(). */
1909:../src/RTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 1506              		.loc 1 1909 0
 1507 000e 3D4B     		ldr	r3, .L114
 1508 0010 1B68     		ldr	r3, [r3]
 1509 0012 002B     		cmp	r3, #0
 1510 0014 00D1     		bne	.L103
 1511              	.L104:
 1512              		.loc 1 1909 0 is_stmt 0 discriminator 1
 1513 0016 FEE7     		b	.L104
 1514              	.L103:
1910:../src/RTOS/tasks.c **** 
1911:../src/RTOS/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1912:../src/RTOS/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1913:../src/RTOS/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1914:../src/RTOS/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1915:../src/RTOS/tasks.c **** 	tasks from this list into their appropriate ready list. */
1916:../src/RTOS/tasks.c **** 	taskENTER_CRITICAL();
 1515              		.loc 1 1916 0 is_stmt 1
 1516 0018 FFF7FEFF 		bl	vPortEnterCritical
1917:../src/RTOS/tasks.c **** 	{
1918:../src/RTOS/tasks.c **** 		--uxSchedulerSuspended;
 1517              		.loc 1 1918 0
 1518 001c 394B     		ldr	r3, .L114
 1519 001e 1B68     		ldr	r3, [r3]
 1520 0020 013B     		subs	r3, r3, #1
 1521 0022 384A     		ldr	r2, .L114
 1522 0024 1360     		str	r3, [r2]
1919:../src/RTOS/tasks.c **** 
1920:../src/RTOS/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1523              		.loc 1 1920 0
 1524 0026 374B     		ldr	r3, .L114
 1525 0028 1B68     		ldr	r3, [r3]
 1526 002a 002B     		cmp	r3, #0
 1527 002c 62D1     		bne	.L105
1921:../src/RTOS/tasks.c **** 		{
1922:../src/RTOS/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 1528              		.loc 1 1922 0
 1529 002e 364B     		ldr	r3, .L114+4
 1530 0030 1B68     		ldr	r3, [r3]
 1531 0032 002B     		cmp	r3, #0
 1532 0034 5ED0     		beq	.L105
1923:../src/RTOS/tasks.c **** 			{
1924:../src/RTOS/tasks.c **** 				/* Move any readied tasks from the pending list into the
1925:../src/RTOS/tasks.c **** 				appropriate ready list. */
1926:../src/RTOS/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1533              		.loc 1 1926 0
 1534 0036 2FE0     		b	.L106
 1535              	.L108:
1927:../src/RTOS/tasks.c **** 				{
1928:../src/RTOS/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 1536              		.loc 1 1928 0
 1537 0038 344B     		ldr	r3, .L114+8
 1538 003a DB68     		ldr	r3, [r3, #12]
 1539 003c DB68     		ldr	r3, [r3, #12]
 1540 003e FB60     		str	r3, [r7, #12]
1929:../src/RTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1541              		.loc 1 1929 0
 1542 0040 FB68     		ldr	r3, [r7, #12]
 1543 0042 1833     		adds	r3, r3, #24
 1544 0044 1846     		mov	r0, r3
 1545 0046 FFF7FEFF 		bl	uxListRemove
1930:../src/RTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1546              		.loc 1 1930 0
 1547 004a FB68     		ldr	r3, [r7, #12]
 1548 004c 0433     		adds	r3, r3, #4
 1549 004e 1846     		mov	r0, r3
 1550 0050 FFF7FEFF 		bl	uxListRemove
1931:../src/RTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1551              		.loc 1 1931 0
 1552 0054 FB68     		ldr	r3, [r7, #12]
 1553 0056 DA6A     		ldr	r2, [r3, #44]
 1554 0058 2D4B     		ldr	r3, .L114+12
 1555 005a 1B68     		ldr	r3, [r3]
 1556 005c 9A42     		cmp	r2, r3
 1557 005e 03D9     		bls	.L107
 1558              		.loc 1 1931 0 is_stmt 0 discriminator 1
 1559 0060 FB68     		ldr	r3, [r7, #12]
 1560 0062 DB6A     		ldr	r3, [r3, #44]
 1561 0064 2A4A     		ldr	r2, .L114+12
 1562 0066 1360     		str	r3, [r2]
 1563              	.L107:
 1564              		.loc 1 1931 0 discriminator 3
 1565 0068 FB68     		ldr	r3, [r7, #12]
 1566 006a DA6A     		ldr	r2, [r3, #44]
 1567 006c 1346     		mov	r3, r2
 1568 006e 9B00     		lsls	r3, r3, #2
 1569 0070 1344     		add	r3, r3, r2
 1570 0072 9B00     		lsls	r3, r3, #2
 1571 0074 274A     		ldr	r2, .L114+16
 1572 0076 1A44     		add	r2, r2, r3
 1573 0078 FB68     		ldr	r3, [r7, #12]
 1574 007a 0433     		adds	r3, r3, #4
 1575 007c 1046     		mov	r0, r2
 1576 007e 1946     		mov	r1, r3
 1577 0080 FFF7FEFF 		bl	vListInsertEnd
1932:../src/RTOS/tasks.c **** 
1933:../src/RTOS/tasks.c **** 					/* If the moved task has a priority higher than the current
1934:../src/RTOS/tasks.c **** 					task then a yield must be performed. */
1935:../src/RTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1578              		.loc 1 1935 0 is_stmt 1 discriminator 3
 1579 0084 FB68     		ldr	r3, [r7, #12]
 1580 0086 DA6A     		ldr	r2, [r3, #44]
 1581 0088 234B     		ldr	r3, .L114+20
 1582 008a 1B68     		ldr	r3, [r3]
 1583 008c DB6A     		ldr	r3, [r3, #44]
 1584 008e 9A42     		cmp	r2, r3
 1585 0090 02D3     		bcc	.L106
1936:../src/RTOS/tasks.c **** 					{
1937:../src/RTOS/tasks.c **** 						xYieldPending = pdTRUE;
 1586              		.loc 1 1937 0
 1587 0092 224B     		ldr	r3, .L114+24
 1588 0094 0122     		movs	r2, #1
 1589 0096 1A60     		str	r2, [r3]
 1590              	.L106:
1926:../src/RTOS/tasks.c **** 				{
 1591              		.loc 1 1926 0
 1592 0098 1C4B     		ldr	r3, .L114+8
 1593 009a 1B68     		ldr	r3, [r3]
 1594 009c 002B     		cmp	r3, #0
 1595 009e CBD1     		bne	.L108
1938:../src/RTOS/tasks.c **** 					}
1939:../src/RTOS/tasks.c **** 					else
1940:../src/RTOS/tasks.c **** 					{
1941:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1942:../src/RTOS/tasks.c **** 					}
1943:../src/RTOS/tasks.c **** 				}
1944:../src/RTOS/tasks.c **** 
1945:../src/RTOS/tasks.c **** 				if( pxTCB != NULL )
 1596              		.loc 1 1945 0
 1597 00a0 FB68     		ldr	r3, [r7, #12]
 1598 00a2 002B     		cmp	r3, #0
 1599 00a4 01D0     		beq	.L109
1946:../src/RTOS/tasks.c **** 				{
1947:../src/RTOS/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
1948:../src/RTOS/tasks.c **** 					which may have prevented the next unblock time from being
1949:../src/RTOS/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
1950:../src/RTOS/tasks.c **** 					important for low power tickless implementations, where
1951:../src/RTOS/tasks.c **** 					this can prevent an unnecessary exit from low power
1952:../src/RTOS/tasks.c **** 					state. */
1953:../src/RTOS/tasks.c **** 					prvResetNextTaskUnblockTime();
 1600              		.loc 1 1953 0
 1601 00a6 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 1602              	.L109:
 1603              	.LBB28:
1954:../src/RTOS/tasks.c **** 				}
1955:../src/RTOS/tasks.c **** 
1956:../src/RTOS/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1957:../src/RTOS/tasks.c **** 				they should be processed now.  This ensures the tick count does
1958:../src/RTOS/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
1959:../src/RTOS/tasks.c **** 				time. */
1960:../src/RTOS/tasks.c **** 				{
1961:../src/RTOS/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 1604              		.loc 1 1961 0
 1605 00aa 1D4B     		ldr	r3, .L114+28
 1606 00ac 1B68     		ldr	r3, [r3]
 1607 00ae 7B60     		str	r3, [r7, #4]
1962:../src/RTOS/tasks.c **** 
1963:../src/RTOS/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
 1608              		.loc 1 1963 0
 1609 00b0 7B68     		ldr	r3, [r7, #4]
 1610 00b2 002B     		cmp	r3, #0
 1611 00b4 10D0     		beq	.L110
 1612              	.L112:
1964:../src/RTOS/tasks.c **** 					{
1965:../src/RTOS/tasks.c **** 						do
1966:../src/RTOS/tasks.c **** 						{
1967:../src/RTOS/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
 1613              		.loc 1 1967 0
 1614 00b6 FFF7FEFF 		bl	xTaskIncrementTick
 1615 00ba 0346     		mov	r3, r0
 1616 00bc 002B     		cmp	r3, #0
 1617 00be 02D0     		beq	.L111
1968:../src/RTOS/tasks.c **** 							{
1969:../src/RTOS/tasks.c **** 								xYieldPending = pdTRUE;
 1618              		.loc 1 1969 0
 1619 00c0 164B     		ldr	r3, .L114+24
 1620 00c2 0122     		movs	r2, #1
 1621 00c4 1A60     		str	r2, [r3]
 1622              	.L111:
1970:../src/RTOS/tasks.c **** 							}
1971:../src/RTOS/tasks.c **** 							else
1972:../src/RTOS/tasks.c **** 							{
1973:../src/RTOS/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
1974:../src/RTOS/tasks.c **** 							}
1975:../src/RTOS/tasks.c **** 							--uxPendedCounts;
 1623              		.loc 1 1975 0
 1624 00c6 7B68     		ldr	r3, [r7, #4]
 1625 00c8 013B     		subs	r3, r3, #1
 1626 00ca 7B60     		str	r3, [r7, #4]
1976:../src/RTOS/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 1627              		.loc 1 1976 0
 1628 00cc 7B68     		ldr	r3, [r7, #4]
 1629 00ce 002B     		cmp	r3, #0
 1630 00d0 F1D1     		bne	.L112
1977:../src/RTOS/tasks.c **** 
1978:../src/RTOS/tasks.c **** 						uxPendedTicks = 0;
 1631              		.loc 1 1978 0
 1632 00d2 134B     		ldr	r3, .L114+28
 1633 00d4 0022     		movs	r2, #0
 1634 00d6 1A60     		str	r2, [r3]
 1635              	.L110:
 1636              	.LBE28:
1979:../src/RTOS/tasks.c **** 					}
1980:../src/RTOS/tasks.c **** 					else
1981:../src/RTOS/tasks.c **** 					{
1982:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1983:../src/RTOS/tasks.c **** 					}
1984:../src/RTOS/tasks.c **** 				}
1985:../src/RTOS/tasks.c **** 
1986:../src/RTOS/tasks.c **** 				if( xYieldPending != pdFALSE )
 1637              		.loc 1 1986 0
 1638 00d8 104B     		ldr	r3, .L114+24
 1639 00da 1B68     		ldr	r3, [r3]
 1640 00dc 002B     		cmp	r3, #0
 1641 00de 09D0     		beq	.L105
1987:../src/RTOS/tasks.c **** 				{
1988:../src/RTOS/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
1989:../src/RTOS/tasks.c **** 					{
1990:../src/RTOS/tasks.c **** 						xAlreadyYielded = pdTRUE;
 1642              		.loc 1 1990 0
 1643 00e0 0123     		movs	r3, #1
 1644 00e2 BB60     		str	r3, [r7, #8]
1991:../src/RTOS/tasks.c **** 					}
1992:../src/RTOS/tasks.c **** 					#endif
1993:../src/RTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1645              		.loc 1 1993 0
 1646 00e4 0F4B     		ldr	r3, .L114+32
 1647 00e6 4FF08052 		mov	r2, #268435456
 1648 00ea 1A60     		str	r2, [r3]
 1649              	@ 1993 "../src/RTOS/tasks.c" 1
 1650 00ec BFF34F8F 		dsb
 1651              	@ 0 "" 2
 1652              	@ 1993 "../src/RTOS/tasks.c" 1
 1653 00f0 BFF36F8F 		isb
 1654              	@ 0 "" 2
 1655              		.thumb
 1656              	.L105:
1994:../src/RTOS/tasks.c **** 				}
1995:../src/RTOS/tasks.c **** 				else
1996:../src/RTOS/tasks.c **** 				{
1997:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1998:../src/RTOS/tasks.c **** 				}
1999:../src/RTOS/tasks.c **** 			}
2000:../src/RTOS/tasks.c **** 		}
2001:../src/RTOS/tasks.c **** 		else
2002:../src/RTOS/tasks.c **** 		{
2003:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2004:../src/RTOS/tasks.c **** 		}
2005:../src/RTOS/tasks.c **** 	}
2006:../src/RTOS/tasks.c **** 	taskEXIT_CRITICAL();
 1657              		.loc 1 2006 0
 1658 00f4 FFF7FEFF 		bl	vPortExitCritical
2007:../src/RTOS/tasks.c **** 
2008:../src/RTOS/tasks.c **** 	return xAlreadyYielded;
 1659              		.loc 1 2008 0
 1660 00f8 BB68     		ldr	r3, [r7, #8]
2009:../src/RTOS/tasks.c **** }
 1661              		.loc 1 2009 0
 1662 00fa 1846     		mov	r0, r3
 1663 00fc 1037     		adds	r7, r7, #16
 1664              		.cfi_def_cfa_offset 8
 1665 00fe BD46     		mov	sp, r7
 1666              		.cfi_def_cfa_register 13
 1667              		@ sp needed
 1668 0100 80BD     		pop	{r7, pc}
 1669              	.L115:
 1670 0102 00BF     		.align	2
 1671              	.L114:
 1672 0104 00000000 		.word	uxSchedulerSuspended
 1673 0108 00000000 		.word	uxCurrentNumberOfTasks
 1674 010c 00000000 		.word	xPendingReadyList
 1675 0110 00000000 		.word	uxTopReadyPriority
 1676 0114 00000000 		.word	pxReadyTasksLists
 1677 0118 00000000 		.word	pxCurrentTCB
 1678 011c 00000000 		.word	xYieldPending
 1679 0120 00000000 		.word	uxPendedTicks
 1680 0124 04ED00E0 		.word	-536810236
 1681              		.cfi_endproc
 1682              	.LFE16:
 1684              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1685              		.align	2
 1686              		.global	xTaskGetTickCount
 1687              		.thumb
 1688              		.thumb_func
 1690              	xTaskGetTickCount:
 1691              	.LFB17:
2010:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2011:../src/RTOS/tasks.c **** 
2012:../src/RTOS/tasks.c **** TickType_t xTaskGetTickCount( void )
2013:../src/RTOS/tasks.c **** {
 1692              		.loc 1 2013 0
 1693              		.cfi_startproc
 1694              		@ args = 0, pretend = 0, frame = 8
 1695              		@ frame_needed = 1, uses_anonymous_args = 0
 1696              		@ link register save eliminated.
 1697 0000 80B4     		push	{r7}
 1698              		.cfi_def_cfa_offset 4
 1699              		.cfi_offset 7, -4
 1700 0002 83B0     		sub	sp, sp, #12
 1701              		.cfi_def_cfa_offset 16
 1702 0004 00AF     		add	r7, sp, #0
 1703              		.cfi_def_cfa_register 7
2014:../src/RTOS/tasks.c **** TickType_t xTicks;
2015:../src/RTOS/tasks.c **** 
2016:../src/RTOS/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2017:../src/RTOS/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2018:../src/RTOS/tasks.c **** 	{
2019:../src/RTOS/tasks.c **** 		xTicks = xTickCount;
 1704              		.loc 1 2019 0
 1705 0006 054B     		ldr	r3, .L118
 1706 0008 1B68     		ldr	r3, [r3]
 1707 000a 7B60     		str	r3, [r7, #4]
2020:../src/RTOS/tasks.c **** 	}
2021:../src/RTOS/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2022:../src/RTOS/tasks.c **** 
2023:../src/RTOS/tasks.c **** 	return xTicks;
 1708              		.loc 1 2023 0
 1709 000c 7B68     		ldr	r3, [r7, #4]
2024:../src/RTOS/tasks.c **** }
 1710              		.loc 1 2024 0
 1711 000e 1846     		mov	r0, r3
 1712 0010 0C37     		adds	r7, r7, #12
 1713              		.cfi_def_cfa_offset 4
 1714 0012 BD46     		mov	sp, r7
 1715              		.cfi_def_cfa_register 13
 1716              		@ sp needed
 1717 0014 5DF8047B 		ldr	r7, [sp], #4
 1718              		.cfi_restore 7
 1719              		.cfi_def_cfa_offset 0
 1720 0018 7047     		bx	lr
 1721              	.L119:
 1722 001a 00BF     		.align	2
 1723              	.L118:
 1724 001c 00000000 		.word	xTickCount
 1725              		.cfi_endproc
 1726              	.LFE17:
 1728              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1729              		.align	2
 1730              		.global	xTaskGetTickCountFromISR
 1731              		.thumb
 1732              		.thumb_func
 1734              	xTaskGetTickCountFromISR:
 1735              	.LFB18:
2025:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2026:../src/RTOS/tasks.c **** 
2027:../src/RTOS/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2028:../src/RTOS/tasks.c **** {
 1736              		.loc 1 2028 0
 1737              		.cfi_startproc
 1738              		@ args = 0, pretend = 0, frame = 8
 1739              		@ frame_needed = 1, uses_anonymous_args = 0
 1740 0000 80B5     		push	{r7, lr}
 1741              		.cfi_def_cfa_offset 8
 1742              		.cfi_offset 7, -8
 1743              		.cfi_offset 14, -4
 1744 0002 82B0     		sub	sp, sp, #8
 1745              		.cfi_def_cfa_offset 16
 1746 0004 00AF     		add	r7, sp, #0
 1747              		.cfi_def_cfa_register 7
2029:../src/RTOS/tasks.c **** TickType_t xReturn;
2030:../src/RTOS/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2031:../src/RTOS/tasks.c **** 
2032:../src/RTOS/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2033:../src/RTOS/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2034:../src/RTOS/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2035:../src/RTOS/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2036:../src/RTOS/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2037:../src/RTOS/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2038:../src/RTOS/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2039:../src/RTOS/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2040:../src/RTOS/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2041:../src/RTOS/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2042:../src/RTOS/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2043:../src/RTOS/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2044:../src/RTOS/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2045:../src/RTOS/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
2046:../src/RTOS/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1748              		.loc 1 2046 0
 1749 0006 FFF7FEFF 		bl	vPortValidateInterruptPriority
2047:../src/RTOS/tasks.c **** 
2048:../src/RTOS/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 1750              		.loc 1 2048 0
 1751 000a 0023     		movs	r3, #0
 1752 000c 7B60     		str	r3, [r7, #4]
2049:../src/RTOS/tasks.c **** 	{
2050:../src/RTOS/tasks.c **** 		xReturn = xTickCount;
 1753              		.loc 1 2050 0
 1754 000e 044B     		ldr	r3, .L122
 1755 0010 1B68     		ldr	r3, [r3]
 1756 0012 3B60     		str	r3, [r7]
2051:../src/RTOS/tasks.c **** 	}
2052:../src/RTOS/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2053:../src/RTOS/tasks.c **** 
2054:../src/RTOS/tasks.c **** 	return xReturn;
 1757              		.loc 1 2054 0
 1758 0014 3B68     		ldr	r3, [r7]
2055:../src/RTOS/tasks.c **** }
 1759              		.loc 1 2055 0
 1760 0016 1846     		mov	r0, r3
 1761 0018 0837     		adds	r7, r7, #8
 1762              		.cfi_def_cfa_offset 8
 1763 001a BD46     		mov	sp, r7
 1764              		.cfi_def_cfa_register 13
 1765              		@ sp needed
 1766 001c 80BD     		pop	{r7, pc}
 1767              	.L123:
 1768 001e 00BF     		.align	2
 1769              	.L122:
 1770 0020 00000000 		.word	xTickCount
 1771              		.cfi_endproc
 1772              	.LFE18:
 1774              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1775              		.align	2
 1776              		.global	uxTaskGetNumberOfTasks
 1777              		.thumb
 1778              		.thumb_func
 1780              	uxTaskGetNumberOfTasks:
 1781              	.LFB19:
2056:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2057:../src/RTOS/tasks.c **** 
2058:../src/RTOS/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2059:../src/RTOS/tasks.c **** {
 1782              		.loc 1 2059 0
 1783              		.cfi_startproc
 1784              		@ args = 0, pretend = 0, frame = 0
 1785              		@ frame_needed = 1, uses_anonymous_args = 0
 1786              		@ link register save eliminated.
 1787 0000 80B4     		push	{r7}
 1788              		.cfi_def_cfa_offset 4
 1789              		.cfi_offset 7, -4
 1790 0002 00AF     		add	r7, sp, #0
 1791              		.cfi_def_cfa_register 7
2060:../src/RTOS/tasks.c **** 	/* A critical section is not required because the variables are of type
2061:../src/RTOS/tasks.c **** 	BaseType_t. */
2062:../src/RTOS/tasks.c **** 	return uxCurrentNumberOfTasks;
 1792              		.loc 1 2062 0
 1793 0004 034B     		ldr	r3, .L126
 1794 0006 1B68     		ldr	r3, [r3]
2063:../src/RTOS/tasks.c **** }
 1795              		.loc 1 2063 0
 1796 0008 1846     		mov	r0, r3
 1797 000a BD46     		mov	sp, r7
 1798              		.cfi_def_cfa_register 13
 1799              		@ sp needed
 1800 000c 5DF8047B 		ldr	r7, [sp], #4
 1801              		.cfi_restore 7
 1802              		.cfi_def_cfa_offset 0
 1803 0010 7047     		bx	lr
 1804              	.L127:
 1805 0012 00BF     		.align	2
 1806              	.L126:
 1807 0014 00000000 		.word	uxCurrentNumberOfTasks
 1808              		.cfi_endproc
 1809              	.LFE19:
 1811              		.section	.text.pcTaskGetName,"ax",%progbits
 1812              		.align	2
 1813              		.global	pcTaskGetName
 1814              		.thumb
 1815              		.thumb_func
 1817              	pcTaskGetName:
 1818              	.LFB20:
2064:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2065:../src/RTOS/tasks.c **** 
2066:../src/RTOS/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2067:../src/RTOS/tasks.c **** {
 1819              		.loc 1 2067 0
 1820              		.cfi_startproc
 1821              		@ args = 0, pretend = 0, frame = 16
 1822              		@ frame_needed = 1, uses_anonymous_args = 0
 1823              		@ link register save eliminated.
 1824 0000 80B4     		push	{r7}
 1825              		.cfi_def_cfa_offset 4
 1826              		.cfi_offset 7, -4
 1827 0002 85B0     		sub	sp, sp, #20
 1828              		.cfi_def_cfa_offset 24
 1829 0004 00AF     		add	r7, sp, #0
 1830              		.cfi_def_cfa_register 7
 1831 0006 7860     		str	r0, [r7, #4]
2068:../src/RTOS/tasks.c **** TCB_t *pxTCB;
2069:../src/RTOS/tasks.c **** 
2070:../src/RTOS/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2071:../src/RTOS/tasks.c **** 	queried. */
2072:../src/RTOS/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 1832              		.loc 1 2072 0
 1833 0008 7B68     		ldr	r3, [r7, #4]
 1834 000a 002B     		cmp	r3, #0
 1835 000c 02D1     		bne	.L129
 1836              		.loc 1 2072 0 is_stmt 0 discriminator 1
 1837 000e 084B     		ldr	r3, .L134
 1838 0010 1B68     		ldr	r3, [r3]
 1839 0012 00E0     		b	.L130
 1840              	.L129:
 1841              		.loc 1 2072 0 discriminator 2
 1842 0014 7B68     		ldr	r3, [r7, #4]
 1843              	.L130:
 1844              		.loc 1 2072 0 discriminator 4
 1845 0016 FB60     		str	r3, [r7, #12]
2073:../src/RTOS/tasks.c **** 	configASSERT( pxTCB );
 1846              		.loc 1 2073 0 is_stmt 1 discriminator 4
 1847 0018 FB68     		ldr	r3, [r7, #12]
 1848 001a 002B     		cmp	r3, #0
 1849 001c 00D1     		bne	.L131
 1850              	.L132:
 1851              		.loc 1 2073 0 is_stmt 0 discriminator 1
 1852 001e FEE7     		b	.L132
 1853              	.L131:
2074:../src/RTOS/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
 1854              		.loc 1 2074 0 is_stmt 1
 1855 0020 FB68     		ldr	r3, [r7, #12]
 1856 0022 3433     		adds	r3, r3, #52
2075:../src/RTOS/tasks.c **** }
 1857              		.loc 1 2075 0
 1858 0024 1846     		mov	r0, r3
 1859 0026 1437     		adds	r7, r7, #20
 1860              		.cfi_def_cfa_offset 4
 1861 0028 BD46     		mov	sp, r7
 1862              		.cfi_def_cfa_register 13
 1863              		@ sp needed
 1864 002a 5DF8047B 		ldr	r7, [sp], #4
 1865              		.cfi_restore 7
 1866              		.cfi_def_cfa_offset 0
 1867 002e 7047     		bx	lr
 1868              	.L135:
 1869              		.align	2
 1870              	.L134:
 1871 0030 00000000 		.word	pxCurrentTCB
 1872              		.cfi_endproc
 1873              	.LFE20:
 1875              		.section	.text.xTaskIncrementTick,"ax",%progbits
 1876              		.align	2
 1877              		.global	xTaskIncrementTick
 1878              		.thumb
 1879              		.thumb_func
 1881              	xTaskIncrementTick:
 1882              	.LFB21:
2076:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2077:../src/RTOS/tasks.c **** 
2078:../src/RTOS/tasks.c **** #if ( INCLUDE_xTaskGetTaskHandle == 1 )
2079:../src/RTOS/tasks.c **** 
2080:../src/RTOS/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2081:../src/RTOS/tasks.c **** 	{
2082:../src/RTOS/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2083:../src/RTOS/tasks.c **** 	UBaseType_t x;
2084:../src/RTOS/tasks.c **** 	char cNextChar;
2085:../src/RTOS/tasks.c **** 
2086:../src/RTOS/tasks.c **** 		/* This function is called with the scheduler suspended. */
2087:../src/RTOS/tasks.c **** 
2088:../src/RTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2089:../src/RTOS/tasks.c **** 		{
2090:../src/RTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2091:../src/RTOS/tasks.c **** 
2092:../src/RTOS/tasks.c **** 			do
2093:../src/RTOS/tasks.c **** 			{
2094:../src/RTOS/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2095:../src/RTOS/tasks.c **** 
2096:../src/RTOS/tasks.c **** 				/* Check each character in the name looking for a match or
2097:../src/RTOS/tasks.c **** 				mismatch. */
2098:../src/RTOS/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2099:../src/RTOS/tasks.c **** 				{
2100:../src/RTOS/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2101:../src/RTOS/tasks.c **** 
2102:../src/RTOS/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2103:../src/RTOS/tasks.c **** 					{
2104:../src/RTOS/tasks.c **** 						/* Characters didn't match. */
2105:../src/RTOS/tasks.c **** 						break;
2106:../src/RTOS/tasks.c **** 					}
2107:../src/RTOS/tasks.c **** 					else if( cNextChar == 0x00 )
2108:../src/RTOS/tasks.c **** 					{
2109:../src/RTOS/tasks.c **** 						/* Both strings terminated, a match must have been
2110:../src/RTOS/tasks.c **** 						found. */
2111:../src/RTOS/tasks.c **** 						pxReturn = pxNextTCB;
2112:../src/RTOS/tasks.c **** 						break;
2113:../src/RTOS/tasks.c **** 					}
2114:../src/RTOS/tasks.c **** 					else
2115:../src/RTOS/tasks.c **** 					{
2116:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2117:../src/RTOS/tasks.c **** 					}
2118:../src/RTOS/tasks.c **** 				}
2119:../src/RTOS/tasks.c **** 
2120:../src/RTOS/tasks.c **** 				if( pxReturn != NULL )
2121:../src/RTOS/tasks.c **** 				{
2122:../src/RTOS/tasks.c **** 					/* The handle has been found. */
2123:../src/RTOS/tasks.c **** 					break;
2124:../src/RTOS/tasks.c **** 				}
2125:../src/RTOS/tasks.c **** 
2126:../src/RTOS/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2127:../src/RTOS/tasks.c **** 		}
2128:../src/RTOS/tasks.c **** 		else
2129:../src/RTOS/tasks.c **** 		{
2130:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2131:../src/RTOS/tasks.c **** 		}
2132:../src/RTOS/tasks.c **** 
2133:../src/RTOS/tasks.c **** 		return pxReturn;
2134:../src/RTOS/tasks.c **** 	}
2135:../src/RTOS/tasks.c **** 
2136:../src/RTOS/tasks.c **** #endif /* INCLUDE_xTaskGetTaskHandle */
2137:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2138:../src/RTOS/tasks.c **** 
2139:../src/RTOS/tasks.c **** #if ( INCLUDE_xTaskGetTaskHandle == 1 )
2140:../src/RTOS/tasks.c **** 
2141:../src/RTOS/tasks.c **** 	TaskHandle_t xTaskGetTaskHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types a
2142:../src/RTOS/tasks.c **** 	{
2143:../src/RTOS/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2144:../src/RTOS/tasks.c **** 	TCB_t* pxTCB;
2145:../src/RTOS/tasks.c **** 
2146:../src/RTOS/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2147:../src/RTOS/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2148:../src/RTOS/tasks.c **** 
2149:../src/RTOS/tasks.c **** 		vTaskSuspendAll();
2150:../src/RTOS/tasks.c **** 		{
2151:../src/RTOS/tasks.c **** 			/* Search the ready lists. */
2152:../src/RTOS/tasks.c **** 			do
2153:../src/RTOS/tasks.c **** 			{
2154:../src/RTOS/tasks.c **** 				uxQueue--;
2155:../src/RTOS/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2156:../src/RTOS/tasks.c **** 
2157:../src/RTOS/tasks.c **** 				if( pxTCB != NULL )
2158:../src/RTOS/tasks.c **** 				{
2159:../src/RTOS/tasks.c **** 					/* Found the handle. */
2160:../src/RTOS/tasks.c **** 					break;
2161:../src/RTOS/tasks.c **** 				}
2162:../src/RTOS/tasks.c **** 
2163:../src/RTOS/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2164:../src/RTOS/tasks.c **** 
2165:../src/RTOS/tasks.c **** 			/* Search the delayed lists. */
2166:../src/RTOS/tasks.c **** 			if( pxTCB == NULL )
2167:../src/RTOS/tasks.c **** 			{
2168:../src/RTOS/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2169:../src/RTOS/tasks.c **** 			}
2170:../src/RTOS/tasks.c **** 
2171:../src/RTOS/tasks.c **** 			if( pxTCB == NULL )
2172:../src/RTOS/tasks.c **** 			{
2173:../src/RTOS/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2174:../src/RTOS/tasks.c **** 			}
2175:../src/RTOS/tasks.c **** 
2176:../src/RTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2177:../src/RTOS/tasks.c **** 			{
2178:../src/RTOS/tasks.c **** 				if( pxTCB == NULL )
2179:../src/RTOS/tasks.c **** 				{
2180:../src/RTOS/tasks.c **** 					/* Search the suspended list. */
2181:../src/RTOS/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2182:../src/RTOS/tasks.c **** 				}
2183:../src/RTOS/tasks.c **** 			}
2184:../src/RTOS/tasks.c **** 			#endif
2185:../src/RTOS/tasks.c **** 
2186:../src/RTOS/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2187:../src/RTOS/tasks.c **** 			{
2188:../src/RTOS/tasks.c **** 				if( pxTCB == NULL )
2189:../src/RTOS/tasks.c **** 				{
2190:../src/RTOS/tasks.c **** 					/* Search the deleted list. */
2191:../src/RTOS/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2192:../src/RTOS/tasks.c **** 				}
2193:../src/RTOS/tasks.c **** 			}
2194:../src/RTOS/tasks.c **** 			#endif
2195:../src/RTOS/tasks.c **** 		}
2196:../src/RTOS/tasks.c **** 		( void ) xTaskResumeAll();
2197:../src/RTOS/tasks.c **** 
2198:../src/RTOS/tasks.c **** 		return ( TaskHandle_t ) pxTCB;
2199:../src/RTOS/tasks.c **** 	}
2200:../src/RTOS/tasks.c **** 
2201:../src/RTOS/tasks.c **** #endif /* INCLUDE_xTaskGetTaskHandle */
2202:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2203:../src/RTOS/tasks.c **** 
2204:../src/RTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2205:../src/RTOS/tasks.c **** 
2206:../src/RTOS/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2207:../src/RTOS/tasks.c **** 	{
2208:../src/RTOS/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2209:../src/RTOS/tasks.c **** 
2210:../src/RTOS/tasks.c **** 		vTaskSuspendAll();
2211:../src/RTOS/tasks.c **** 		{
2212:../src/RTOS/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2213:../src/RTOS/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2214:../src/RTOS/tasks.c **** 			{
2215:../src/RTOS/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2216:../src/RTOS/tasks.c **** 				task in the Ready state. */
2217:../src/RTOS/tasks.c **** 				do
2218:../src/RTOS/tasks.c **** 				{
2219:../src/RTOS/tasks.c **** 					uxQueue--;
2220:../src/RTOS/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2221:../src/RTOS/tasks.c **** 
2222:../src/RTOS/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2223:../src/RTOS/tasks.c **** 
2224:../src/RTOS/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2225:../src/RTOS/tasks.c **** 				task in the Blocked state. */
2226:../src/RTOS/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2227:../src/RTOS/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2228:../src/RTOS/tasks.c **** 
2229:../src/RTOS/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2230:../src/RTOS/tasks.c **** 				{
2231:../src/RTOS/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2232:../src/RTOS/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2233:../src/RTOS/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2234:../src/RTOS/tasks.c **** 				}
2235:../src/RTOS/tasks.c **** 				#endif
2236:../src/RTOS/tasks.c **** 
2237:../src/RTOS/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2238:../src/RTOS/tasks.c **** 				{
2239:../src/RTOS/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2240:../src/RTOS/tasks.c **** 					each task in the Suspended state. */
2241:../src/RTOS/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2242:../src/RTOS/tasks.c **** 				}
2243:../src/RTOS/tasks.c **** 				#endif
2244:../src/RTOS/tasks.c **** 
2245:../src/RTOS/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2246:../src/RTOS/tasks.c **** 				{
2247:../src/RTOS/tasks.c **** 					if( pulTotalRunTime != NULL )
2248:../src/RTOS/tasks.c **** 					{
2249:../src/RTOS/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2250:../src/RTOS/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2251:../src/RTOS/tasks.c **** 						#else
2252:../src/RTOS/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2253:../src/RTOS/tasks.c **** 						#endif
2254:../src/RTOS/tasks.c **** 					}
2255:../src/RTOS/tasks.c **** 				}
2256:../src/RTOS/tasks.c **** 				#else
2257:../src/RTOS/tasks.c **** 				{
2258:../src/RTOS/tasks.c **** 					if( pulTotalRunTime != NULL )
2259:../src/RTOS/tasks.c **** 					{
2260:../src/RTOS/tasks.c **** 						*pulTotalRunTime = 0;
2261:../src/RTOS/tasks.c **** 					}
2262:../src/RTOS/tasks.c **** 				}
2263:../src/RTOS/tasks.c **** 				#endif
2264:../src/RTOS/tasks.c **** 			}
2265:../src/RTOS/tasks.c **** 			else
2266:../src/RTOS/tasks.c **** 			{
2267:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2268:../src/RTOS/tasks.c **** 			}
2269:../src/RTOS/tasks.c **** 		}
2270:../src/RTOS/tasks.c **** 		( void ) xTaskResumeAll();
2271:../src/RTOS/tasks.c **** 
2272:../src/RTOS/tasks.c **** 		return uxTask;
2273:../src/RTOS/tasks.c **** 	}
2274:../src/RTOS/tasks.c **** 
2275:../src/RTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2276:../src/RTOS/tasks.c **** /*----------------------------------------------------------*/
2277:../src/RTOS/tasks.c **** 
2278:../src/RTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2279:../src/RTOS/tasks.c **** 
2280:../src/RTOS/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2281:../src/RTOS/tasks.c **** 	{
2282:../src/RTOS/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2283:../src/RTOS/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2284:../src/RTOS/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2285:../src/RTOS/tasks.c **** 		return xIdleTaskHandle;
2286:../src/RTOS/tasks.c **** 	}
2287:../src/RTOS/tasks.c **** 
2288:../src/RTOS/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2289:../src/RTOS/tasks.c **** /*----------------------------------------------------------*/
2290:../src/RTOS/tasks.c **** 
2291:../src/RTOS/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2292:../src/RTOS/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2293:../src/RTOS/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2294:../src/RTOS/tasks.c **** 1. */
2295:../src/RTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2296:../src/RTOS/tasks.c **** 
2297:../src/RTOS/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2298:../src/RTOS/tasks.c **** 	{
2299:../src/RTOS/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2300:../src/RTOS/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2301:../src/RTOS/tasks.c **** 		each stepped tick. */
2302:../src/RTOS/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2303:../src/RTOS/tasks.c **** 		xTickCount += xTicksToJump;
2304:../src/RTOS/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2305:../src/RTOS/tasks.c **** 	}
2306:../src/RTOS/tasks.c **** 
2307:../src/RTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2308:../src/RTOS/tasks.c **** /*----------------------------------------------------------*/
2309:../src/RTOS/tasks.c **** 
2310:../src/RTOS/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2311:../src/RTOS/tasks.c **** 
2312:../src/RTOS/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2313:../src/RTOS/tasks.c **** 	{
2314:../src/RTOS/tasks.c **** 	TCB_t *pxTCB = ( TCB_t * ) xTask;
2315:../src/RTOS/tasks.c **** 	BaseType_t xReturn = pdFALSE;
2316:../src/RTOS/tasks.c **** 
2317:../src/RTOS/tasks.c **** 		configASSERT( pxTCB );
2318:../src/RTOS/tasks.c **** 
2319:../src/RTOS/tasks.c **** 		vTaskSuspendAll();
2320:../src/RTOS/tasks.c **** 		{
2321:../src/RTOS/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2322:../src/RTOS/tasks.c **** 			it is actually in the Blocked state. */
2323:../src/RTOS/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2324:../src/RTOS/tasks.c **** 			{
2325:../src/RTOS/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2326:../src/RTOS/tasks.c **** 				interrupt won't touch the xStateListItem because the
2327:../src/RTOS/tasks.c **** 				scheduler is suspended. */
2328:../src/RTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2329:../src/RTOS/tasks.c **** 
2330:../src/RTOS/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2331:../src/RTOS/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2332:../src/RTOS/tasks.c **** 				even though the scheduler is suspended, so a critical section
2333:../src/RTOS/tasks.c **** 				is used. */
2334:../src/RTOS/tasks.c **** 				taskENTER_CRITICAL();
2335:../src/RTOS/tasks.c **** 				{
2336:../src/RTOS/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2337:../src/RTOS/tasks.c **** 					{
2338:../src/RTOS/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2339:../src/RTOS/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2340:../src/RTOS/tasks.c **** 					}
2341:../src/RTOS/tasks.c **** 					else
2342:../src/RTOS/tasks.c **** 					{
2343:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2344:../src/RTOS/tasks.c **** 					}
2345:../src/RTOS/tasks.c **** 				}
2346:../src/RTOS/tasks.c **** 				taskEXIT_CRITICAL();
2347:../src/RTOS/tasks.c **** 
2348:../src/RTOS/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2349:../src/RTOS/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2350:../src/RTOS/tasks.c **** 
2351:../src/RTOS/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2352:../src/RTOS/tasks.c **** 				switch if preemption is turned off. */
2353:../src/RTOS/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2354:../src/RTOS/tasks.c **** 				{
2355:../src/RTOS/tasks.c **** 					/* Preemption is on, but a context switch should only be
2356:../src/RTOS/tasks.c **** 					performed if the unblocked task has a priority that is
2357:../src/RTOS/tasks.c **** 					equal to or higher than the currently executing task. */
2358:../src/RTOS/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2359:../src/RTOS/tasks.c **** 					{
2360:../src/RTOS/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2361:../src/RTOS/tasks.c **** 						is unsuspended. */
2362:../src/RTOS/tasks.c **** 						xYieldPending = pdTRUE;
2363:../src/RTOS/tasks.c **** 					}
2364:../src/RTOS/tasks.c **** 					else
2365:../src/RTOS/tasks.c **** 					{
2366:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2367:../src/RTOS/tasks.c **** 					}
2368:../src/RTOS/tasks.c **** 				}
2369:../src/RTOS/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2370:../src/RTOS/tasks.c **** 			}
2371:../src/RTOS/tasks.c **** 			else
2372:../src/RTOS/tasks.c **** 			{
2373:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2374:../src/RTOS/tasks.c **** 			}
2375:../src/RTOS/tasks.c **** 		}
2376:../src/RTOS/tasks.c **** 		xTaskResumeAll();
2377:../src/RTOS/tasks.c **** 
2378:../src/RTOS/tasks.c **** 		return xReturn;
2379:../src/RTOS/tasks.c **** 	}
2380:../src/RTOS/tasks.c **** 
2381:../src/RTOS/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2382:../src/RTOS/tasks.c **** /*----------------------------------------------------------*/
2383:../src/RTOS/tasks.c **** 
2384:../src/RTOS/tasks.c **** BaseType_t xTaskIncrementTick( void )
2385:../src/RTOS/tasks.c **** {
 1883              		.loc 1 2385 0
 1884              		.cfi_startproc
 1885              		@ args = 0, pretend = 0, frame = 24
 1886              		@ frame_needed = 1, uses_anonymous_args = 0
 1887 0000 80B5     		push	{r7, lr}
 1888              		.cfi_def_cfa_offset 8
 1889              		.cfi_offset 7, -8
 1890              		.cfi_offset 14, -4
 1891 0002 86B0     		sub	sp, sp, #24
 1892              		.cfi_def_cfa_offset 32
 1893 0004 00AF     		add	r7, sp, #0
 1894              		.cfi_def_cfa_register 7
2386:../src/RTOS/tasks.c **** TCB_t * pxTCB;
2387:../src/RTOS/tasks.c **** TickType_t xItemValue;
2388:../src/RTOS/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 1895              		.loc 1 2388 0
 1896 0006 0023     		movs	r3, #0
 1897 0008 7B61     		str	r3, [r7, #20]
2389:../src/RTOS/tasks.c **** 
2390:../src/RTOS/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2391:../src/RTOS/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2392:../src/RTOS/tasks.c **** 	tasks to be unblocked. */
2393:../src/RTOS/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2394:../src/RTOS/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1898              		.loc 1 2394 0
 1899 000a 454B     		ldr	r3, .L153
 1900 000c 1B68     		ldr	r3, [r3]
 1901 000e 002B     		cmp	r3, #0
 1902 0010 75D1     		bne	.L137
 1903              	.LBB29:
2395:../src/RTOS/tasks.c **** 	{
2396:../src/RTOS/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2397:../src/RTOS/tasks.c **** 		block. */
2398:../src/RTOS/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + 1;
 1904              		.loc 1 2398 0
 1905 0012 444B     		ldr	r3, .L153+4
 1906 0014 1B68     		ldr	r3, [r3]
 1907 0016 0133     		adds	r3, r3, #1
 1908 0018 3B61     		str	r3, [r7, #16]
2399:../src/RTOS/tasks.c **** 
2400:../src/RTOS/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2401:../src/RTOS/tasks.c **** 		delayed lists if it wraps to 0. */
2402:../src/RTOS/tasks.c **** 		xTickCount = xConstTickCount;
 1909              		.loc 1 2402 0
 1910 001a 424A     		ldr	r2, .L153+4
 1911 001c 3B69     		ldr	r3, [r7, #16]
 1912 001e 1360     		str	r3, [r2]
2403:../src/RTOS/tasks.c **** 
2404:../src/RTOS/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U )
 1913              		.loc 1 2404 0
 1914 0020 3B69     		ldr	r3, [r7, #16]
 1915 0022 002B     		cmp	r3, #0
 1916 0024 16D1     		bne	.L138
 1917              	.LBB30:
2405:../src/RTOS/tasks.c **** 		{
2406:../src/RTOS/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
 1918              		.loc 1 2406 0
 1919 0026 404B     		ldr	r3, .L153+8
 1920 0028 1B68     		ldr	r3, [r3]
 1921 002a 1B68     		ldr	r3, [r3]
 1922 002c 002B     		cmp	r3, #0
 1923 002e 00D0     		beq	.L139
 1924              	.L140:
 1925              		.loc 1 2406 0 is_stmt 0 discriminator 1
 1926 0030 FEE7     		b	.L140
 1927              	.L139:
 1928 0032 3D4B     		ldr	r3, .L153+8
 1929 0034 1B68     		ldr	r3, [r3]
 1930 0036 FB60     		str	r3, [r7, #12]
 1931 0038 3C4B     		ldr	r3, .L153+12
 1932 003a 1B68     		ldr	r3, [r3]
 1933 003c 3A4A     		ldr	r2, .L153+8
 1934 003e 1360     		str	r3, [r2]
 1935 0040 3A4A     		ldr	r2, .L153+12
 1936 0042 FB68     		ldr	r3, [r7, #12]
 1937 0044 1360     		str	r3, [r2]
 1938 0046 3A4B     		ldr	r3, .L153+16
 1939 0048 1B68     		ldr	r3, [r3]
 1940 004a 0133     		adds	r3, r3, #1
 1941 004c 384A     		ldr	r2, .L153+16
 1942 004e 1360     		str	r3, [r2]
 1943 0050 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 1944              	.L138:
 1945              	.LBE30:
2407:../src/RTOS/tasks.c **** 		}
2408:../src/RTOS/tasks.c **** 		else
2409:../src/RTOS/tasks.c **** 		{
2410:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2411:../src/RTOS/tasks.c **** 		}
2412:../src/RTOS/tasks.c **** 
2413:../src/RTOS/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2414:../src/RTOS/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2415:../src/RTOS/tasks.c **** 		has been found whose block time has not expired there is no need to
2416:../src/RTOS/tasks.c **** 		look any further down the list. */
2417:../src/RTOS/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
 1946              		.loc 1 2417 0 is_stmt 1
 1947 0054 374B     		ldr	r3, .L153+20
 1948 0056 1B68     		ldr	r3, [r3]
 1949 0058 3A69     		ldr	r2, [r7, #16]
 1950 005a 9A42     		cmp	r2, r3
 1951 005c 4ED3     		bcc	.L141
 1952              	.L149:
2418:../src/RTOS/tasks.c **** 		{
2419:../src/RTOS/tasks.c **** 			for( ;; )
2420:../src/RTOS/tasks.c **** 			{
2421:../src/RTOS/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1953              		.loc 1 2421 0
 1954 005e 324B     		ldr	r3, .L153+8
 1955 0060 1B68     		ldr	r3, [r3]
 1956 0062 1B68     		ldr	r3, [r3]
 1957 0064 002B     		cmp	r3, #0
 1958 0066 01D1     		bne	.L142
 1959              		.loc 1 2421 0 is_stmt 0 discriminator 1
 1960 0068 0123     		movs	r3, #1
 1961 006a 00E0     		b	.L143
 1962              	.L142:
 1963              		.loc 1 2421 0 discriminator 2
 1964 006c 0023     		movs	r3, #0
 1965              	.L143:
 1966              		.loc 1 2421 0 discriminator 4
 1967 006e 002B     		cmp	r3, #0
 1968 0070 04D0     		beq	.L144
2422:../src/RTOS/tasks.c **** 				{
2423:../src/RTOS/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2424:../src/RTOS/tasks.c **** 					to the maximum possible value so it is extremely
2425:../src/RTOS/tasks.c **** 					unlikely that the
2426:../src/RTOS/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2427:../src/RTOS/tasks.c **** 					next time through. */
2428:../src/RTOS/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
 1969              		.loc 1 2428 0 is_stmt 1
 1970 0072 304B     		ldr	r3, .L153+20
 1971 0074 4FF0FF32 		mov	r2, #-1
 1972 0078 1A60     		str	r2, [r3]
2429:../src/RTOS/tasks.c **** 					break;
 1973              		.loc 1 2429 0
 1974 007a 3FE0     		b	.L141
 1975              	.L144:
2430:../src/RTOS/tasks.c **** 				}
2431:../src/RTOS/tasks.c **** 				else
2432:../src/RTOS/tasks.c **** 				{
2433:../src/RTOS/tasks.c **** 					/* The delayed list is not empty, get the value of the
2434:../src/RTOS/tasks.c **** 					item at the head of the delayed list.  This is the time
2435:../src/RTOS/tasks.c **** 					at which the task at the head of the delayed list must
2436:../src/RTOS/tasks.c **** 					be removed from the Blocked state. */
2437:../src/RTOS/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1976              		.loc 1 2437 0
 1977 007c 2A4B     		ldr	r3, .L153+8
 1978 007e 1B68     		ldr	r3, [r3]
 1979 0080 DB68     		ldr	r3, [r3, #12]
 1980 0082 DB68     		ldr	r3, [r3, #12]
 1981 0084 BB60     		str	r3, [r7, #8]
2438:../src/RTOS/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1982              		.loc 1 2438 0
 1983 0086 BB68     		ldr	r3, [r7, #8]
 1984 0088 5B68     		ldr	r3, [r3, #4]
 1985 008a 7B60     		str	r3, [r7, #4]
2439:../src/RTOS/tasks.c **** 
2440:../src/RTOS/tasks.c **** 					if( xConstTickCount < xItemValue )
 1986              		.loc 1 2440 0
 1987 008c 3A69     		ldr	r2, [r7, #16]
 1988 008e 7B68     		ldr	r3, [r7, #4]
 1989 0090 9A42     		cmp	r2, r3
 1990 0092 03D2     		bcs	.L145
2441:../src/RTOS/tasks.c **** 					{
2442:../src/RTOS/tasks.c **** 						/* It is not time to unblock this item yet, but the
2443:../src/RTOS/tasks.c **** 						item value is the time at which the task at the head
2444:../src/RTOS/tasks.c **** 						of the blocked list must be removed from the Blocked
2445:../src/RTOS/tasks.c **** 						state -	so record the item value in
2446:../src/RTOS/tasks.c **** 						xNextTaskUnblockTime. */
2447:../src/RTOS/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
 1991              		.loc 1 2447 0
 1992 0094 274A     		ldr	r2, .L153+20
 1993 0096 7B68     		ldr	r3, [r7, #4]
 1994 0098 1360     		str	r3, [r2]
2448:../src/RTOS/tasks.c **** 						break;
 1995              		.loc 1 2448 0
 1996 009a 2FE0     		b	.L141
 1997              	.L145:
2449:../src/RTOS/tasks.c **** 					}
2450:../src/RTOS/tasks.c **** 					else
2451:../src/RTOS/tasks.c **** 					{
2452:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2453:../src/RTOS/tasks.c **** 					}
2454:../src/RTOS/tasks.c **** 
2455:../src/RTOS/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2456:../src/RTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1998              		.loc 1 2456 0
 1999 009c BB68     		ldr	r3, [r7, #8]
 2000 009e 0433     		adds	r3, r3, #4
 2001 00a0 1846     		mov	r0, r3
 2002 00a2 FFF7FEFF 		bl	uxListRemove
2457:../src/RTOS/tasks.c **** 
2458:../src/RTOS/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2459:../src/RTOS/tasks.c **** 					it from the event list. */
2460:../src/RTOS/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2003              		.loc 1 2460 0
 2004 00a6 BB68     		ldr	r3, [r7, #8]
 2005 00a8 9B6A     		ldr	r3, [r3, #40]
 2006 00aa 002B     		cmp	r3, #0
 2007 00ac 04D0     		beq	.L146
2461:../src/RTOS/tasks.c **** 					{
2462:../src/RTOS/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2008              		.loc 1 2462 0
 2009 00ae BB68     		ldr	r3, [r7, #8]
 2010 00b0 1833     		adds	r3, r3, #24
 2011 00b2 1846     		mov	r0, r3
 2012 00b4 FFF7FEFF 		bl	uxListRemove
 2013              	.L146:
2463:../src/RTOS/tasks.c **** 					}
2464:../src/RTOS/tasks.c **** 					else
2465:../src/RTOS/tasks.c **** 					{
2466:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2467:../src/RTOS/tasks.c **** 					}
2468:../src/RTOS/tasks.c **** 
2469:../src/RTOS/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2470:../src/RTOS/tasks.c **** 					list. */
2471:../src/RTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2014              		.loc 1 2471 0
 2015 00b8 BB68     		ldr	r3, [r7, #8]
 2016 00ba DA6A     		ldr	r2, [r3, #44]
 2017 00bc 1E4B     		ldr	r3, .L153+24
 2018 00be 1B68     		ldr	r3, [r3]
 2019 00c0 9A42     		cmp	r2, r3
 2020 00c2 03D9     		bls	.L147
 2021              		.loc 1 2471 0 is_stmt 0 discriminator 1
 2022 00c4 BB68     		ldr	r3, [r7, #8]
 2023 00c6 DB6A     		ldr	r3, [r3, #44]
 2024 00c8 1B4A     		ldr	r2, .L153+24
 2025 00ca 1360     		str	r3, [r2]
 2026              	.L147:
 2027              		.loc 1 2471 0 discriminator 3
 2028 00cc BB68     		ldr	r3, [r7, #8]
 2029 00ce DA6A     		ldr	r2, [r3, #44]
 2030 00d0 1346     		mov	r3, r2
 2031 00d2 9B00     		lsls	r3, r3, #2
 2032 00d4 1344     		add	r3, r3, r2
 2033 00d6 9B00     		lsls	r3, r3, #2
 2034 00d8 184A     		ldr	r2, .L153+28
 2035 00da 1A44     		add	r2, r2, r3
 2036 00dc BB68     		ldr	r3, [r7, #8]
 2037 00de 0433     		adds	r3, r3, #4
 2038 00e0 1046     		mov	r0, r2
 2039 00e2 1946     		mov	r1, r3
 2040 00e4 FFF7FEFF 		bl	vListInsertEnd
2472:../src/RTOS/tasks.c **** 
2473:../src/RTOS/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2474:../src/RTOS/tasks.c **** 					context switch if preemption is turned off. */
2475:../src/RTOS/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2476:../src/RTOS/tasks.c **** 					{
2477:../src/RTOS/tasks.c **** 						/* Preemption is on, but a context switch should
2478:../src/RTOS/tasks.c **** 						only be performed if the unblocked task has a
2479:../src/RTOS/tasks.c **** 						priority that is equal to or higher than the
2480:../src/RTOS/tasks.c **** 						currently executing task. */
2481:../src/RTOS/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2041              		.loc 1 2481 0 is_stmt 1 discriminator 3
 2042 00e8 BB68     		ldr	r3, [r7, #8]
 2043 00ea DA6A     		ldr	r2, [r3, #44]
 2044 00ec 144B     		ldr	r3, .L153+32
 2045 00ee 1B68     		ldr	r3, [r3]
 2046 00f0 DB6A     		ldr	r3, [r3, #44]
 2047 00f2 9A42     		cmp	r2, r3
 2048 00f4 01D3     		bcc	.L148
2482:../src/RTOS/tasks.c **** 						{
2483:../src/RTOS/tasks.c **** 							xSwitchRequired = pdTRUE;
 2049              		.loc 1 2483 0
 2050 00f6 0123     		movs	r3, #1
 2051 00f8 7B61     		str	r3, [r7, #20]
 2052              	.L148:
2484:../src/RTOS/tasks.c **** 						}
2485:../src/RTOS/tasks.c **** 						else
2486:../src/RTOS/tasks.c **** 						{
2487:../src/RTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2488:../src/RTOS/tasks.c **** 						}
2489:../src/RTOS/tasks.c **** 					}
2490:../src/RTOS/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2491:../src/RTOS/tasks.c **** 				}
2492:../src/RTOS/tasks.c **** 			}
 2053              		.loc 1 2492 0
 2054 00fa B0E7     		b	.L149
 2055              	.L141:
 2056              	.LBE29:
 2057 00fc 04E0     		b	.L150
 2058              	.L137:
2493:../src/RTOS/tasks.c **** 		}
2494:../src/RTOS/tasks.c **** 
2495:../src/RTOS/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2496:../src/RTOS/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2497:../src/RTOS/tasks.c **** 		writer has not explicitly turned time slicing off. */
2498:../src/RTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2499:../src/RTOS/tasks.c **** 		{
2500:../src/RTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2501:../src/RTOS/tasks.c **** 			{
2502:../src/RTOS/tasks.c **** 				xSwitchRequired = pdTRUE;
2503:../src/RTOS/tasks.c **** 			}
2504:../src/RTOS/tasks.c **** 			else
2505:../src/RTOS/tasks.c **** 			{
2506:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2507:../src/RTOS/tasks.c **** 			}
2508:../src/RTOS/tasks.c **** 		}
2509:../src/RTOS/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2510:../src/RTOS/tasks.c **** 
2511:../src/RTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2512:../src/RTOS/tasks.c **** 		{
2513:../src/RTOS/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2514:../src/RTOS/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2515:../src/RTOS/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2516:../src/RTOS/tasks.c **** 			{
2517:../src/RTOS/tasks.c **** 				vApplicationTickHook();
2518:../src/RTOS/tasks.c **** 			}
2519:../src/RTOS/tasks.c **** 			else
2520:../src/RTOS/tasks.c **** 			{
2521:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2522:../src/RTOS/tasks.c **** 			}
2523:../src/RTOS/tasks.c **** 		}
2524:../src/RTOS/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2525:../src/RTOS/tasks.c **** 	}
2526:../src/RTOS/tasks.c **** 	else
2527:../src/RTOS/tasks.c **** 	{
2528:../src/RTOS/tasks.c **** 		++uxPendedTicks;
 2059              		.loc 1 2528 0
 2060 00fe 114B     		ldr	r3, .L153+36
 2061 0100 1B68     		ldr	r3, [r3]
 2062 0102 0133     		adds	r3, r3, #1
 2063 0104 0F4A     		ldr	r2, .L153+36
 2064 0106 1360     		str	r3, [r2]
 2065              	.L150:
2529:../src/RTOS/tasks.c **** 
2530:../src/RTOS/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2531:../src/RTOS/tasks.c **** 		scheduler is locked. */
2532:../src/RTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2533:../src/RTOS/tasks.c **** 		{
2534:../src/RTOS/tasks.c **** 			vApplicationTickHook();
2535:../src/RTOS/tasks.c **** 		}
2536:../src/RTOS/tasks.c **** 		#endif
2537:../src/RTOS/tasks.c **** 	}
2538:../src/RTOS/tasks.c **** 
2539:../src/RTOS/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2540:../src/RTOS/tasks.c **** 	{
2541:../src/RTOS/tasks.c **** 		if( xYieldPending != pdFALSE )
 2066              		.loc 1 2541 0
 2067 0108 0F4B     		ldr	r3, .L153+40
 2068 010a 1B68     		ldr	r3, [r3]
 2069 010c 002B     		cmp	r3, #0
 2070 010e 01D0     		beq	.L151
2542:../src/RTOS/tasks.c **** 		{
2543:../src/RTOS/tasks.c **** 			xSwitchRequired = pdTRUE;
 2071              		.loc 1 2543 0
 2072 0110 0123     		movs	r3, #1
 2073 0112 7B61     		str	r3, [r7, #20]
 2074              	.L151:
2544:../src/RTOS/tasks.c **** 		}
2545:../src/RTOS/tasks.c **** 		else
2546:../src/RTOS/tasks.c **** 		{
2547:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2548:../src/RTOS/tasks.c **** 		}
2549:../src/RTOS/tasks.c **** 	}
2550:../src/RTOS/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2551:../src/RTOS/tasks.c **** 
2552:../src/RTOS/tasks.c **** 	return xSwitchRequired;
 2075              		.loc 1 2552 0
 2076 0114 7B69     		ldr	r3, [r7, #20]
2553:../src/RTOS/tasks.c **** }
 2077              		.loc 1 2553 0
 2078 0116 1846     		mov	r0, r3
 2079 0118 1837     		adds	r7, r7, #24
 2080              		.cfi_def_cfa_offset 8
 2081 011a BD46     		mov	sp, r7
 2082              		.cfi_def_cfa_register 13
 2083              		@ sp needed
 2084 011c 80BD     		pop	{r7, pc}
 2085              	.L154:
 2086 011e 00BF     		.align	2
 2087              	.L153:
 2088 0120 00000000 		.word	uxSchedulerSuspended
 2089 0124 00000000 		.word	xTickCount
 2090 0128 00000000 		.word	pxDelayedTaskList
 2091 012c 00000000 		.word	pxOverflowDelayedTaskList
 2092 0130 00000000 		.word	xNumOfOverflows
 2093 0134 00000000 		.word	xNextTaskUnblockTime
 2094 0138 00000000 		.word	uxTopReadyPriority
 2095 013c 00000000 		.word	pxReadyTasksLists
 2096 0140 00000000 		.word	pxCurrentTCB
 2097 0144 00000000 		.word	uxPendedTicks
 2098 0148 00000000 		.word	xYieldPending
 2099              		.cfi_endproc
 2100              	.LFE21:
 2102              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2103              		.align	2
 2104              		.global	vTaskSwitchContext
 2105              		.thumb
 2106              		.thumb_func
 2108              	vTaskSwitchContext:
 2109              	.LFB22:
2554:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2555:../src/RTOS/tasks.c **** 
2556:../src/RTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2557:../src/RTOS/tasks.c **** 
2558:../src/RTOS/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2559:../src/RTOS/tasks.c **** 	{
2560:../src/RTOS/tasks.c **** 	TCB_t *xTCB;
2561:../src/RTOS/tasks.c **** 
2562:../src/RTOS/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2563:../src/RTOS/tasks.c **** 		getting set. */
2564:../src/RTOS/tasks.c **** 		if( xTask == NULL )
2565:../src/RTOS/tasks.c **** 		{
2566:../src/RTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2567:../src/RTOS/tasks.c **** 		}
2568:../src/RTOS/tasks.c **** 		else
2569:../src/RTOS/tasks.c **** 		{
2570:../src/RTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2571:../src/RTOS/tasks.c **** 		}
2572:../src/RTOS/tasks.c **** 
2573:../src/RTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2574:../src/RTOS/tasks.c **** 		the value can be accessed from an interrupt. */
2575:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
2576:../src/RTOS/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2577:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
2578:../src/RTOS/tasks.c **** 	}
2579:../src/RTOS/tasks.c **** 
2580:../src/RTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2581:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2582:../src/RTOS/tasks.c **** 
2583:../src/RTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2584:../src/RTOS/tasks.c **** 
2585:../src/RTOS/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2586:../src/RTOS/tasks.c **** 	{
2587:../src/RTOS/tasks.c **** 	TCB_t *xTCB;
2588:../src/RTOS/tasks.c **** 	TaskHookFunction_t xReturn;
2589:../src/RTOS/tasks.c **** 
2590:../src/RTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2591:../src/RTOS/tasks.c **** 		if( xTask == NULL )
2592:../src/RTOS/tasks.c **** 		{
2593:../src/RTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2594:../src/RTOS/tasks.c **** 		}
2595:../src/RTOS/tasks.c **** 		else
2596:../src/RTOS/tasks.c **** 		{
2597:../src/RTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2598:../src/RTOS/tasks.c **** 		}
2599:../src/RTOS/tasks.c **** 
2600:../src/RTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2601:../src/RTOS/tasks.c **** 		the value can be accessed from an interrupt. */
2602:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
2603:../src/RTOS/tasks.c **** 		{
2604:../src/RTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2605:../src/RTOS/tasks.c **** 		}
2606:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
2607:../src/RTOS/tasks.c **** 
2608:../src/RTOS/tasks.c **** 		return xReturn;
2609:../src/RTOS/tasks.c **** 	}
2610:../src/RTOS/tasks.c **** 
2611:../src/RTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2612:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2613:../src/RTOS/tasks.c **** 
2614:../src/RTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2615:../src/RTOS/tasks.c **** 
2616:../src/RTOS/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2617:../src/RTOS/tasks.c **** 	{
2618:../src/RTOS/tasks.c **** 	TCB_t *xTCB;
2619:../src/RTOS/tasks.c **** 	BaseType_t xReturn;
2620:../src/RTOS/tasks.c **** 
2621:../src/RTOS/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2622:../src/RTOS/tasks.c **** 		if( xTask == NULL )
2623:../src/RTOS/tasks.c **** 		{
2624:../src/RTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2625:../src/RTOS/tasks.c **** 		}
2626:../src/RTOS/tasks.c **** 		else
2627:../src/RTOS/tasks.c **** 		{
2628:../src/RTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2629:../src/RTOS/tasks.c **** 		}
2630:../src/RTOS/tasks.c **** 
2631:../src/RTOS/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2632:../src/RTOS/tasks.c **** 		{
2633:../src/RTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2634:../src/RTOS/tasks.c **** 		}
2635:../src/RTOS/tasks.c **** 		else
2636:../src/RTOS/tasks.c **** 		{
2637:../src/RTOS/tasks.c **** 			xReturn = pdFAIL;
2638:../src/RTOS/tasks.c **** 		}
2639:../src/RTOS/tasks.c **** 
2640:../src/RTOS/tasks.c **** 		return xReturn;
2641:../src/RTOS/tasks.c **** 	}
2642:../src/RTOS/tasks.c **** 
2643:../src/RTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2644:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2645:../src/RTOS/tasks.c **** 
2646:../src/RTOS/tasks.c **** void vTaskSwitchContext( void )
2647:../src/RTOS/tasks.c **** {
 2110              		.loc 1 2647 0
 2111              		.cfi_startproc
 2112              		@ args = 0, pretend = 0, frame = 8
 2113              		@ frame_needed = 1, uses_anonymous_args = 0
 2114              		@ link register save eliminated.
 2115 0000 80B4     		push	{r7}
 2116              		.cfi_def_cfa_offset 4
 2117              		.cfi_offset 7, -4
 2118 0002 83B0     		sub	sp, sp, #12
 2119              		.cfi_def_cfa_offset 16
 2120 0004 00AF     		add	r7, sp, #0
 2121              		.cfi_def_cfa_register 7
2648:../src/RTOS/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2122              		.loc 1 2648 0
 2123 0006 224B     		ldr	r3, .L163
 2124 0008 1B68     		ldr	r3, [r3]
 2125 000a 002B     		cmp	r3, #0
 2126 000c 03D0     		beq	.L156
2649:../src/RTOS/tasks.c **** 	{
2650:../src/RTOS/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2651:../src/RTOS/tasks.c **** 		switch. */
2652:../src/RTOS/tasks.c **** 		xYieldPending = pdTRUE;
 2127              		.loc 1 2652 0
 2128 000e 214B     		ldr	r3, .L163+4
 2129 0010 0122     		movs	r2, #1
 2130 0012 1A60     		str	r2, [r3]
 2131 0014 37E0     		b	.L155
 2132              	.L156:
2653:../src/RTOS/tasks.c **** 	}
2654:../src/RTOS/tasks.c **** 	else
2655:../src/RTOS/tasks.c **** 	{
2656:../src/RTOS/tasks.c **** 		xYieldPending = pdFALSE;
 2133              		.loc 1 2656 0
 2134 0016 1F4B     		ldr	r3, .L163+4
 2135 0018 0022     		movs	r2, #0
 2136 001a 1A60     		str	r2, [r3]
 2137              	.LBB31:
2657:../src/RTOS/tasks.c **** 		traceTASK_SWITCHED_OUT();
2658:../src/RTOS/tasks.c **** 
2659:../src/RTOS/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2660:../src/RTOS/tasks.c **** 		{
2661:../src/RTOS/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2662:../src/RTOS/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2663:../src/RTOS/tasks.c **** 				#else
2664:../src/RTOS/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2665:../src/RTOS/tasks.c **** 				#endif
2666:../src/RTOS/tasks.c **** 
2667:../src/RTOS/tasks.c **** 				/* Add the amount of time the task has been running to the
2668:../src/RTOS/tasks.c **** 				accumulated time so far.  The time the task started running was
2669:../src/RTOS/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2670:../src/RTOS/tasks.c **** 				protection here so count values are only valid until the timer
2671:../src/RTOS/tasks.c **** 				overflows.  The guard against negative values is to protect
2672:../src/RTOS/tasks.c **** 				against suspect run time stat counter implementations - which
2673:../src/RTOS/tasks.c **** 				are provided by the application, not the kernel. */
2674:../src/RTOS/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2675:../src/RTOS/tasks.c **** 				{
2676:../src/RTOS/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2677:../src/RTOS/tasks.c **** 				}
2678:../src/RTOS/tasks.c **** 				else
2679:../src/RTOS/tasks.c **** 				{
2680:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2681:../src/RTOS/tasks.c **** 				}
2682:../src/RTOS/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2683:../src/RTOS/tasks.c **** 		}
2684:../src/RTOS/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2685:../src/RTOS/tasks.c **** 
2686:../src/RTOS/tasks.c **** 		/* Check for stack overflow, if configured. */
2687:../src/RTOS/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
2688:../src/RTOS/tasks.c **** 
2689:../src/RTOS/tasks.c **** 		/* Select a new task to run using either the generic C or port
2690:../src/RTOS/tasks.c **** 		optimised asm code. */
2691:../src/RTOS/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2138              		.loc 1 2691 0
 2139 001c 1E4B     		ldr	r3, .L163+8
 2140 001e 1B68     		ldr	r3, [r3]
 2141 0020 7B60     		str	r3, [r7, #4]
 2142 0022 06E0     		b	.L158
 2143              	.L161:
 2144              		.loc 1 2691 0 is_stmt 0 discriminator 4
 2145 0024 7B68     		ldr	r3, [r7, #4]
 2146 0026 002B     		cmp	r3, #0
 2147 0028 00D1     		bne	.L159
 2148              	.L160:
 2149              		.loc 1 2691 0 discriminator 1
 2150 002a FEE7     		b	.L160
 2151              	.L159:
 2152              		.loc 1 2691 0 discriminator 2
 2153 002c 7B68     		ldr	r3, [r7, #4]
 2154 002e 013B     		subs	r3, r3, #1
 2155 0030 7B60     		str	r3, [r7, #4]
 2156              	.L158:
 2157              		.loc 1 2691 0 discriminator 3
 2158 0032 1A49     		ldr	r1, .L163+12
 2159 0034 7A68     		ldr	r2, [r7, #4]
 2160 0036 1346     		mov	r3, r2
 2161 0038 9B00     		lsls	r3, r3, #2
 2162 003a 1344     		add	r3, r3, r2
 2163 003c 9B00     		lsls	r3, r3, #2
 2164 003e 0B44     		add	r3, r3, r1
 2165 0040 1B68     		ldr	r3, [r3]
 2166 0042 002B     		cmp	r3, #0
 2167 0044 EED0     		beq	.L161
 2168              	.LBB32:
 2169              		.loc 1 2691 0 discriminator 5
 2170 0046 7A68     		ldr	r2, [r7, #4]
 2171 0048 1346     		mov	r3, r2
 2172 004a 9B00     		lsls	r3, r3, #2
 2173 004c 1344     		add	r3, r3, r2
 2174 004e 9B00     		lsls	r3, r3, #2
 2175 0050 124A     		ldr	r2, .L163+12
 2176 0052 1344     		add	r3, r3, r2
 2177 0054 3B60     		str	r3, [r7]
 2178 0056 3B68     		ldr	r3, [r7]
 2179 0058 5B68     		ldr	r3, [r3, #4]
 2180 005a 5A68     		ldr	r2, [r3, #4]
 2181 005c 3B68     		ldr	r3, [r7]
 2182 005e 5A60     		str	r2, [r3, #4]
 2183 0060 3B68     		ldr	r3, [r7]
 2184 0062 5A68     		ldr	r2, [r3, #4]
 2185 0064 3B68     		ldr	r3, [r7]
 2186 0066 0833     		adds	r3, r3, #8
 2187 0068 9A42     		cmp	r2, r3
 2188 006a 04D1     		bne	.L162
 2189              		.loc 1 2691 0 discriminator 6
 2190 006c 3B68     		ldr	r3, [r7]
 2191 006e 5B68     		ldr	r3, [r3, #4]
 2192 0070 5A68     		ldr	r2, [r3, #4]
 2193 0072 3B68     		ldr	r3, [r7]
 2194 0074 5A60     		str	r2, [r3, #4]
 2195              	.L162:
 2196              		.loc 1 2691 0 discriminator 8
 2197 0076 3B68     		ldr	r3, [r7]
 2198 0078 5B68     		ldr	r3, [r3, #4]
 2199 007a DB68     		ldr	r3, [r3, #12]
 2200 007c 084A     		ldr	r2, .L163+16
 2201 007e 1360     		str	r3, [r2]
 2202              	.LBE32:
 2203 0080 054A     		ldr	r2, .L163+8
 2204 0082 7B68     		ldr	r3, [r7, #4]
 2205 0084 1360     		str	r3, [r2]
 2206              	.L155:
 2207              	.LBE31:
2692:../src/RTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
2693:../src/RTOS/tasks.c **** 
2694:../src/RTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2695:../src/RTOS/tasks.c **** 		{
2696:../src/RTOS/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2697:../src/RTOS/tasks.c **** 			structure specific to this task. */
2698:../src/RTOS/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2699:../src/RTOS/tasks.c **** 		}
2700:../src/RTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2701:../src/RTOS/tasks.c **** 	}
2702:../src/RTOS/tasks.c **** }
 2208              		.loc 1 2702 0 is_stmt 1
 2209 0086 0C37     		adds	r7, r7, #12
 2210              		.cfi_def_cfa_offset 4
 2211 0088 BD46     		mov	sp, r7
 2212              		.cfi_def_cfa_register 13
 2213              		@ sp needed
 2214 008a 5DF8047B 		ldr	r7, [sp], #4
 2215              		.cfi_restore 7
 2216              		.cfi_def_cfa_offset 0
 2217 008e 7047     		bx	lr
 2218              	.L164:
 2219              		.align	2
 2220              	.L163:
 2221 0090 00000000 		.word	uxSchedulerSuspended
 2222 0094 00000000 		.word	xYieldPending
 2223 0098 00000000 		.word	uxTopReadyPriority
 2224 009c 00000000 		.word	pxReadyTasksLists
 2225 00a0 00000000 		.word	pxCurrentTCB
 2226              		.cfi_endproc
 2227              	.LFE22:
 2229              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2230              		.align	2
 2231              		.global	vTaskPlaceOnEventList
 2232              		.thumb
 2233              		.thumb_func
 2235              	vTaskPlaceOnEventList:
 2236              	.LFB23:
2703:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2704:../src/RTOS/tasks.c **** 
2705:../src/RTOS/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2706:../src/RTOS/tasks.c **** {
 2237              		.loc 1 2706 0
 2238              		.cfi_startproc
 2239              		@ args = 0, pretend = 0, frame = 8
 2240              		@ frame_needed = 1, uses_anonymous_args = 0
 2241 0000 80B5     		push	{r7, lr}
 2242              		.cfi_def_cfa_offset 8
 2243              		.cfi_offset 7, -8
 2244              		.cfi_offset 14, -4
 2245 0002 82B0     		sub	sp, sp, #8
 2246              		.cfi_def_cfa_offset 16
 2247 0004 00AF     		add	r7, sp, #0
 2248              		.cfi_def_cfa_register 7
 2249 0006 7860     		str	r0, [r7, #4]
 2250 0008 3960     		str	r1, [r7]
2707:../src/RTOS/tasks.c **** 	configASSERT( pxEventList );
 2251              		.loc 1 2707 0
 2252 000a 7B68     		ldr	r3, [r7, #4]
 2253 000c 002B     		cmp	r3, #0
 2254 000e 00D1     		bne	.L166
 2255              	.L167:
 2256              		.loc 1 2707 0 is_stmt 0 discriminator 1
 2257 0010 FEE7     		b	.L167
 2258              	.L166:
2708:../src/RTOS/tasks.c **** 
2709:../src/RTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2710:../src/RTOS/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2711:../src/RTOS/tasks.c **** 
2712:../src/RTOS/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2713:../src/RTOS/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2714:../src/RTOS/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2715:../src/RTOS/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2716:../src/RTOS/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2259              		.loc 1 2716 0 is_stmt 1
 2260 0012 074B     		ldr	r3, .L168
 2261 0014 1B68     		ldr	r3, [r3]
 2262 0016 1833     		adds	r3, r3, #24
 2263 0018 7868     		ldr	r0, [r7, #4]
 2264 001a 1946     		mov	r1, r3
 2265 001c FFF7FEFF 		bl	vListInsert
2717:../src/RTOS/tasks.c **** 
2718:../src/RTOS/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2266              		.loc 1 2718 0
 2267 0020 3868     		ldr	r0, [r7]
 2268 0022 0121     		movs	r1, #1
 2269 0024 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
2719:../src/RTOS/tasks.c **** }
 2270              		.loc 1 2719 0
 2271 0028 0837     		adds	r7, r7, #8
 2272              		.cfi_def_cfa_offset 8
 2273 002a BD46     		mov	sp, r7
 2274              		.cfi_def_cfa_register 13
 2275              		@ sp needed
 2276 002c 80BD     		pop	{r7, pc}
 2277              	.L169:
 2278 002e 00BF     		.align	2
 2279              	.L168:
 2280 0030 00000000 		.word	pxCurrentTCB
 2281              		.cfi_endproc
 2282              	.LFE23:
 2284              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2285              		.align	2
 2286              		.global	vTaskPlaceOnUnorderedEventList
 2287              		.thumb
 2288              		.thumb_func
 2290              	vTaskPlaceOnUnorderedEventList:
 2291              	.LFB24:
2720:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2721:../src/RTOS/tasks.c **** 
2722:../src/RTOS/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2723:../src/RTOS/tasks.c **** {
 2292              		.loc 1 2723 0
 2293              		.cfi_startproc
 2294              		@ args = 0, pretend = 0, frame = 16
 2295              		@ frame_needed = 1, uses_anonymous_args = 0
 2296 0000 80B5     		push	{r7, lr}
 2297              		.cfi_def_cfa_offset 8
 2298              		.cfi_offset 7, -8
 2299              		.cfi_offset 14, -4
 2300 0002 84B0     		sub	sp, sp, #16
 2301              		.cfi_def_cfa_offset 24
 2302 0004 00AF     		add	r7, sp, #0
 2303              		.cfi_def_cfa_register 7
 2304 0006 F860     		str	r0, [r7, #12]
 2305 0008 B960     		str	r1, [r7, #8]
 2306 000a 7A60     		str	r2, [r7, #4]
2724:../src/RTOS/tasks.c **** 	configASSERT( pxEventList );
 2307              		.loc 1 2724 0
 2308 000c FB68     		ldr	r3, [r7, #12]
 2309 000e 002B     		cmp	r3, #0
 2310 0010 00D1     		bne	.L171
 2311              	.L172:
 2312              		.loc 1 2724 0 is_stmt 0 discriminator 1
 2313 0012 FEE7     		b	.L172
 2314              	.L171:
2725:../src/RTOS/tasks.c **** 
2726:../src/RTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2727:../src/RTOS/tasks.c **** 	the event groups implementation. */
2728:../src/RTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
 2315              		.loc 1 2728 0 is_stmt 1
 2316 0014 0C4B     		ldr	r3, .L175
 2317 0016 1B68     		ldr	r3, [r3]
 2318 0018 002B     		cmp	r3, #0
 2319 001a 00D1     		bne	.L173
 2320              	.L174:
 2321              		.loc 1 2728 0 is_stmt 0 discriminator 2
 2322 001c FEE7     		b	.L174
 2323              	.L173:
2729:../src/RTOS/tasks.c **** 
2730:../src/RTOS/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2731:../src/RTOS/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2732:../src/RTOS/tasks.c **** 	task that is not in the Blocked state. */
2733:../src/RTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
 2324              		.loc 1 2733 0 is_stmt 1
 2325 001e 0B4B     		ldr	r3, .L175+4
 2326 0020 1B68     		ldr	r3, [r3]
 2327 0022 BA68     		ldr	r2, [r7, #8]
 2328 0024 42F00042 		orr	r2, r2, #-2147483648
 2329 0028 9A61     		str	r2, [r3, #24]
2734:../src/RTOS/tasks.c **** 
2735:../src/RTOS/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2736:../src/RTOS/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2737:../src/RTOS/tasks.c **** 	event group implementation - and interrupts don't access event groups
2738:../src/RTOS/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2739:../src/RTOS/tasks.c **** 	the task level). */
2740:../src/RTOS/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2330              		.loc 1 2740 0
 2331 002a 084B     		ldr	r3, .L175+4
 2332 002c 1B68     		ldr	r3, [r3]
 2333 002e 1833     		adds	r3, r3, #24
 2334 0030 F868     		ldr	r0, [r7, #12]
 2335 0032 1946     		mov	r1, r3
 2336 0034 FFF7FEFF 		bl	vListInsertEnd
2741:../src/RTOS/tasks.c **** 
2742:../src/RTOS/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2337              		.loc 1 2742 0
 2338 0038 7868     		ldr	r0, [r7, #4]
 2339 003a 0121     		movs	r1, #1
 2340 003c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
2743:../src/RTOS/tasks.c **** }
 2341              		.loc 1 2743 0
 2342 0040 1037     		adds	r7, r7, #16
 2343              		.cfi_def_cfa_offset 8
 2344 0042 BD46     		mov	sp, r7
 2345              		.cfi_def_cfa_register 13
 2346              		@ sp needed
 2347 0044 80BD     		pop	{r7, pc}
 2348              	.L176:
 2349 0046 00BF     		.align	2
 2350              	.L175:
 2351 0048 00000000 		.word	uxSchedulerSuspended
 2352 004c 00000000 		.word	pxCurrentTCB
 2353              		.cfi_endproc
 2354              	.LFE24:
 2356              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2357              		.align	2
 2358              		.global	xTaskRemoveFromEventList
 2359              		.thumb
 2360              		.thumb_func
 2362              	xTaskRemoveFromEventList:
 2363              	.LFB25:
2744:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2745:../src/RTOS/tasks.c **** 
2746:../src/RTOS/tasks.c **** #if( configUSE_TIMERS == 1 )
2747:../src/RTOS/tasks.c **** 
2748:../src/RTOS/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
2749:../src/RTOS/tasks.c **** 	{
2750:../src/RTOS/tasks.c **** 		configASSERT( pxEventList );
2751:../src/RTOS/tasks.c **** 
2752:../src/RTOS/tasks.c **** 		/* This function should not be called by application code hence the
2753:../src/RTOS/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2754:../src/RTOS/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2755:../src/RTOS/tasks.c **** 		it should be called with the scheduler suspended. */
2756:../src/RTOS/tasks.c **** 
2757:../src/RTOS/tasks.c **** 
2758:../src/RTOS/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2759:../src/RTOS/tasks.c **** 		In this case it is assume that this is the only task that is going to
2760:../src/RTOS/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2761:../src/RTOS/tasks.c **** 		can be used in place of vListInsert. */
2762:../src/RTOS/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2763:../src/RTOS/tasks.c **** 
2764:../src/RTOS/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
2765:../src/RTOS/tasks.c **** 		value that will be recognised as an indefinite delay inside the
2766:../src/RTOS/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
2767:../src/RTOS/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
2768:../src/RTOS/tasks.c **** 		{
2769:../src/RTOS/tasks.c **** 			xTicksToWait = portMAX_DELAY;
2770:../src/RTOS/tasks.c **** 		}
2771:../src/RTOS/tasks.c **** 
2772:../src/RTOS/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
2773:../src/RTOS/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
2774:../src/RTOS/tasks.c **** 	}
2775:../src/RTOS/tasks.c **** 
2776:../src/RTOS/tasks.c **** #endif /* configUSE_TIMERS */
2777:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2778:../src/RTOS/tasks.c **** 
2779:../src/RTOS/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2780:../src/RTOS/tasks.c **** {
 2364              		.loc 1 2780 0
 2365              		.cfi_startproc
 2366              		@ args = 0, pretend = 0, frame = 16
 2367              		@ frame_needed = 1, uses_anonymous_args = 0
 2368 0000 80B5     		push	{r7, lr}
 2369              		.cfi_def_cfa_offset 8
 2370              		.cfi_offset 7, -8
 2371              		.cfi_offset 14, -4
 2372 0002 84B0     		sub	sp, sp, #16
 2373              		.cfi_def_cfa_offset 24
 2374 0004 00AF     		add	r7, sp, #0
 2375              		.cfi_def_cfa_register 7
 2376 0006 7860     		str	r0, [r7, #4]
2781:../src/RTOS/tasks.c **** TCB_t *pxUnblockedTCB;
2782:../src/RTOS/tasks.c **** BaseType_t xReturn;
2783:../src/RTOS/tasks.c **** 
2784:../src/RTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2785:../src/RTOS/tasks.c **** 	called from a critical section within an ISR. */
2786:../src/RTOS/tasks.c **** 
2787:../src/RTOS/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2788:../src/RTOS/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2789:../src/RTOS/tasks.c **** 	the delayed list, and add it to the ready list.
2790:../src/RTOS/tasks.c **** 
2791:../src/RTOS/tasks.c **** 	If an event is for a queue that is locked then this function will never
2792:../src/RTOS/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2793:../src/RTOS/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2794:../src/RTOS/tasks.c **** 
2795:../src/RTOS/tasks.c **** 	This function assumes that a check has already been made to ensure that
2796:../src/RTOS/tasks.c **** 	pxEventList is not empty. */
2797:../src/RTOS/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2377              		.loc 1 2797 0
 2378 0008 7B68     		ldr	r3, [r7, #4]
 2379 000a DB68     		ldr	r3, [r3, #12]
 2380 000c DB68     		ldr	r3, [r3, #12]
 2381 000e BB60     		str	r3, [r7, #8]
2798:../src/RTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2382              		.loc 1 2798 0
 2383 0010 BB68     		ldr	r3, [r7, #8]
 2384 0012 002B     		cmp	r3, #0
 2385 0014 00D1     		bne	.L178
 2386              	.L179:
 2387              		.loc 1 2798 0 is_stmt 0 discriminator 1
 2388 0016 FEE7     		b	.L179
 2389              	.L178:
2799:../src/RTOS/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2390              		.loc 1 2799 0 is_stmt 1
 2391 0018 BB68     		ldr	r3, [r7, #8]
 2392 001a 1833     		adds	r3, r3, #24
 2393 001c 1846     		mov	r0, r3
 2394 001e FFF7FEFF 		bl	uxListRemove
2800:../src/RTOS/tasks.c **** 
2801:../src/RTOS/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2395              		.loc 1 2801 0
 2396 0022 1E4B     		ldr	r3, .L186
 2397 0024 1B68     		ldr	r3, [r3]
 2398 0026 002B     		cmp	r3, #0
 2399 0028 1DD1     		bne	.L180
2802:../src/RTOS/tasks.c **** 	{
2803:../src/RTOS/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 2400              		.loc 1 2803 0
 2401 002a BB68     		ldr	r3, [r7, #8]
 2402 002c 0433     		adds	r3, r3, #4
 2403 002e 1846     		mov	r0, r3
 2404 0030 FFF7FEFF 		bl	uxListRemove
2804:../src/RTOS/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2405              		.loc 1 2804 0
 2406 0034 BB68     		ldr	r3, [r7, #8]
 2407 0036 DA6A     		ldr	r2, [r3, #44]
 2408 0038 194B     		ldr	r3, .L186+4
 2409 003a 1B68     		ldr	r3, [r3]
 2410 003c 9A42     		cmp	r2, r3
 2411 003e 03D9     		bls	.L181
 2412              		.loc 1 2804 0 is_stmt 0 discriminator 1
 2413 0040 BB68     		ldr	r3, [r7, #8]
 2414 0042 DB6A     		ldr	r3, [r3, #44]
 2415 0044 164A     		ldr	r2, .L186+4
 2416 0046 1360     		str	r3, [r2]
 2417              	.L181:
 2418              		.loc 1 2804 0 discriminator 3
 2419 0048 BB68     		ldr	r3, [r7, #8]
 2420 004a DA6A     		ldr	r2, [r3, #44]
 2421 004c 1346     		mov	r3, r2
 2422 004e 9B00     		lsls	r3, r3, #2
 2423 0050 1344     		add	r3, r3, r2
 2424 0052 9B00     		lsls	r3, r3, #2
 2425 0054 134A     		ldr	r2, .L186+8
 2426 0056 1A44     		add	r2, r2, r3
 2427 0058 BB68     		ldr	r3, [r7, #8]
 2428 005a 0433     		adds	r3, r3, #4
 2429 005c 1046     		mov	r0, r2
 2430 005e 1946     		mov	r1, r3
 2431 0060 FFF7FEFF 		bl	vListInsertEnd
 2432 0064 05E0     		b	.L182
 2433              	.L180:
2805:../src/RTOS/tasks.c **** 	}
2806:../src/RTOS/tasks.c **** 	else
2807:../src/RTOS/tasks.c **** 	{
2808:../src/RTOS/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
2809:../src/RTOS/tasks.c **** 		pending until the scheduler is resumed. */
2810:../src/RTOS/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2434              		.loc 1 2810 0 is_stmt 1
 2435 0066 BB68     		ldr	r3, [r7, #8]
 2436 0068 1833     		adds	r3, r3, #24
 2437 006a 0F48     		ldr	r0, .L186+12
 2438 006c 1946     		mov	r1, r3
 2439 006e FFF7FEFF 		bl	vListInsertEnd
 2440              	.L182:
2811:../src/RTOS/tasks.c **** 	}
2812:../src/RTOS/tasks.c **** 
2813:../src/RTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2441              		.loc 1 2813 0
 2442 0072 BB68     		ldr	r3, [r7, #8]
 2443 0074 DA6A     		ldr	r2, [r3, #44]
 2444 0076 0D4B     		ldr	r3, .L186+16
 2445 0078 1B68     		ldr	r3, [r3]
 2446 007a DB6A     		ldr	r3, [r3, #44]
 2447 007c 9A42     		cmp	r2, r3
 2448 007e 05D9     		bls	.L183
2814:../src/RTOS/tasks.c **** 	{
2815:../src/RTOS/tasks.c **** 		/* Return true if the task removed from the event list has a higher
2816:../src/RTOS/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
2817:../src/RTOS/tasks.c **** 		it should force a context switch now. */
2818:../src/RTOS/tasks.c **** 		xReturn = pdTRUE;
 2449              		.loc 1 2818 0
 2450 0080 0123     		movs	r3, #1
 2451 0082 FB60     		str	r3, [r7, #12]
2819:../src/RTOS/tasks.c **** 
2820:../src/RTOS/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2821:../src/RTOS/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2822:../src/RTOS/tasks.c **** 		xYieldPending = pdTRUE;
 2452              		.loc 1 2822 0
 2453 0084 0A4B     		ldr	r3, .L186+20
 2454 0086 0122     		movs	r2, #1
 2455 0088 1A60     		str	r2, [r3]
 2456 008a 01E0     		b	.L184
 2457              	.L183:
2823:../src/RTOS/tasks.c **** 	}
2824:../src/RTOS/tasks.c **** 	else
2825:../src/RTOS/tasks.c **** 	{
2826:../src/RTOS/tasks.c **** 		xReturn = pdFALSE;
 2458              		.loc 1 2826 0
 2459 008c 0023     		movs	r3, #0
 2460 008e FB60     		str	r3, [r7, #12]
 2461              	.L184:
2827:../src/RTOS/tasks.c **** 	}
2828:../src/RTOS/tasks.c **** 
2829:../src/RTOS/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
2830:../src/RTOS/tasks.c **** 	{
2831:../src/RTOS/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2832:../src/RTOS/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
2833:../src/RTOS/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2834:../src/RTOS/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
2835:../src/RTOS/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
2836:../src/RTOS/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
2837:../src/RTOS/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
2838:../src/RTOS/tasks.c **** 		ensure it is updated at the earliest possible time. */
2839:../src/RTOS/tasks.c **** 		prvResetNextTaskUnblockTime();
2840:../src/RTOS/tasks.c **** 	}
2841:../src/RTOS/tasks.c **** 	#endif
2842:../src/RTOS/tasks.c **** 
2843:../src/RTOS/tasks.c **** 	return xReturn;
 2462              		.loc 1 2843 0
 2463 0090 FB68     		ldr	r3, [r7, #12]
2844:../src/RTOS/tasks.c **** }
 2464              		.loc 1 2844 0
 2465 0092 1846     		mov	r0, r3
 2466 0094 1037     		adds	r7, r7, #16
 2467              		.cfi_def_cfa_offset 8
 2468 0096 BD46     		mov	sp, r7
 2469              		.cfi_def_cfa_register 13
 2470              		@ sp needed
 2471 0098 80BD     		pop	{r7, pc}
 2472              	.L187:
 2473 009a 00BF     		.align	2
 2474              	.L186:
 2475 009c 00000000 		.word	uxSchedulerSuspended
 2476 00a0 00000000 		.word	uxTopReadyPriority
 2477 00a4 00000000 		.word	pxReadyTasksLists
 2478 00a8 00000000 		.word	xPendingReadyList
 2479 00ac 00000000 		.word	pxCurrentTCB
 2480 00b0 00000000 		.word	xYieldPending
 2481              		.cfi_endproc
 2482              	.LFE25:
 2484              		.section	.text.xTaskRemoveFromUnorderedEventList,"ax",%progbits
 2485              		.align	2
 2486              		.global	xTaskRemoveFromUnorderedEventList
 2487              		.thumb
 2488              		.thumb_func
 2490              	xTaskRemoveFromUnorderedEventList:
 2491              	.LFB26:
2845:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2846:../src/RTOS/tasks.c **** 
2847:../src/RTOS/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2848:../src/RTOS/tasks.c **** {
 2492              		.loc 1 2848 0
 2493              		.cfi_startproc
 2494              		@ args = 0, pretend = 0, frame = 16
 2495              		@ frame_needed = 1, uses_anonymous_args = 0
 2496 0000 80B5     		push	{r7, lr}
 2497              		.cfi_def_cfa_offset 8
 2498              		.cfi_offset 7, -8
 2499              		.cfi_offset 14, -4
 2500 0002 84B0     		sub	sp, sp, #16
 2501              		.cfi_def_cfa_offset 24
 2502 0004 00AF     		add	r7, sp, #0
 2503              		.cfi_def_cfa_register 7
 2504 0006 7860     		str	r0, [r7, #4]
 2505 0008 3960     		str	r1, [r7]
2849:../src/RTOS/tasks.c **** TCB_t *pxUnblockedTCB;
2850:../src/RTOS/tasks.c **** BaseType_t xReturn;
2851:../src/RTOS/tasks.c **** 
2852:../src/RTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2853:../src/RTOS/tasks.c **** 	the event flags implementation. */
2854:../src/RTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
 2506              		.loc 1 2854 0
 2507 000a 224B     		ldr	r3, .L197
 2508 000c 1B68     		ldr	r3, [r3]
 2509 000e 002B     		cmp	r3, #0
 2510 0010 00D1     		bne	.L189
 2511              	.L190:
 2512              		.loc 1 2854 0 is_stmt 0 discriminator 1
 2513 0012 FEE7     		b	.L190
 2514              	.L189:
2855:../src/RTOS/tasks.c **** 
2856:../src/RTOS/tasks.c **** 	/* Store the new item value in the event list. */
2857:../src/RTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 2515              		.loc 1 2857 0 is_stmt 1
 2516 0014 3B68     		ldr	r3, [r7]
 2517 0016 43F00042 		orr	r2, r3, #-2147483648
 2518 001a 7B68     		ldr	r3, [r7, #4]
 2519 001c 1A60     		str	r2, [r3]
2858:../src/RTOS/tasks.c **** 
2859:../src/RTOS/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
2860:../src/RTOS/tasks.c **** 	event flags. */
2861:../src/RTOS/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 2520              		.loc 1 2861 0
 2521 001e 7B68     		ldr	r3, [r7, #4]
 2522 0020 DB68     		ldr	r3, [r3, #12]
 2523 0022 BB60     		str	r3, [r7, #8]
2862:../src/RTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2524              		.loc 1 2862 0
 2525 0024 BB68     		ldr	r3, [r7, #8]
 2526 0026 002B     		cmp	r3, #0
 2527 0028 00D1     		bne	.L191
 2528              	.L192:
 2529              		.loc 1 2862 0 is_stmt 0 discriminator 2
 2530 002a FEE7     		b	.L192
 2531              	.L191:
2863:../src/RTOS/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 2532              		.loc 1 2863 0 is_stmt 1
 2533 002c 7868     		ldr	r0, [r7, #4]
 2534 002e FFF7FEFF 		bl	uxListRemove
2864:../src/RTOS/tasks.c **** 
2865:../src/RTOS/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
2866:../src/RTOS/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
2867:../src/RTOS/tasks.c **** 	lists. */
2868:../src/RTOS/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 2535              		.loc 1 2868 0
 2536 0032 BB68     		ldr	r3, [r7, #8]
 2537 0034 0433     		adds	r3, r3, #4
 2538 0036 1846     		mov	r0, r3
 2539 0038 FFF7FEFF 		bl	uxListRemove
2869:../src/RTOS/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2540              		.loc 1 2869 0
 2541 003c BB68     		ldr	r3, [r7, #8]
 2542 003e DA6A     		ldr	r2, [r3, #44]
 2543 0040 154B     		ldr	r3, .L197+4
 2544 0042 1B68     		ldr	r3, [r3]
 2545 0044 9A42     		cmp	r2, r3
 2546 0046 03D9     		bls	.L193
 2547              		.loc 1 2869 0 is_stmt 0 discriminator 1
 2548 0048 BB68     		ldr	r3, [r7, #8]
 2549 004a DB6A     		ldr	r3, [r3, #44]
 2550 004c 124A     		ldr	r2, .L197+4
 2551 004e 1360     		str	r3, [r2]
 2552              	.L193:
 2553              		.loc 1 2869 0 discriminator 3
 2554 0050 BB68     		ldr	r3, [r7, #8]
 2555 0052 DA6A     		ldr	r2, [r3, #44]
 2556 0054 1346     		mov	r3, r2
 2557 0056 9B00     		lsls	r3, r3, #2
 2558 0058 1344     		add	r3, r3, r2
 2559 005a 9B00     		lsls	r3, r3, #2
 2560 005c 0F4A     		ldr	r2, .L197+8
 2561 005e 1A44     		add	r2, r2, r3
 2562 0060 BB68     		ldr	r3, [r7, #8]
 2563 0062 0433     		adds	r3, r3, #4
 2564 0064 1046     		mov	r0, r2
 2565 0066 1946     		mov	r1, r3
 2566 0068 FFF7FEFF 		bl	vListInsertEnd
2870:../src/RTOS/tasks.c **** 
2871:../src/RTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2567              		.loc 1 2871 0 is_stmt 1 discriminator 3
 2568 006c BB68     		ldr	r3, [r7, #8]
 2569 006e DA6A     		ldr	r2, [r3, #44]
 2570 0070 0B4B     		ldr	r3, .L197+12
 2571 0072 1B68     		ldr	r3, [r3]
 2572 0074 DB6A     		ldr	r3, [r3, #44]
 2573 0076 9A42     		cmp	r2, r3
 2574 0078 05D9     		bls	.L194
2872:../src/RTOS/tasks.c **** 	{
2873:../src/RTOS/tasks.c **** 		/* Return true if the task removed from the event list has
2874:../src/RTOS/tasks.c **** 		a higher priority than the calling task.  This allows
2875:../src/RTOS/tasks.c **** 		the calling task to know if it should force a context
2876:../src/RTOS/tasks.c **** 		switch now. */
2877:../src/RTOS/tasks.c **** 		xReturn = pdTRUE;
 2575              		.loc 1 2877 0
 2576 007a 0123     		movs	r3, #1
 2577 007c FB60     		str	r3, [r7, #12]
2878:../src/RTOS/tasks.c **** 
2879:../src/RTOS/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2880:../src/RTOS/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2881:../src/RTOS/tasks.c **** 		xYieldPending = pdTRUE;
 2578              		.loc 1 2881 0
 2579 007e 094B     		ldr	r3, .L197+16
 2580 0080 0122     		movs	r2, #1
 2581 0082 1A60     		str	r2, [r3]
 2582 0084 01E0     		b	.L195
 2583              	.L194:
2882:../src/RTOS/tasks.c **** 	}
2883:../src/RTOS/tasks.c **** 	else
2884:../src/RTOS/tasks.c **** 	{
2885:../src/RTOS/tasks.c **** 		xReturn = pdFALSE;
 2584              		.loc 1 2885 0
 2585 0086 0023     		movs	r3, #0
 2586 0088 FB60     		str	r3, [r7, #12]
 2587              	.L195:
2886:../src/RTOS/tasks.c **** 	}
2887:../src/RTOS/tasks.c **** 
2888:../src/RTOS/tasks.c **** 	return xReturn;
 2588              		.loc 1 2888 0
 2589 008a FB68     		ldr	r3, [r7, #12]
2889:../src/RTOS/tasks.c **** }
 2590              		.loc 1 2889 0
 2591 008c 1846     		mov	r0, r3
 2592 008e 1037     		adds	r7, r7, #16
 2593              		.cfi_def_cfa_offset 8
 2594 0090 BD46     		mov	sp, r7
 2595              		.cfi_def_cfa_register 13
 2596              		@ sp needed
 2597 0092 80BD     		pop	{r7, pc}
 2598              	.L198:
 2599              		.align	2
 2600              	.L197:
 2601 0094 00000000 		.word	uxSchedulerSuspended
 2602 0098 00000000 		.word	uxTopReadyPriority
 2603 009c 00000000 		.word	pxReadyTasksLists
 2604 00a0 00000000 		.word	pxCurrentTCB
 2605 00a4 00000000 		.word	xYieldPending
 2606              		.cfi_endproc
 2607              	.LFE26:
 2609              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2610              		.align	2
 2611              		.global	vTaskSetTimeOutState
 2612              		.thumb
 2613              		.thumb_func
 2615              	vTaskSetTimeOutState:
 2616              	.LFB27:
2890:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2891:../src/RTOS/tasks.c **** 
2892:../src/RTOS/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2893:../src/RTOS/tasks.c **** {
 2617              		.loc 1 2893 0
 2618              		.cfi_startproc
 2619              		@ args = 0, pretend = 0, frame = 8
 2620              		@ frame_needed = 1, uses_anonymous_args = 0
 2621              		@ link register save eliminated.
 2622 0000 80B4     		push	{r7}
 2623              		.cfi_def_cfa_offset 4
 2624              		.cfi_offset 7, -4
 2625 0002 83B0     		sub	sp, sp, #12
 2626              		.cfi_def_cfa_offset 16
 2627 0004 00AF     		add	r7, sp, #0
 2628              		.cfi_def_cfa_register 7
 2629 0006 7860     		str	r0, [r7, #4]
2894:../src/RTOS/tasks.c **** 	configASSERT( pxTimeOut );
 2630              		.loc 1 2894 0
 2631 0008 7B68     		ldr	r3, [r7, #4]
 2632 000a 002B     		cmp	r3, #0
 2633 000c 00D1     		bne	.L200
 2634              	.L201:
 2635              		.loc 1 2894 0 is_stmt 0 discriminator 1
 2636 000e FEE7     		b	.L201
 2637              	.L200:
2895:../src/RTOS/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2638              		.loc 1 2895 0 is_stmt 1
 2639 0010 064B     		ldr	r3, .L202
 2640 0012 1A68     		ldr	r2, [r3]
 2641 0014 7B68     		ldr	r3, [r7, #4]
 2642 0016 1A60     		str	r2, [r3]
2896:../src/RTOS/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2643              		.loc 1 2896 0
 2644 0018 054B     		ldr	r3, .L202+4
 2645 001a 1A68     		ldr	r2, [r3]
 2646 001c 7B68     		ldr	r3, [r7, #4]
 2647 001e 5A60     		str	r2, [r3, #4]
2897:../src/RTOS/tasks.c **** }
 2648              		.loc 1 2897 0
 2649 0020 0C37     		adds	r7, r7, #12
 2650              		.cfi_def_cfa_offset 4
 2651 0022 BD46     		mov	sp, r7
 2652              		.cfi_def_cfa_register 13
 2653              		@ sp needed
 2654 0024 5DF8047B 		ldr	r7, [sp], #4
 2655              		.cfi_restore 7
 2656              		.cfi_def_cfa_offset 0
 2657 0028 7047     		bx	lr
 2658              	.L203:
 2659 002a 00BF     		.align	2
 2660              	.L202:
 2661 002c 00000000 		.word	xNumOfOverflows
 2662 0030 00000000 		.word	xTickCount
 2663              		.cfi_endproc
 2664              	.LFE27:
 2666              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2667              		.align	2
 2668              		.global	xTaskCheckForTimeOut
 2669              		.thumb
 2670              		.thumb_func
 2672              	xTaskCheckForTimeOut:
 2673              	.LFB28:
2898:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2899:../src/RTOS/tasks.c **** 
2900:../src/RTOS/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2901:../src/RTOS/tasks.c **** {
 2674              		.loc 1 2901 0
 2675              		.cfi_startproc
 2676              		@ args = 0, pretend = 0, frame = 16
 2677              		@ frame_needed = 1, uses_anonymous_args = 0
 2678 0000 80B5     		push	{r7, lr}
 2679              		.cfi_def_cfa_offset 8
 2680              		.cfi_offset 7, -8
 2681              		.cfi_offset 14, -4
 2682 0002 84B0     		sub	sp, sp, #16
 2683              		.cfi_def_cfa_offset 24
 2684 0004 00AF     		add	r7, sp, #0
 2685              		.cfi_def_cfa_register 7
 2686 0006 7860     		str	r0, [r7, #4]
 2687 0008 3960     		str	r1, [r7]
2902:../src/RTOS/tasks.c **** BaseType_t xReturn;
2903:../src/RTOS/tasks.c **** 
2904:../src/RTOS/tasks.c **** 	configASSERT( pxTimeOut );
 2688              		.loc 1 2904 0
 2689 000a 7B68     		ldr	r3, [r7, #4]
 2690 000c 002B     		cmp	r3, #0
 2691 000e 00D1     		bne	.L205
 2692              	.L206:
 2693              		.loc 1 2904 0 is_stmt 0 discriminator 1
 2694 0010 FEE7     		b	.L206
 2695              	.L205:
2905:../src/RTOS/tasks.c **** 	configASSERT( pxTicksToWait );
 2696              		.loc 1 2905 0 is_stmt 1
 2697 0012 3B68     		ldr	r3, [r7]
 2698 0014 002B     		cmp	r3, #0
 2699 0016 00D1     		bne	.L207
 2700              	.L208:
 2701              		.loc 1 2905 0 is_stmt 0 discriminator 2
 2702 0018 FEE7     		b	.L208
 2703              	.L207:
2906:../src/RTOS/tasks.c **** 
2907:../src/RTOS/tasks.c **** 	taskENTER_CRITICAL();
 2704              		.loc 1 2907 0 is_stmt 1
 2705 001a FFF7FEFF 		bl	vPortEnterCritical
 2706              	.LBB33:
2908:../src/RTOS/tasks.c **** 	{
2909:../src/RTOS/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2910:../src/RTOS/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
 2707              		.loc 1 2910 0
 2708 001e 1C4B     		ldr	r3, .L214
 2709 0020 1B68     		ldr	r3, [r3]
 2710 0022 BB60     		str	r3, [r7, #8]
2911:../src/RTOS/tasks.c **** 
2912:../src/RTOS/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
2913:../src/RTOS/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
2914:../src/RTOS/tasks.c **** 			{
2915:../src/RTOS/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
2916:../src/RTOS/tasks.c **** 				but has the same result. */
2917:../src/RTOS/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
2918:../src/RTOS/tasks.c **** 				xReturn = pdTRUE;
2919:../src/RTOS/tasks.c **** 			}
2920:../src/RTOS/tasks.c **** 			else
2921:../src/RTOS/tasks.c **** 		#endif
2922:../src/RTOS/tasks.c **** 
2923:../src/RTOS/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2924:../src/RTOS/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2711              		.loc 1 2924 0
 2712 0024 3B68     		ldr	r3, [r7]
 2713 0026 1B68     		ldr	r3, [r3]
 2714 0028 B3F1FF3F 		cmp	r3, #-1
 2715 002c 02D1     		bne	.L209
2925:../src/RTOS/tasks.c **** 			{
2926:../src/RTOS/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
2927:../src/RTOS/tasks.c **** 				specified is the maximum block time then the task should block
2928:../src/RTOS/tasks.c **** 				indefinitely, and therefore never time out. */
2929:../src/RTOS/tasks.c **** 				xReturn = pdFALSE;
 2716              		.loc 1 2929 0
 2717 002e 0023     		movs	r3, #0
 2718 0030 FB60     		str	r3, [r7, #12]
 2719 0032 26E0     		b	.L210
 2720              	.L209:
2930:../src/RTOS/tasks.c **** 			}
2931:../src/RTOS/tasks.c **** 			else
2932:../src/RTOS/tasks.c **** 		#endif
2933:../src/RTOS/tasks.c **** 
2934:../src/RTOS/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 2721              		.loc 1 2934 0
 2722 0034 7B68     		ldr	r3, [r7, #4]
 2723 0036 1A68     		ldr	r2, [r3]
 2724 0038 164B     		ldr	r3, .L214+4
 2725 003a 1B68     		ldr	r3, [r3]
 2726 003c 9A42     		cmp	r2, r3
 2727 003e 07D0     		beq	.L211
 2728              		.loc 1 2934 0 is_stmt 0 discriminator 1
 2729 0040 7B68     		ldr	r3, [r7, #4]
 2730 0042 5A68     		ldr	r2, [r3, #4]
 2731 0044 BB68     		ldr	r3, [r7, #8]
 2732 0046 9A42     		cmp	r2, r3
 2733 0048 02D8     		bhi	.L211
2935:../src/RTOS/tasks.c **** 		{
2936:../src/RTOS/tasks.c **** 			/* The tick count is greater than the time at which
2937:../src/RTOS/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
2938:../src/RTOS/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
2939:../src/RTOS/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
2940:../src/RTOS/tasks.c **** 			was called. */
2941:../src/RTOS/tasks.c **** 			xReturn = pdTRUE;
 2734              		.loc 1 2941 0 is_stmt 1
 2735 004a 0123     		movs	r3, #1
 2736 004c FB60     		str	r3, [r7, #12]
 2737 004e 18E0     		b	.L210
 2738              	.L211:
2942:../src/RTOS/tasks.c **** 		}
2943:../src/RTOS/tasks.c **** 		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /
 2739              		.loc 1 2943 0
 2740 0050 7B68     		ldr	r3, [r7, #4]
 2741 0052 5B68     		ldr	r3, [r3, #4]
 2742 0054 BA68     		ldr	r2, [r7, #8]
 2743 0056 D21A     		subs	r2, r2, r3
 2744 0058 3B68     		ldr	r3, [r7]
 2745 005a 1B68     		ldr	r3, [r3]
 2746 005c 9A42     		cmp	r2, r3
 2747 005e 0ED2     		bcs	.L212
2944:../src/RTOS/tasks.c **** 		{
2945:../src/RTOS/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2946:../src/RTOS/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 2748              		.loc 1 2946 0
 2749 0060 3B68     		ldr	r3, [r7]
 2750 0062 1A68     		ldr	r2, [r3]
 2751 0064 7B68     		ldr	r3, [r7, #4]
 2752 0066 5968     		ldr	r1, [r3, #4]
 2753 0068 BB68     		ldr	r3, [r7, #8]
 2754 006a CB1A     		subs	r3, r1, r3
 2755 006c 1A44     		add	r2, r2, r3
 2756 006e 3B68     		ldr	r3, [r7]
 2757 0070 1A60     		str	r2, [r3]
2947:../src/RTOS/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2758              		.loc 1 2947 0
 2759 0072 7868     		ldr	r0, [r7, #4]
 2760 0074 FFF7FEFF 		bl	vTaskSetTimeOutState
2948:../src/RTOS/tasks.c **** 			xReturn = pdFALSE;
 2761              		.loc 1 2948 0
 2762 0078 0023     		movs	r3, #0
 2763 007a FB60     		str	r3, [r7, #12]
 2764 007c 01E0     		b	.L210
 2765              	.L212:
2949:../src/RTOS/tasks.c **** 		}
2950:../src/RTOS/tasks.c **** 		else
2951:../src/RTOS/tasks.c **** 		{
2952:../src/RTOS/tasks.c **** 			xReturn = pdTRUE;
 2766              		.loc 1 2952 0
 2767 007e 0123     		movs	r3, #1
 2768 0080 FB60     		str	r3, [r7, #12]
 2769              	.L210:
 2770              	.LBE33:
2953:../src/RTOS/tasks.c **** 		}
2954:../src/RTOS/tasks.c **** 	}
2955:../src/RTOS/tasks.c **** 	taskEXIT_CRITICAL();
 2771              		.loc 1 2955 0
 2772 0082 FFF7FEFF 		bl	vPortExitCritical
2956:../src/RTOS/tasks.c **** 
2957:../src/RTOS/tasks.c **** 	return xReturn;
 2773              		.loc 1 2957 0
 2774 0086 FB68     		ldr	r3, [r7, #12]
2958:../src/RTOS/tasks.c **** }
 2775              		.loc 1 2958 0
 2776 0088 1846     		mov	r0, r3
 2777 008a 1037     		adds	r7, r7, #16
 2778              		.cfi_def_cfa_offset 8
 2779 008c BD46     		mov	sp, r7
 2780              		.cfi_def_cfa_register 13
 2781              		@ sp needed
 2782 008e 80BD     		pop	{r7, pc}
 2783              	.L215:
 2784              		.align	2
 2785              	.L214:
 2786 0090 00000000 		.word	xTickCount
 2787 0094 00000000 		.word	xNumOfOverflows
 2788              		.cfi_endproc
 2789              	.LFE28:
 2791              		.section	.text.vTaskMissedYield,"ax",%progbits
 2792              		.align	2
 2793              		.global	vTaskMissedYield
 2794              		.thumb
 2795              		.thumb_func
 2797              	vTaskMissedYield:
 2798              	.LFB29:
2959:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2960:../src/RTOS/tasks.c **** 
2961:../src/RTOS/tasks.c **** void vTaskMissedYield( void )
2962:../src/RTOS/tasks.c **** {
 2799              		.loc 1 2962 0
 2800              		.cfi_startproc
 2801              		@ args = 0, pretend = 0, frame = 0
 2802              		@ frame_needed = 1, uses_anonymous_args = 0
 2803              		@ link register save eliminated.
 2804 0000 80B4     		push	{r7}
 2805              		.cfi_def_cfa_offset 4
 2806              		.cfi_offset 7, -4
 2807 0002 00AF     		add	r7, sp, #0
 2808              		.cfi_def_cfa_register 7
2963:../src/RTOS/tasks.c **** 	xYieldPending = pdTRUE;
 2809              		.loc 1 2963 0
 2810 0004 034B     		ldr	r3, .L217
 2811 0006 0122     		movs	r2, #1
 2812 0008 1A60     		str	r2, [r3]
2964:../src/RTOS/tasks.c **** }
 2813              		.loc 1 2964 0
 2814 000a BD46     		mov	sp, r7
 2815              		.cfi_def_cfa_register 13
 2816              		@ sp needed
 2817 000c 5DF8047B 		ldr	r7, [sp], #4
 2818              		.cfi_restore 7
 2819              		.cfi_def_cfa_offset 0
 2820 0010 7047     		bx	lr
 2821              	.L218:
 2822 0012 00BF     		.align	2
 2823              	.L217:
 2824 0014 00000000 		.word	xYieldPending
 2825              		.cfi_endproc
 2826              	.LFE29:
 2828              		.section	.text.prvIdleTask,"ax",%progbits
 2829              		.align	2
 2830              		.thumb
 2831              		.thumb_func
 2833              	prvIdleTask:
 2834              	.LFB30:
2965:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2966:../src/RTOS/tasks.c **** 
2967:../src/RTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2968:../src/RTOS/tasks.c **** 
2969:../src/RTOS/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2970:../src/RTOS/tasks.c **** 	{
2971:../src/RTOS/tasks.c **** 	UBaseType_t uxReturn;
2972:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
2973:../src/RTOS/tasks.c **** 
2974:../src/RTOS/tasks.c **** 		if( xTask != NULL )
2975:../src/RTOS/tasks.c **** 		{
2976:../src/RTOS/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2977:../src/RTOS/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2978:../src/RTOS/tasks.c **** 		}
2979:../src/RTOS/tasks.c **** 		else
2980:../src/RTOS/tasks.c **** 		{
2981:../src/RTOS/tasks.c **** 			uxReturn = 0U;
2982:../src/RTOS/tasks.c **** 		}
2983:../src/RTOS/tasks.c **** 
2984:../src/RTOS/tasks.c **** 		return uxReturn;
2985:../src/RTOS/tasks.c **** 	}
2986:../src/RTOS/tasks.c **** 
2987:../src/RTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2988:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
2989:../src/RTOS/tasks.c **** 
2990:../src/RTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2991:../src/RTOS/tasks.c **** 
2992:../src/RTOS/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2993:../src/RTOS/tasks.c **** 	{
2994:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
2995:../src/RTOS/tasks.c **** 
2996:../src/RTOS/tasks.c **** 		if( xTask != NULL )
2997:../src/RTOS/tasks.c **** 		{
2998:../src/RTOS/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2999:../src/RTOS/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3000:../src/RTOS/tasks.c **** 		}
3001:../src/RTOS/tasks.c **** 	}
3002:../src/RTOS/tasks.c **** 
3003:../src/RTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3004:../src/RTOS/tasks.c **** 
3005:../src/RTOS/tasks.c **** /*
3006:../src/RTOS/tasks.c ****  * -----------------------------------------------------------
3007:../src/RTOS/tasks.c ****  * The Idle task.
3008:../src/RTOS/tasks.c ****  * ----------------------------------------------------------
3009:../src/RTOS/tasks.c ****  *
3010:../src/RTOS/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3011:../src/RTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3012:../src/RTOS/tasks.c ****  *
3013:../src/RTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
3014:../src/RTOS/tasks.c ****  *
3015:../src/RTOS/tasks.c ****  */
3016:../src/RTOS/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3017:../src/RTOS/tasks.c **** {
 2835              		.loc 1 3017 0
 2836              		.cfi_startproc
 2837              		@ args = 0, pretend = 0, frame = 8
 2838              		@ frame_needed = 1, uses_anonymous_args = 0
 2839 0000 80B5     		push	{r7, lr}
 2840              		.cfi_def_cfa_offset 8
 2841              		.cfi_offset 7, -8
 2842              		.cfi_offset 14, -4
 2843 0002 82B0     		sub	sp, sp, #8
 2844              		.cfi_def_cfa_offset 16
 2845 0004 00AF     		add	r7, sp, #0
 2846              		.cfi_def_cfa_register 7
 2847 0006 7860     		str	r0, [r7, #4]
 2848              	.L221:
3018:../src/RTOS/tasks.c **** 	/* Stop warnings. */
3019:../src/RTOS/tasks.c **** 	( void ) pvParameters;
3020:../src/RTOS/tasks.c **** 
3021:../src/RTOS/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3022:../src/RTOS/tasks.c **** 	SCHEDULER IS STARTED. **/
3023:../src/RTOS/tasks.c **** 
3024:../src/RTOS/tasks.c **** 	for( ;; )
3025:../src/RTOS/tasks.c **** 	{
3026:../src/RTOS/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3027:../src/RTOS/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3028:../src/RTOS/tasks.c **** 		prvCheckTasksWaitingTermination();
 2849              		.loc 1 3028 0
 2850 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
3029:../src/RTOS/tasks.c **** 
3030:../src/RTOS/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3031:../src/RTOS/tasks.c **** 		{
3032:../src/RTOS/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3033:../src/RTOS/tasks.c **** 			see if any other task has become available.  If we are using
3034:../src/RTOS/tasks.c **** 			preemption we don't need to do this as any task becoming available
3035:../src/RTOS/tasks.c **** 			will automatically get the processor anyway. */
3036:../src/RTOS/tasks.c **** 			taskYIELD();
3037:../src/RTOS/tasks.c **** 		}
3038:../src/RTOS/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3039:../src/RTOS/tasks.c **** 
3040:../src/RTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3041:../src/RTOS/tasks.c **** 		{
3042:../src/RTOS/tasks.c **** 			/* When using preemption tasks of equal priority will be
3043:../src/RTOS/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3044:../src/RTOS/tasks.c **** 			to run then the idle task should yield before the end of the
3045:../src/RTOS/tasks.c **** 			timeslice.
3046:../src/RTOS/tasks.c **** 
3047:../src/RTOS/tasks.c **** 			A critical region is not required here as we are just reading from
3048:../src/RTOS/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3049:../src/RTOS/tasks.c **** 			the ready list at the idle priority contains more than one task
3050:../src/RTOS/tasks.c **** 			then a task other than the idle task is ready to execute. */
3051:../src/RTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 2851              		.loc 1 3051 0
 2852 000c 064B     		ldr	r3, .L222
 2853 000e 1B68     		ldr	r3, [r3]
 2854 0010 012B     		cmp	r3, #1
 2855 0012 07D9     		bls	.L220
3052:../src/RTOS/tasks.c **** 			{
3053:../src/RTOS/tasks.c **** 				taskYIELD();
 2856              		.loc 1 3053 0
 2857 0014 054B     		ldr	r3, .L222+4
 2858 0016 4FF08052 		mov	r2, #268435456
 2859 001a 1A60     		str	r2, [r3]
 2860              	@ 3053 "../src/RTOS/tasks.c" 1
 2861 001c BFF34F8F 		dsb
 2862              	@ 0 "" 2
 2863              	@ 3053 "../src/RTOS/tasks.c" 1
 2864 0020 BFF36F8F 		isb
 2865              	@ 0 "" 2
 2866              		.thumb
 2867              	.L220:
3054:../src/RTOS/tasks.c **** 			}
3055:../src/RTOS/tasks.c **** 			else
3056:../src/RTOS/tasks.c **** 			{
3057:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3058:../src/RTOS/tasks.c **** 			}
3059:../src/RTOS/tasks.c **** 		}
3060:../src/RTOS/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3061:../src/RTOS/tasks.c **** 
3062:../src/RTOS/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3063:../src/RTOS/tasks.c **** 		{
3064:../src/RTOS/tasks.c **** 			extern void vApplicationIdleHook( void );
3065:../src/RTOS/tasks.c **** 
3066:../src/RTOS/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3067:../src/RTOS/tasks.c **** 			allows the application designer to add background functionality
3068:../src/RTOS/tasks.c **** 			without the overhead of a separate task.
3069:../src/RTOS/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3070:../src/RTOS/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3071:../src/RTOS/tasks.c **** 			vApplicationIdleHook();
3072:../src/RTOS/tasks.c **** 		}
3073:../src/RTOS/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3074:../src/RTOS/tasks.c **** 
3075:../src/RTOS/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3076:../src/RTOS/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3077:../src/RTOS/tasks.c **** 		user defined low power mode	implementations require
3078:../src/RTOS/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3079:../src/RTOS/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3080:../src/RTOS/tasks.c **** 		{
3081:../src/RTOS/tasks.c **** 		TickType_t xExpectedIdleTime;
3082:../src/RTOS/tasks.c **** 
3083:../src/RTOS/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3084:../src/RTOS/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3085:../src/RTOS/tasks.c **** 			test of the expected idle time is performed without the
3086:../src/RTOS/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3087:../src/RTOS/tasks.c **** 			valid. */
3088:../src/RTOS/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3089:../src/RTOS/tasks.c **** 
3090:../src/RTOS/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3091:../src/RTOS/tasks.c **** 			{
3092:../src/RTOS/tasks.c **** 				vTaskSuspendAll();
3093:../src/RTOS/tasks.c **** 				{
3094:../src/RTOS/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3095:../src/RTOS/tasks.c **** 					time can be sampled again, and this time its value can
3096:../src/RTOS/tasks.c **** 					be used. */
3097:../src/RTOS/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3098:../src/RTOS/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3099:../src/RTOS/tasks.c **** 
3100:../src/RTOS/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3101:../src/RTOS/tasks.c **** 					{
3102:../src/RTOS/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3103:../src/RTOS/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3104:../src/RTOS/tasks.c **** 						traceLOW_POWER_IDLE_END();
3105:../src/RTOS/tasks.c **** 					}
3106:../src/RTOS/tasks.c **** 					else
3107:../src/RTOS/tasks.c **** 					{
3108:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3109:../src/RTOS/tasks.c **** 					}
3110:../src/RTOS/tasks.c **** 				}
3111:../src/RTOS/tasks.c **** 				( void ) xTaskResumeAll();
3112:../src/RTOS/tasks.c **** 			}
3113:../src/RTOS/tasks.c **** 			else
3114:../src/RTOS/tasks.c **** 			{
3115:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3116:../src/RTOS/tasks.c **** 			}
3117:../src/RTOS/tasks.c **** 		}
3118:../src/RTOS/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3119:../src/RTOS/tasks.c **** 	}
 2868              		.loc 1 3119 0
 2869 0024 F0E7     		b	.L221
 2870              	.L223:
 2871 0026 00BF     		.align	2
 2872              	.L222:
 2873 0028 00000000 		.word	pxReadyTasksLists
 2874 002c 04ED00E0 		.word	-536810236
 2875              		.cfi_endproc
 2876              	.LFE30:
 2878              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 2879              		.align	2
 2880              		.thumb
 2881              		.thumb_func
 2883              	prvInitialiseTaskLists:
 2884              	.LFB31:
3120:../src/RTOS/tasks.c **** }
3121:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3122:../src/RTOS/tasks.c **** 
3123:../src/RTOS/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3124:../src/RTOS/tasks.c **** 
3125:../src/RTOS/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3126:../src/RTOS/tasks.c **** 	{
3127:../src/RTOS/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3128:../src/RTOS/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3129:../src/RTOS/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3130:../src/RTOS/tasks.c **** 
3131:../src/RTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3132:../src/RTOS/tasks.c **** 		{
3133:../src/RTOS/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3134:../src/RTOS/tasks.c **** 			eReturn = eAbortSleep;
3135:../src/RTOS/tasks.c **** 		}
3136:../src/RTOS/tasks.c **** 		else if( xYieldPending != pdFALSE )
3137:../src/RTOS/tasks.c **** 		{
3138:../src/RTOS/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3139:../src/RTOS/tasks.c **** 			eReturn = eAbortSleep;
3140:../src/RTOS/tasks.c **** 		}
3141:../src/RTOS/tasks.c **** 		else
3142:../src/RTOS/tasks.c **** 		{
3143:../src/RTOS/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3144:../src/RTOS/tasks.c **** 			have an infinite block time rather than actually being suspended)
3145:../src/RTOS/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3146:../src/RTOS/tasks.c **** 			interrupts. */
3147:../src/RTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3148:../src/RTOS/tasks.c **** 			{
3149:../src/RTOS/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3150:../src/RTOS/tasks.c **** 			}
3151:../src/RTOS/tasks.c **** 			else
3152:../src/RTOS/tasks.c **** 			{
3153:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3154:../src/RTOS/tasks.c **** 			}
3155:../src/RTOS/tasks.c **** 		}
3156:../src/RTOS/tasks.c **** 
3157:../src/RTOS/tasks.c **** 		return eReturn;
3158:../src/RTOS/tasks.c **** 	}
3159:../src/RTOS/tasks.c **** 
3160:../src/RTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3161:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3162:../src/RTOS/tasks.c **** 
3163:../src/RTOS/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3164:../src/RTOS/tasks.c **** 
3165:../src/RTOS/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3166:../src/RTOS/tasks.c **** 	{
3167:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
3168:../src/RTOS/tasks.c **** 
3169:../src/RTOS/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3170:../src/RTOS/tasks.c **** 		{
3171:../src/RTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3172:../src/RTOS/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3173:../src/RTOS/tasks.c **** 		}
3174:../src/RTOS/tasks.c **** 	}
3175:../src/RTOS/tasks.c **** 
3176:../src/RTOS/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3177:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3178:../src/RTOS/tasks.c **** 
3179:../src/RTOS/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3180:../src/RTOS/tasks.c **** 
3181:../src/RTOS/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3182:../src/RTOS/tasks.c **** 	{
3183:../src/RTOS/tasks.c **** 	void *pvReturn = NULL;
3184:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
3185:../src/RTOS/tasks.c **** 
3186:../src/RTOS/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3187:../src/RTOS/tasks.c **** 		{
3188:../src/RTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3189:../src/RTOS/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3190:../src/RTOS/tasks.c **** 		}
3191:../src/RTOS/tasks.c **** 		else
3192:../src/RTOS/tasks.c **** 		{
3193:../src/RTOS/tasks.c **** 			pvReturn = NULL;
3194:../src/RTOS/tasks.c **** 		}
3195:../src/RTOS/tasks.c **** 
3196:../src/RTOS/tasks.c **** 		return pvReturn;
3197:../src/RTOS/tasks.c **** 	}
3198:../src/RTOS/tasks.c **** 
3199:../src/RTOS/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3200:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3201:../src/RTOS/tasks.c **** 
3202:../src/RTOS/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3203:../src/RTOS/tasks.c **** 
3204:../src/RTOS/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3205:../src/RTOS/tasks.c **** 	{
3206:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
3207:../src/RTOS/tasks.c **** 
3208:../src/RTOS/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3209:../src/RTOS/tasks.c **** 		the calling task. */
3210:../src/RTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3211:../src/RTOS/tasks.c **** 
3212:../src/RTOS/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3213:../src/RTOS/tasks.c **** 	}
3214:../src/RTOS/tasks.c **** 
3215:../src/RTOS/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3216:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3217:../src/RTOS/tasks.c **** 
3218:../src/RTOS/tasks.c **** static void prvInitialiseTaskLists( void )
3219:../src/RTOS/tasks.c **** {
 2885              		.loc 1 3219 0
 2886              		.cfi_startproc
 2887              		@ args = 0, pretend = 0, frame = 8
 2888              		@ frame_needed = 1, uses_anonymous_args = 0
 2889 0000 80B5     		push	{r7, lr}
 2890              		.cfi_def_cfa_offset 8
 2891              		.cfi_offset 7, -8
 2892              		.cfi_offset 14, -4
 2893 0002 82B0     		sub	sp, sp, #8
 2894              		.cfi_def_cfa_offset 16
 2895 0004 00AF     		add	r7, sp, #0
 2896              		.cfi_def_cfa_register 7
3220:../src/RTOS/tasks.c **** UBaseType_t uxPriority;
3221:../src/RTOS/tasks.c **** 
3222:../src/RTOS/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 2897              		.loc 1 3222 0
 2898 0006 0023     		movs	r3, #0
 2899 0008 7B60     		str	r3, [r7, #4]
 2900 000a 0CE0     		b	.L225
 2901              	.L226:
3223:../src/RTOS/tasks.c **** 	{
3224:../src/RTOS/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 2902              		.loc 1 3224 0 discriminator 3
 2903 000c 7A68     		ldr	r2, [r7, #4]
 2904 000e 1346     		mov	r3, r2
 2905 0010 9B00     		lsls	r3, r3, #2
 2906 0012 1344     		add	r3, r3, r2
 2907 0014 9B00     		lsls	r3, r3, #2
 2908 0016 104A     		ldr	r2, .L227
 2909 0018 1344     		add	r3, r3, r2
 2910 001a 1846     		mov	r0, r3
 2911 001c FFF7FEFF 		bl	vListInitialise
3222:../src/RTOS/tasks.c **** 	{
 2912              		.loc 1 3222 0 discriminator 3
 2913 0020 7B68     		ldr	r3, [r7, #4]
 2914 0022 0133     		adds	r3, r3, #1
 2915 0024 7B60     		str	r3, [r7, #4]
 2916              	.L225:
3222:../src/RTOS/tasks.c **** 	{
 2917              		.loc 1 3222 0 is_stmt 0 discriminator 1
 2918 0026 7B68     		ldr	r3, [r7, #4]
 2919 0028 092B     		cmp	r3, #9
 2920 002a EFD9     		bls	.L226
3225:../src/RTOS/tasks.c **** 	}
3226:../src/RTOS/tasks.c **** 
3227:../src/RTOS/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 2921              		.loc 1 3227 0 is_stmt 1
 2922 002c 0B48     		ldr	r0, .L227+4
 2923 002e FFF7FEFF 		bl	vListInitialise
3228:../src/RTOS/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 2924              		.loc 1 3228 0
 2925 0032 0B48     		ldr	r0, .L227+8
 2926 0034 FFF7FEFF 		bl	vListInitialise
3229:../src/RTOS/tasks.c **** 	vListInitialise( &xPendingReadyList );
 2927              		.loc 1 3229 0
 2928 0038 0A48     		ldr	r0, .L227+12
 2929 003a FFF7FEFF 		bl	vListInitialise
3230:../src/RTOS/tasks.c **** 
3231:../src/RTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3232:../src/RTOS/tasks.c **** 	{
3233:../src/RTOS/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3234:../src/RTOS/tasks.c **** 	}
3235:../src/RTOS/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3236:../src/RTOS/tasks.c **** 
3237:../src/RTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3238:../src/RTOS/tasks.c **** 	{
3239:../src/RTOS/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 2930              		.loc 1 3239 0
 2931 003e 0A48     		ldr	r0, .L227+16
 2932 0040 FFF7FEFF 		bl	vListInitialise
3240:../src/RTOS/tasks.c **** 	}
3241:../src/RTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3242:../src/RTOS/tasks.c **** 
3243:../src/RTOS/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3244:../src/RTOS/tasks.c **** 	using list2. */
3245:../src/RTOS/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 2933              		.loc 1 3245 0
 2934 0044 094B     		ldr	r3, .L227+20
 2935 0046 054A     		ldr	r2, .L227+4
 2936 0048 1A60     		str	r2, [r3]
3246:../src/RTOS/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 2937              		.loc 1 3246 0
 2938 004a 094B     		ldr	r3, .L227+24
 2939 004c 044A     		ldr	r2, .L227+8
 2940 004e 1A60     		str	r2, [r3]
3247:../src/RTOS/tasks.c **** }
 2941              		.loc 1 3247 0
 2942 0050 0837     		adds	r7, r7, #8
 2943              		.cfi_def_cfa_offset 8
 2944 0052 BD46     		mov	sp, r7
 2945              		.cfi_def_cfa_register 13
 2946              		@ sp needed
 2947 0054 80BD     		pop	{r7, pc}
 2948              	.L228:
 2949 0056 00BF     		.align	2
 2950              	.L227:
 2951 0058 00000000 		.word	pxReadyTasksLists
 2952 005c 00000000 		.word	xDelayedTaskList1
 2953 0060 00000000 		.word	xDelayedTaskList2
 2954 0064 00000000 		.word	xPendingReadyList
 2955 0068 00000000 		.word	xSuspendedTaskList
 2956 006c 00000000 		.word	pxDelayedTaskList
 2957 0070 00000000 		.word	pxOverflowDelayedTaskList
 2958              		.cfi_endproc
 2959              	.LFE31:
 2961              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 2962              		.align	2
 2963              		.thumb
 2964              		.thumb_func
 2966              	prvCheckTasksWaitingTermination:
 2967              	.LFB32:
3248:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3249:../src/RTOS/tasks.c **** 
3250:../src/RTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3251:../src/RTOS/tasks.c **** {
 2968              		.loc 1 3251 0
 2969              		.cfi_startproc
 2970              		@ args = 0, pretend = 0, frame = 0
 2971              		@ frame_needed = 1, uses_anonymous_args = 0
 2972              		@ link register save eliminated.
 2973 0000 80B4     		push	{r7}
 2974              		.cfi_def_cfa_offset 4
 2975              		.cfi_offset 7, -4
 2976 0002 00AF     		add	r7, sp, #0
 2977              		.cfi_def_cfa_register 7
3252:../src/RTOS/tasks.c **** 
3253:../src/RTOS/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3254:../src/RTOS/tasks.c **** 
3255:../src/RTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3256:../src/RTOS/tasks.c **** 	{
3257:../src/RTOS/tasks.c **** 		BaseType_t xListIsEmpty;
3258:../src/RTOS/tasks.c **** 
3259:../src/RTOS/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3260:../src/RTOS/tasks.c **** 		too often in the idle task. */
3261:../src/RTOS/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3262:../src/RTOS/tasks.c **** 		{
3263:../src/RTOS/tasks.c **** 			vTaskSuspendAll();
3264:../src/RTOS/tasks.c **** 			{
3265:../src/RTOS/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
3266:../src/RTOS/tasks.c **** 			}
3267:../src/RTOS/tasks.c **** 			( void ) xTaskResumeAll();
3268:../src/RTOS/tasks.c **** 
3269:../src/RTOS/tasks.c **** 			if( xListIsEmpty == pdFALSE )
3270:../src/RTOS/tasks.c **** 			{
3271:../src/RTOS/tasks.c **** 				TCB_t *pxTCB;
3272:../src/RTOS/tasks.c **** 
3273:../src/RTOS/tasks.c **** 				taskENTER_CRITICAL();
3274:../src/RTOS/tasks.c **** 				{
3275:../src/RTOS/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
3276:../src/RTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3277:../src/RTOS/tasks.c **** 					--uxCurrentNumberOfTasks;
3278:../src/RTOS/tasks.c **** 					--uxDeletedTasksWaitingCleanUp;
3279:../src/RTOS/tasks.c **** 				}
3280:../src/RTOS/tasks.c **** 				taskEXIT_CRITICAL();
3281:../src/RTOS/tasks.c **** 
3282:../src/RTOS/tasks.c **** 				prvDeleteTCB( pxTCB );
3283:../src/RTOS/tasks.c **** 			}
3284:../src/RTOS/tasks.c **** 			else
3285:../src/RTOS/tasks.c **** 			{
3286:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3287:../src/RTOS/tasks.c **** 			}
3288:../src/RTOS/tasks.c **** 		}
3289:../src/RTOS/tasks.c **** 	}
3290:../src/RTOS/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3291:../src/RTOS/tasks.c **** }
 2978              		.loc 1 3291 0
 2979 0004 BD46     		mov	sp, r7
 2980              		.cfi_def_cfa_register 13
 2981              		@ sp needed
 2982 0006 5DF8047B 		ldr	r7, [sp], #4
 2983              		.cfi_restore 7
 2984              		.cfi_def_cfa_offset 0
 2985 000a 7047     		bx	lr
 2986              		.cfi_endproc
 2987              	.LFE32:
 2989              		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
 2990              		.align	2
 2991              		.thumb
 2992              		.thumb_func
 2994              	prvResetNextTaskUnblockTime:
 2995              	.LFB33:
3292:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3293:../src/RTOS/tasks.c **** 
3294:../src/RTOS/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3295:../src/RTOS/tasks.c **** 
3296:../src/RTOS/tasks.c **** 	void vTaskGetTaskInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpa
3297:../src/RTOS/tasks.c **** 	{
3298:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
3299:../src/RTOS/tasks.c **** 
3300:../src/RTOS/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3301:../src/RTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3302:../src/RTOS/tasks.c **** 
3303:../src/RTOS/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3304:../src/RTOS/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3305:../src/RTOS/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3306:../src/RTOS/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3307:../src/RTOS/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3308:../src/RTOS/tasks.c **** 
3309:../src/RTOS/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3310:../src/RTOS/tasks.c **** 		{
3311:../src/RTOS/tasks.c **** 			/* If the task is in the suspended list then there is a chance it is
3312:../src/RTOS/tasks.c **** 			actually just blocked indefinitely - so really it should be reported as
3313:../src/RTOS/tasks.c **** 			being in the Blocked state. */
3314:../src/RTOS/tasks.c **** 			if( pxTaskStatus->eCurrentState == eSuspended )
3315:../src/RTOS/tasks.c **** 			{
3316:../src/RTOS/tasks.c **** 				vTaskSuspendAll();
3317:../src/RTOS/tasks.c **** 				{
3318:../src/RTOS/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3319:../src/RTOS/tasks.c **** 					{
3320:../src/RTOS/tasks.c **** 						pxTaskStatus->eCurrentState = eBlocked;
3321:../src/RTOS/tasks.c **** 					}
3322:../src/RTOS/tasks.c **** 				}
3323:../src/RTOS/tasks.c **** 				xTaskResumeAll();
3324:../src/RTOS/tasks.c **** 			}
3325:../src/RTOS/tasks.c **** 		}
3326:../src/RTOS/tasks.c **** 		#endif /* INCLUDE_vTaskSuspend */
3327:../src/RTOS/tasks.c **** 
3328:../src/RTOS/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3329:../src/RTOS/tasks.c **** 		{
3330:../src/RTOS/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3331:../src/RTOS/tasks.c **** 		}
3332:../src/RTOS/tasks.c **** 		#else
3333:../src/RTOS/tasks.c **** 		{
3334:../src/RTOS/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3335:../src/RTOS/tasks.c **** 		}
3336:../src/RTOS/tasks.c **** 		#endif
3337:../src/RTOS/tasks.c **** 
3338:../src/RTOS/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3339:../src/RTOS/tasks.c **** 		{
3340:../src/RTOS/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3341:../src/RTOS/tasks.c **** 		}
3342:../src/RTOS/tasks.c **** 		#else
3343:../src/RTOS/tasks.c **** 		{
3344:../src/RTOS/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3345:../src/RTOS/tasks.c **** 		}
3346:../src/RTOS/tasks.c **** 		#endif
3347:../src/RTOS/tasks.c **** 
3348:../src/RTOS/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the value
3349:../src/RTOS/tasks.c **** 		of eState passed into this function is eInvalid - otherwise the state is
3350:../src/RTOS/tasks.c **** 		just set to whatever is passed in. */
3351:../src/RTOS/tasks.c **** 		if( eState != eInvalid )
3352:../src/RTOS/tasks.c **** 		{
3353:../src/RTOS/tasks.c **** 			pxTaskStatus->eCurrentState = eState;
3354:../src/RTOS/tasks.c **** 		}
3355:../src/RTOS/tasks.c **** 		else
3356:../src/RTOS/tasks.c **** 		{
3357:../src/RTOS/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
3358:../src/RTOS/tasks.c **** 		}
3359:../src/RTOS/tasks.c **** 
3360:../src/RTOS/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3361:../src/RTOS/tasks.c **** 		parameter is provided to allow it to be skipped. */
3362:../src/RTOS/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3363:../src/RTOS/tasks.c **** 		{
3364:../src/RTOS/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3365:../src/RTOS/tasks.c **** 			{
3366:../src/RTOS/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3367:../src/RTOS/tasks.c **** 			}
3368:../src/RTOS/tasks.c **** 			#else
3369:../src/RTOS/tasks.c **** 			{
3370:../src/RTOS/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3371:../src/RTOS/tasks.c **** 			}
3372:../src/RTOS/tasks.c **** 			#endif
3373:../src/RTOS/tasks.c **** 		}
3374:../src/RTOS/tasks.c **** 		else
3375:../src/RTOS/tasks.c **** 		{
3376:../src/RTOS/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3377:../src/RTOS/tasks.c **** 		}
3378:../src/RTOS/tasks.c **** 	}
3379:../src/RTOS/tasks.c **** 
3380:../src/RTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3381:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3382:../src/RTOS/tasks.c **** 
3383:../src/RTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3384:../src/RTOS/tasks.c **** 
3385:../src/RTOS/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3386:../src/RTOS/tasks.c **** 	{
3387:../src/RTOS/tasks.c **** 	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3388:../src/RTOS/tasks.c **** 	UBaseType_t uxTask = 0;
3389:../src/RTOS/tasks.c **** 
3390:../src/RTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3391:../src/RTOS/tasks.c **** 		{
3392:../src/RTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3393:../src/RTOS/tasks.c **** 
3394:../src/RTOS/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3395:../src/RTOS/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3396:../src/RTOS/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3397:../src/RTOS/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3398:../src/RTOS/tasks.c **** 			do
3399:../src/RTOS/tasks.c **** 			{
3400:../src/RTOS/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3401:../src/RTOS/tasks.c **** 				vTaskGetTaskInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState 
3402:../src/RTOS/tasks.c **** 				uxTask++;
3403:../src/RTOS/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3404:../src/RTOS/tasks.c **** 		}
3405:../src/RTOS/tasks.c **** 		else
3406:../src/RTOS/tasks.c **** 		{
3407:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3408:../src/RTOS/tasks.c **** 		}
3409:../src/RTOS/tasks.c **** 
3410:../src/RTOS/tasks.c **** 		return uxTask;
3411:../src/RTOS/tasks.c **** 	}
3412:../src/RTOS/tasks.c **** 
3413:../src/RTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3414:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3415:../src/RTOS/tasks.c **** 
3416:../src/RTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3417:../src/RTOS/tasks.c **** 
3418:../src/RTOS/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3419:../src/RTOS/tasks.c **** 	{
3420:../src/RTOS/tasks.c **** 	uint32_t ulCount = 0U;
3421:../src/RTOS/tasks.c **** 
3422:../src/RTOS/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3423:../src/RTOS/tasks.c **** 		{
3424:../src/RTOS/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3425:../src/RTOS/tasks.c **** 			ulCount++;
3426:../src/RTOS/tasks.c **** 		}
3427:../src/RTOS/tasks.c **** 
3428:../src/RTOS/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3429:../src/RTOS/tasks.c **** 
3430:../src/RTOS/tasks.c **** 		return ( uint16_t ) ulCount;
3431:../src/RTOS/tasks.c **** 	}
3432:../src/RTOS/tasks.c **** 
3433:../src/RTOS/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3434:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3435:../src/RTOS/tasks.c **** 
3436:../src/RTOS/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3437:../src/RTOS/tasks.c **** 
3438:../src/RTOS/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3439:../src/RTOS/tasks.c **** 	{
3440:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
3441:../src/RTOS/tasks.c **** 	uint8_t *pucEndOfStack;
3442:../src/RTOS/tasks.c **** 	UBaseType_t uxReturn;
3443:../src/RTOS/tasks.c **** 
3444:../src/RTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3445:../src/RTOS/tasks.c **** 
3446:../src/RTOS/tasks.c **** 		#if portSTACK_GROWTH < 0
3447:../src/RTOS/tasks.c **** 		{
3448:../src/RTOS/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3449:../src/RTOS/tasks.c **** 		}
3450:../src/RTOS/tasks.c **** 		#else
3451:../src/RTOS/tasks.c **** 		{
3452:../src/RTOS/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3453:../src/RTOS/tasks.c **** 		}
3454:../src/RTOS/tasks.c **** 		#endif
3455:../src/RTOS/tasks.c **** 
3456:../src/RTOS/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3457:../src/RTOS/tasks.c **** 
3458:../src/RTOS/tasks.c **** 		return uxReturn;
3459:../src/RTOS/tasks.c **** 	}
3460:../src/RTOS/tasks.c **** 
3461:../src/RTOS/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3462:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3463:../src/RTOS/tasks.c **** 
3464:../src/RTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3465:../src/RTOS/tasks.c **** 
3466:../src/RTOS/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3467:../src/RTOS/tasks.c **** 	{
3468:../src/RTOS/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3469:../src/RTOS/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3470:../src/RTOS/tasks.c **** 		want to allocate and clean RAM statically. */
3471:../src/RTOS/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3472:../src/RTOS/tasks.c **** 
3473:../src/RTOS/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3474:../src/RTOS/tasks.c **** 		to the task to free any memory allocated at the application level. */
3475:../src/RTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3476:../src/RTOS/tasks.c **** 		{
3477:../src/RTOS/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3478:../src/RTOS/tasks.c **** 		}
3479:../src/RTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3480:../src/RTOS/tasks.c **** 
3481:../src/RTOS/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
3482:../src/RTOS/tasks.c **** 		{
3483:../src/RTOS/tasks.c **** 			/* The task can only have been allocated dynamically - free it
3484:../src/RTOS/tasks.c **** 			again. */
3485:../src/RTOS/tasks.c **** 			vPortFree( pxTCB->pxStack );
3486:../src/RTOS/tasks.c **** 			vPortFree( pxTCB );
3487:../src/RTOS/tasks.c **** 		}
3488:../src/RTOS/tasks.c **** 		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
3489:../src/RTOS/tasks.c **** 		{
3490:../src/RTOS/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3491:../src/RTOS/tasks.c **** 			check before attempting to free the memory. */
3492:../src/RTOS/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
3493:../src/RTOS/tasks.c **** 			{
3494:../src/RTOS/tasks.c **** 				vPortFree( pxTCB->pxStack );
3495:../src/RTOS/tasks.c **** 				vPortFree( pxTCB );
3496:../src/RTOS/tasks.c **** 			}
3497:../src/RTOS/tasks.c **** 			else
3498:../src/RTOS/tasks.c **** 			{
3499:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3500:../src/RTOS/tasks.c **** 			}
3501:../src/RTOS/tasks.c **** 		}
3502:../src/RTOS/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3503:../src/RTOS/tasks.c **** 	}
3504:../src/RTOS/tasks.c **** 
3505:../src/RTOS/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3506:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3507:../src/RTOS/tasks.c **** 
3508:../src/RTOS/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3509:../src/RTOS/tasks.c **** {
 2996              		.loc 1 3509 0
 2997              		.cfi_startproc
 2998              		@ args = 0, pretend = 0, frame = 8
 2999              		@ frame_needed = 1, uses_anonymous_args = 0
 3000              		@ link register save eliminated.
 3001 0000 80B4     		push	{r7}
 3002              		.cfi_def_cfa_offset 4
 3003              		.cfi_offset 7, -4
 3004 0002 83B0     		sub	sp, sp, #12
 3005              		.cfi_def_cfa_offset 16
 3006 0004 00AF     		add	r7, sp, #0
 3007              		.cfi_def_cfa_register 7
3510:../src/RTOS/tasks.c **** TCB_t *pxTCB;
3511:../src/RTOS/tasks.c **** 
3512:../src/RTOS/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 3008              		.loc 1 3512 0
 3009 0006 0E4B     		ldr	r3, .L235
 3010 0008 1B68     		ldr	r3, [r3]
 3011 000a 1B68     		ldr	r3, [r3]
 3012 000c 002B     		cmp	r3, #0
 3013 000e 01D1     		bne	.L231
 3014              		.loc 1 3512 0 is_stmt 0 discriminator 1
 3015 0010 0123     		movs	r3, #1
 3016 0012 00E0     		b	.L232
 3017              	.L231:
 3018              		.loc 1 3512 0 discriminator 2
 3019 0014 0023     		movs	r3, #0
 3020              	.L232:
 3021              		.loc 1 3512 0 discriminator 4
 3022 0016 002B     		cmp	r3, #0
 3023 0018 04D0     		beq	.L233
3513:../src/RTOS/tasks.c **** 	{
3514:../src/RTOS/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3515:../src/RTOS/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3516:../src/RTOS/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3517:../src/RTOS/tasks.c **** 		there is an item in the delayed list. */
3518:../src/RTOS/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 3024              		.loc 1 3518 0 is_stmt 1
 3025 001a 0A4B     		ldr	r3, .L235+4
 3026 001c 4FF0FF32 		mov	r2, #-1
 3027 0020 1A60     		str	r2, [r3]
 3028 0022 08E0     		b	.L230
 3029              	.L233:
3519:../src/RTOS/tasks.c **** 	}
3520:../src/RTOS/tasks.c **** 	else
3521:../src/RTOS/tasks.c **** 	{
3522:../src/RTOS/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3523:../src/RTOS/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3524:../src/RTOS/tasks.c **** 		which the task at the head of the delayed list should be removed
3525:../src/RTOS/tasks.c **** 		from the Blocked state. */
3526:../src/RTOS/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 3030              		.loc 1 3526 0
 3031 0024 064B     		ldr	r3, .L235
 3032 0026 1B68     		ldr	r3, [r3]
 3033 0028 DB68     		ldr	r3, [r3, #12]
 3034 002a DB68     		ldr	r3, [r3, #12]
 3035 002c 7B60     		str	r3, [r7, #4]
3527:../src/RTOS/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 3036              		.loc 1 3527 0
 3037 002e 7B68     		ldr	r3, [r7, #4]
 3038 0030 5B68     		ldr	r3, [r3, #4]
 3039 0032 044A     		ldr	r2, .L235+4
 3040 0034 1360     		str	r3, [r2]
 3041              	.L230:
3528:../src/RTOS/tasks.c **** 	}
3529:../src/RTOS/tasks.c **** }
 3042              		.loc 1 3529 0
 3043 0036 0C37     		adds	r7, r7, #12
 3044              		.cfi_def_cfa_offset 4
 3045 0038 BD46     		mov	sp, r7
 3046              		.cfi_def_cfa_register 13
 3047              		@ sp needed
 3048 003a 5DF8047B 		ldr	r7, [sp], #4
 3049              		.cfi_restore 7
 3050              		.cfi_def_cfa_offset 0
 3051 003e 7047     		bx	lr
 3052              	.L236:
 3053              		.align	2
 3054              	.L235:
 3055 0040 00000000 		.word	pxDelayedTaskList
 3056 0044 00000000 		.word	xNextTaskUnblockTime
 3057              		.cfi_endproc
 3058              	.LFE33:
 3060              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3061              		.align	2
 3062              		.global	xTaskGetCurrentTaskHandle
 3063              		.thumb
 3064              		.thumb_func
 3066              	xTaskGetCurrentTaskHandle:
 3067              	.LFB34:
3530:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3531:../src/RTOS/tasks.c **** 
3532:../src/RTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3533:../src/RTOS/tasks.c **** 
3534:../src/RTOS/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3535:../src/RTOS/tasks.c **** 	{
 3068              		.loc 1 3535 0
 3069              		.cfi_startproc
 3070              		@ args = 0, pretend = 0, frame = 8
 3071              		@ frame_needed = 1, uses_anonymous_args = 0
 3072              		@ link register save eliminated.
 3073 0000 80B4     		push	{r7}
 3074              		.cfi_def_cfa_offset 4
 3075              		.cfi_offset 7, -4
 3076 0002 83B0     		sub	sp, sp, #12
 3077              		.cfi_def_cfa_offset 16
 3078 0004 00AF     		add	r7, sp, #0
 3079              		.cfi_def_cfa_register 7
3536:../src/RTOS/tasks.c **** 	TaskHandle_t xReturn;
3537:../src/RTOS/tasks.c **** 
3538:../src/RTOS/tasks.c **** 		/* A critical section is not required as this is not called from
3539:../src/RTOS/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3540:../src/RTOS/tasks.c **** 		individual execution thread. */
3541:../src/RTOS/tasks.c **** 		xReturn = pxCurrentTCB;
 3080              		.loc 1 3541 0
 3081 0006 054B     		ldr	r3, .L239
 3082 0008 1B68     		ldr	r3, [r3]
 3083 000a 7B60     		str	r3, [r7, #4]
3542:../src/RTOS/tasks.c **** 
3543:../src/RTOS/tasks.c **** 		return xReturn;
 3084              		.loc 1 3543 0
 3085 000c 7B68     		ldr	r3, [r7, #4]
3544:../src/RTOS/tasks.c **** 	}
 3086              		.loc 1 3544 0
 3087 000e 1846     		mov	r0, r3
 3088 0010 0C37     		adds	r7, r7, #12
 3089              		.cfi_def_cfa_offset 4
 3090 0012 BD46     		mov	sp, r7
 3091              		.cfi_def_cfa_register 13
 3092              		@ sp needed
 3093 0014 5DF8047B 		ldr	r7, [sp], #4
 3094              		.cfi_restore 7
 3095              		.cfi_def_cfa_offset 0
 3096 0018 7047     		bx	lr
 3097              	.L240:
 3098 001a 00BF     		.align	2
 3099              	.L239:
 3100 001c 00000000 		.word	pxCurrentTCB
 3101              		.cfi_endproc
 3102              	.LFE34:
 3104              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 3105              		.align	2
 3106              		.global	xTaskGetSchedulerState
 3107              		.thumb
 3108              		.thumb_func
 3110              	xTaskGetSchedulerState:
 3111              	.LFB35:
3545:../src/RTOS/tasks.c **** 
3546:../src/RTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3547:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3548:../src/RTOS/tasks.c **** 
3549:../src/RTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3550:../src/RTOS/tasks.c **** 
3551:../src/RTOS/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3552:../src/RTOS/tasks.c **** 	{
 3112              		.loc 1 3552 0
 3113              		.cfi_startproc
 3114              		@ args = 0, pretend = 0, frame = 8
 3115              		@ frame_needed = 1, uses_anonymous_args = 0
 3116              		@ link register save eliminated.
 3117 0000 80B4     		push	{r7}
 3118              		.cfi_def_cfa_offset 4
 3119              		.cfi_offset 7, -4
 3120 0002 83B0     		sub	sp, sp, #12
 3121              		.cfi_def_cfa_offset 16
 3122 0004 00AF     		add	r7, sp, #0
 3123              		.cfi_def_cfa_register 7
3553:../src/RTOS/tasks.c **** 	BaseType_t xReturn;
3554:../src/RTOS/tasks.c **** 
3555:../src/RTOS/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 3124              		.loc 1 3555 0
 3125 0006 0B4B     		ldr	r3, .L246
 3126 0008 1B68     		ldr	r3, [r3]
 3127 000a 002B     		cmp	r3, #0
 3128 000c 02D1     		bne	.L242
3556:../src/RTOS/tasks.c **** 		{
3557:../src/RTOS/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 3129              		.loc 1 3557 0
 3130 000e 0123     		movs	r3, #1
 3131 0010 7B60     		str	r3, [r7, #4]
 3132 0012 08E0     		b	.L243
 3133              	.L242:
3558:../src/RTOS/tasks.c **** 		}
3559:../src/RTOS/tasks.c **** 		else
3560:../src/RTOS/tasks.c **** 		{
3561:../src/RTOS/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 3134              		.loc 1 3561 0
 3135 0014 084B     		ldr	r3, .L246+4
 3136 0016 1B68     		ldr	r3, [r3]
 3137 0018 002B     		cmp	r3, #0
 3138 001a 02D1     		bne	.L244
3562:../src/RTOS/tasks.c **** 			{
3563:../src/RTOS/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 3139              		.loc 1 3563 0
 3140 001c 0223     		movs	r3, #2
 3141 001e 7B60     		str	r3, [r7, #4]
 3142 0020 01E0     		b	.L243
 3143              	.L244:
3564:../src/RTOS/tasks.c **** 			}
3565:../src/RTOS/tasks.c **** 			else
3566:../src/RTOS/tasks.c **** 			{
3567:../src/RTOS/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 3144              		.loc 1 3567 0
 3145 0022 0023     		movs	r3, #0
 3146 0024 7B60     		str	r3, [r7, #4]
 3147              	.L243:
3568:../src/RTOS/tasks.c **** 			}
3569:../src/RTOS/tasks.c **** 		}
3570:../src/RTOS/tasks.c **** 
3571:../src/RTOS/tasks.c **** 		return xReturn;
 3148              		.loc 1 3571 0
 3149 0026 7B68     		ldr	r3, [r7, #4]
3572:../src/RTOS/tasks.c **** 	}
 3150              		.loc 1 3572 0
 3151 0028 1846     		mov	r0, r3
 3152 002a 0C37     		adds	r7, r7, #12
 3153              		.cfi_def_cfa_offset 4
 3154 002c BD46     		mov	sp, r7
 3155              		.cfi_def_cfa_register 13
 3156              		@ sp needed
 3157 002e 5DF8047B 		ldr	r7, [sp], #4
 3158              		.cfi_restore 7
 3159              		.cfi_def_cfa_offset 0
 3160 0032 7047     		bx	lr
 3161              	.L247:
 3162              		.align	2
 3163              	.L246:
 3164 0034 00000000 		.word	xSchedulerRunning
 3165 0038 00000000 		.word	uxSchedulerSuspended
 3166              		.cfi_endproc
 3167              	.LFE35:
 3169              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3170              		.align	2
 3171              		.global	vTaskPriorityInherit
 3172              		.thumb
 3173              		.thumb_func
 3175              	vTaskPriorityInherit:
 3176              	.LFB36:
3573:../src/RTOS/tasks.c **** 
3574:../src/RTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3575:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3576:../src/RTOS/tasks.c **** 
3577:../src/RTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3578:../src/RTOS/tasks.c **** 
3579:../src/RTOS/tasks.c **** 	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3580:../src/RTOS/tasks.c **** 	{
 3177              		.loc 1 3580 0
 3178              		.cfi_startproc
 3179              		@ args = 0, pretend = 0, frame = 16
 3180              		@ frame_needed = 1, uses_anonymous_args = 0
 3181 0000 80B5     		push	{r7, lr}
 3182              		.cfi_def_cfa_offset 8
 3183              		.cfi_offset 7, -8
 3184              		.cfi_offset 14, -4
 3185 0002 84B0     		sub	sp, sp, #16
 3186              		.cfi_def_cfa_offset 24
 3187 0004 00AF     		add	r7, sp, #0
 3188              		.cfi_def_cfa_register 7
 3189 0006 7860     		str	r0, [r7, #4]
3581:../src/RTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 3190              		.loc 1 3581 0
 3191 0008 7B68     		ldr	r3, [r7, #4]
 3192 000a FB60     		str	r3, [r7, #12]
3582:../src/RTOS/tasks.c **** 
3583:../src/RTOS/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3584:../src/RTOS/tasks.c **** 		locked then the mutex holder might now be NULL. */
3585:../src/RTOS/tasks.c **** 		if( pxMutexHolder != NULL )
 3193              		.loc 1 3585 0
 3194 000c 7B68     		ldr	r3, [r7, #4]
 3195 000e 002B     		cmp	r3, #0
 3196 0010 4AD0     		beq	.L248
3586:../src/RTOS/tasks.c **** 		{
3587:../src/RTOS/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3588:../src/RTOS/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3589:../src/RTOS/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3590:../src/RTOS/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3197              		.loc 1 3590 0
 3198 0012 FB68     		ldr	r3, [r7, #12]
 3199 0014 DA6A     		ldr	r2, [r3, #44]
 3200 0016 264B     		ldr	r3, .L256
 3201 0018 1B68     		ldr	r3, [r3]
 3202 001a DB6A     		ldr	r3, [r3, #44]
 3203 001c 9A42     		cmp	r2, r3
 3204 001e 43D2     		bcs	.L248
3591:../src/RTOS/tasks.c **** 			{
3592:../src/RTOS/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3593:../src/RTOS/tasks.c **** 				priority.  Only reset the event list item value if the value is
3594:../src/RTOS/tasks.c **** 				not	being used for anything else. */
3595:../src/RTOS/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 3205              		.loc 1 3595 0
 3206 0020 FB68     		ldr	r3, [r7, #12]
 3207 0022 9B69     		ldr	r3, [r3, #24]
 3208 0024 002B     		cmp	r3, #0
 3209 0026 06DB     		blt	.L250
3596:../src/RTOS/tasks.c **** 				{
3597:../src/RTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 3210              		.loc 1 3597 0
 3211 0028 214B     		ldr	r3, .L256
 3212 002a 1B68     		ldr	r3, [r3]
 3213 002c DB6A     		ldr	r3, [r3, #44]
 3214 002e C3F10A02 		rsb	r2, r3, #10
 3215 0032 FB68     		ldr	r3, [r7, #12]
 3216 0034 9A61     		str	r2, [r3, #24]
 3217              	.L250:
3598:../src/RTOS/tasks.c **** 				}
3599:../src/RTOS/tasks.c **** 				else
3600:../src/RTOS/tasks.c **** 				{
3601:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3602:../src/RTOS/tasks.c **** 				}
3603:../src/RTOS/tasks.c **** 
3604:../src/RTOS/tasks.c **** 				/* If the task being modified is in the ready state it will need
3605:../src/RTOS/tasks.c **** 				to be moved into a new list. */
3606:../src/RTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListI
 3218              		.loc 1 3606 0
 3219 0036 FB68     		ldr	r3, [r7, #12]
 3220 0038 5969     		ldr	r1, [r3, #20]
 3221 003a FB68     		ldr	r3, [r7, #12]
 3222 003c DA6A     		ldr	r2, [r3, #44]
 3223 003e 1346     		mov	r3, r2
 3224 0040 9B00     		lsls	r3, r3, #2
 3225 0042 1344     		add	r3, r3, r2
 3226 0044 9B00     		lsls	r3, r3, #2
 3227 0046 1B4A     		ldr	r2, .L256+4
 3228 0048 1344     		add	r3, r3, r2
 3229 004a 9942     		cmp	r1, r3
 3230 004c 01D1     		bne	.L251
 3231              		.loc 1 3606 0 is_stmt 0 discriminator 1
 3232 004e 0123     		movs	r3, #1
 3233 0050 00E0     		b	.L252
 3234              	.L251:
 3235              		.loc 1 3606 0 discriminator 2
 3236 0052 0023     		movs	r3, #0
 3237              	.L252:
 3238              		.loc 1 3606 0 discriminator 4
 3239 0054 002B     		cmp	r3, #0
 3240 0056 22D0     		beq	.L253
3607:../src/RTOS/tasks.c **** 				{
3608:../src/RTOS/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 3241              		.loc 1 3608 0 is_stmt 1
 3242 0058 FB68     		ldr	r3, [r7, #12]
 3243 005a 0433     		adds	r3, r3, #4
 3244 005c 1846     		mov	r0, r3
 3245 005e FFF7FEFF 		bl	uxListRemove
3609:../src/RTOS/tasks.c **** 					{
3610:../src/RTOS/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3611:../src/RTOS/tasks.c **** 					}
3612:../src/RTOS/tasks.c **** 					else
3613:../src/RTOS/tasks.c **** 					{
3614:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3615:../src/RTOS/tasks.c **** 					}
3616:../src/RTOS/tasks.c **** 
3617:../src/RTOS/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3618:../src/RTOS/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3246              		.loc 1 3618 0
 3247 0062 134B     		ldr	r3, .L256
 3248 0064 1B68     		ldr	r3, [r3]
 3249 0066 DA6A     		ldr	r2, [r3, #44]
 3250 0068 FB68     		ldr	r3, [r7, #12]
 3251 006a DA62     		str	r2, [r3, #44]
3619:../src/RTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3252              		.loc 1 3619 0
 3253 006c FB68     		ldr	r3, [r7, #12]
 3254 006e DA6A     		ldr	r2, [r3, #44]
 3255 0070 114B     		ldr	r3, .L256+8
 3256 0072 1B68     		ldr	r3, [r3]
 3257 0074 9A42     		cmp	r2, r3
 3258 0076 03D9     		bls	.L254
 3259              		.loc 1 3619 0 is_stmt 0 discriminator 1
 3260 0078 FB68     		ldr	r3, [r7, #12]
 3261 007a DB6A     		ldr	r3, [r3, #44]
 3262 007c 0E4A     		ldr	r2, .L256+8
 3263 007e 1360     		str	r3, [r2]
 3264              	.L254:
 3265              		.loc 1 3619 0 discriminator 3
 3266 0080 FB68     		ldr	r3, [r7, #12]
 3267 0082 DA6A     		ldr	r2, [r3, #44]
 3268 0084 1346     		mov	r3, r2
 3269 0086 9B00     		lsls	r3, r3, #2
 3270 0088 1344     		add	r3, r3, r2
 3271 008a 9B00     		lsls	r3, r3, #2
 3272 008c 094A     		ldr	r2, .L256+4
 3273 008e 1A44     		add	r2, r2, r3
 3274 0090 FB68     		ldr	r3, [r7, #12]
 3275 0092 0433     		adds	r3, r3, #4
 3276 0094 1046     		mov	r0, r2
 3277 0096 1946     		mov	r1, r3
 3278 0098 FFF7FEFF 		bl	vListInsertEnd
 3279 009c 04E0     		b	.L248
 3280              	.L253:
3620:../src/RTOS/tasks.c **** 				}
3621:../src/RTOS/tasks.c **** 				else
3622:../src/RTOS/tasks.c **** 				{
3623:../src/RTOS/tasks.c **** 					/* Just inherit the priority. */
3624:../src/RTOS/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3281              		.loc 1 3624 0 is_stmt 1
 3282 009e 044B     		ldr	r3, .L256
 3283 00a0 1B68     		ldr	r3, [r3]
 3284 00a2 DA6A     		ldr	r2, [r3, #44]
 3285 00a4 FB68     		ldr	r3, [r7, #12]
 3286 00a6 DA62     		str	r2, [r3, #44]
 3287              	.L248:
3625:../src/RTOS/tasks.c **** 				}
3626:../src/RTOS/tasks.c **** 
3627:../src/RTOS/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3628:../src/RTOS/tasks.c **** 			}
3629:../src/RTOS/tasks.c **** 			else
3630:../src/RTOS/tasks.c **** 			{
3631:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3632:../src/RTOS/tasks.c **** 			}
3633:../src/RTOS/tasks.c **** 		}
3634:../src/RTOS/tasks.c **** 		else
3635:../src/RTOS/tasks.c **** 		{
3636:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3637:../src/RTOS/tasks.c **** 		}
3638:../src/RTOS/tasks.c **** 	}
 3288              		.loc 1 3638 0
 3289 00a8 1037     		adds	r7, r7, #16
 3290              		.cfi_def_cfa_offset 8
 3291 00aa BD46     		mov	sp, r7
 3292              		.cfi_def_cfa_register 13
 3293              		@ sp needed
 3294 00ac 80BD     		pop	{r7, pc}
 3295              	.L257:
 3296 00ae 00BF     		.align	2
 3297              	.L256:
 3298 00b0 00000000 		.word	pxCurrentTCB
 3299 00b4 00000000 		.word	pxReadyTasksLists
 3300 00b8 00000000 		.word	uxTopReadyPriority
 3301              		.cfi_endproc
 3302              	.LFE36:
 3304              		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 3305              		.align	2
 3306              		.global	xTaskPriorityDisinherit
 3307              		.thumb
 3308              		.thumb_func
 3310              	xTaskPriorityDisinherit:
 3311              	.LFB37:
3639:../src/RTOS/tasks.c **** 
3640:../src/RTOS/tasks.c **** #endif /* configUSE_MUTEXES */
3641:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3642:../src/RTOS/tasks.c **** 
3643:../src/RTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3644:../src/RTOS/tasks.c **** 
3645:../src/RTOS/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3646:../src/RTOS/tasks.c **** 	{
 3312              		.loc 1 3646 0
 3313              		.cfi_startproc
 3314              		@ args = 0, pretend = 0, frame = 16
 3315              		@ frame_needed = 1, uses_anonymous_args = 0
 3316 0000 80B5     		push	{r7, lr}
 3317              		.cfi_def_cfa_offset 8
 3318              		.cfi_offset 7, -8
 3319              		.cfi_offset 14, -4
 3320 0002 84B0     		sub	sp, sp, #16
 3321              		.cfi_def_cfa_offset 24
 3322 0004 00AF     		add	r7, sp, #0
 3323              		.cfi_def_cfa_register 7
 3324 0006 7860     		str	r0, [r7, #4]
3647:../src/RTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 3325              		.loc 1 3647 0
 3326 0008 7B68     		ldr	r3, [r7, #4]
 3327 000a BB60     		str	r3, [r7, #8]
3648:../src/RTOS/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 3328              		.loc 1 3648 0
 3329 000c 0023     		movs	r3, #0
 3330 000e FB60     		str	r3, [r7, #12]
3649:../src/RTOS/tasks.c **** 
3650:../src/RTOS/tasks.c **** 		if( pxMutexHolder != NULL )
 3331              		.loc 1 3650 0
 3332 0010 7B68     		ldr	r3, [r7, #4]
 3333 0012 002B     		cmp	r3, #0
 3334 0014 42D0     		beq	.L259
3651:../src/RTOS/tasks.c **** 		{
3652:../src/RTOS/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3653:../src/RTOS/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3654:../src/RTOS/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3655:../src/RTOS/tasks.c **** 			be the running state task. */
3656:../src/RTOS/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
 3335              		.loc 1 3656 0
 3336 0016 244B     		ldr	r3, .L266
 3337 0018 1B68     		ldr	r3, [r3]
 3338 001a BA68     		ldr	r2, [r7, #8]
 3339 001c 9A42     		cmp	r2, r3
 3340 001e 00D0     		beq	.L260
 3341              	.L261:
 3342              		.loc 1 3656 0 is_stmt 0 discriminator 1
 3343 0020 FEE7     		b	.L261
 3344              	.L260:
3657:../src/RTOS/tasks.c **** 
3658:../src/RTOS/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
 3345              		.loc 1 3658 0 is_stmt 1
 3346 0022 BB68     		ldr	r3, [r7, #8]
 3347 0024 1B6C     		ldr	r3, [r3, #64]
 3348 0026 002B     		cmp	r3, #0
 3349 0028 00D1     		bne	.L262
 3350              	.L263:
 3351              		.loc 1 3658 0 is_stmt 0 discriminator 2
 3352 002a FEE7     		b	.L263
 3353              	.L262:
3659:../src/RTOS/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
 3354              		.loc 1 3659 0 is_stmt 1
 3355 002c BB68     		ldr	r3, [r7, #8]
 3356 002e 1B6C     		ldr	r3, [r3, #64]
 3357 0030 5A1E     		subs	r2, r3, #1
 3358 0032 BB68     		ldr	r3, [r7, #8]
 3359 0034 1A64     		str	r2, [r3, #64]
3660:../src/RTOS/tasks.c **** 
3661:../src/RTOS/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3662:../src/RTOS/tasks.c **** 			task? */
3663:../src/RTOS/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3360              		.loc 1 3663 0
 3361 0036 BB68     		ldr	r3, [r7, #8]
 3362 0038 DA6A     		ldr	r2, [r3, #44]
 3363 003a BB68     		ldr	r3, [r7, #8]
 3364 003c DB6B     		ldr	r3, [r3, #60]
 3365 003e 9A42     		cmp	r2, r3
 3366 0040 2CD0     		beq	.L259
3664:../src/RTOS/tasks.c **** 			{
3665:../src/RTOS/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3666:../src/RTOS/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 3367              		.loc 1 3666 0
 3368 0042 BB68     		ldr	r3, [r7, #8]
 3369 0044 1B6C     		ldr	r3, [r3, #64]
 3370 0046 002B     		cmp	r3, #0
 3371 0048 28D1     		bne	.L259
3667:../src/RTOS/tasks.c **** 				{
3668:../src/RTOS/tasks.c **** 					/* A task can only have an inherited priority if it holds
3669:../src/RTOS/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3670:../src/RTOS/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3671:../src/RTOS/tasks.c **** 					holding	task then it must be the running state task.  Remove
3672:../src/RTOS/tasks.c **** 					the	holding task from the ready	list. */
3673:../src/RTOS/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 3372              		.loc 1 3673 0
 3373 004a BB68     		ldr	r3, [r7, #8]
 3374 004c 0433     		adds	r3, r3, #4
 3375 004e 1846     		mov	r0, r3
 3376 0050 FFF7FEFF 		bl	uxListRemove
3674:../src/RTOS/tasks.c **** 					{
3675:../src/RTOS/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3676:../src/RTOS/tasks.c **** 					}
3677:../src/RTOS/tasks.c **** 					else
3678:../src/RTOS/tasks.c **** 					{
3679:../src/RTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3680:../src/RTOS/tasks.c **** 					}
3681:../src/RTOS/tasks.c **** 
3682:../src/RTOS/tasks.c **** 					/* Disinherit the priority before adding the task into the
3683:../src/RTOS/tasks.c **** 					new	ready list. */
3684:../src/RTOS/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3685:../src/RTOS/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
 3377              		.loc 1 3685 0
 3378 0054 BB68     		ldr	r3, [r7, #8]
 3379 0056 DA6B     		ldr	r2, [r3, #60]
 3380 0058 BB68     		ldr	r3, [r7, #8]
 3381 005a DA62     		str	r2, [r3, #44]
3686:../src/RTOS/tasks.c **** 
3687:../src/RTOS/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3688:../src/RTOS/tasks.c **** 					any other purpose if this task is running, and it must be
3689:../src/RTOS/tasks.c **** 					running to give back the mutex. */
3690:../src/RTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 3382              		.loc 1 3690 0
 3383 005c BB68     		ldr	r3, [r7, #8]
 3384 005e DB6A     		ldr	r3, [r3, #44]
 3385 0060 C3F10A02 		rsb	r2, r3, #10
 3386 0064 BB68     		ldr	r3, [r7, #8]
 3387 0066 9A61     		str	r2, [r3, #24]
3691:../src/RTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3388              		.loc 1 3691 0
 3389 0068 BB68     		ldr	r3, [r7, #8]
 3390 006a DA6A     		ldr	r2, [r3, #44]
 3391 006c 0F4B     		ldr	r3, .L266+4
 3392 006e 1B68     		ldr	r3, [r3]
 3393 0070 9A42     		cmp	r2, r3
 3394 0072 03D9     		bls	.L264
 3395              		.loc 1 3691 0 is_stmt 0 discriminator 1
 3396 0074 BB68     		ldr	r3, [r7, #8]
 3397 0076 DB6A     		ldr	r3, [r3, #44]
 3398 0078 0C4A     		ldr	r2, .L266+4
 3399 007a 1360     		str	r3, [r2]
 3400              	.L264:
 3401              		.loc 1 3691 0 discriminator 3
 3402 007c BB68     		ldr	r3, [r7, #8]
 3403 007e DA6A     		ldr	r2, [r3, #44]
 3404 0080 1346     		mov	r3, r2
 3405 0082 9B00     		lsls	r3, r3, #2
 3406 0084 1344     		add	r3, r3, r2
 3407 0086 9B00     		lsls	r3, r3, #2
 3408 0088 094A     		ldr	r2, .L266+8
 3409 008a 1A44     		add	r2, r2, r3
 3410 008c BB68     		ldr	r3, [r7, #8]
 3411 008e 0433     		adds	r3, r3, #4
 3412 0090 1046     		mov	r0, r2
 3413 0092 1946     		mov	r1, r3
 3414 0094 FFF7FEFF 		bl	vListInsertEnd
3692:../src/RTOS/tasks.c **** 
3693:../src/RTOS/tasks.c **** 					/* Return true to indicate that a context switch is required.
3694:../src/RTOS/tasks.c **** 					This is only actually required in the corner case whereby
3695:../src/RTOS/tasks.c **** 					multiple mutexes were held and the mutexes were given back
3696:../src/RTOS/tasks.c **** 					in an order different to that in which they were taken.
3697:../src/RTOS/tasks.c **** 					If a context switch did not occur when the first mutex was
3698:../src/RTOS/tasks.c **** 					returned, even if a task was waiting on it, then a context
3699:../src/RTOS/tasks.c **** 					switch should occur when the last mutex is returned whether
3700:../src/RTOS/tasks.c **** 					a task is waiting on it or not. */
3701:../src/RTOS/tasks.c **** 					xReturn = pdTRUE;
 3415              		.loc 1 3701 0 is_stmt 1 discriminator 3
 3416 0098 0123     		movs	r3, #1
 3417 009a FB60     		str	r3, [r7, #12]
 3418              	.L259:
3702:../src/RTOS/tasks.c **** 				}
3703:../src/RTOS/tasks.c **** 				else
3704:../src/RTOS/tasks.c **** 				{
3705:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3706:../src/RTOS/tasks.c **** 				}
3707:../src/RTOS/tasks.c **** 			}
3708:../src/RTOS/tasks.c **** 			else
3709:../src/RTOS/tasks.c **** 			{
3710:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3711:../src/RTOS/tasks.c **** 			}
3712:../src/RTOS/tasks.c **** 		}
3713:../src/RTOS/tasks.c **** 		else
3714:../src/RTOS/tasks.c **** 		{
3715:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3716:../src/RTOS/tasks.c **** 		}
3717:../src/RTOS/tasks.c **** 
3718:../src/RTOS/tasks.c **** 		return xReturn;
 3419              		.loc 1 3718 0
 3420 009c FB68     		ldr	r3, [r7, #12]
3719:../src/RTOS/tasks.c **** 	}
 3421              		.loc 1 3719 0
 3422 009e 1846     		mov	r0, r3
 3423 00a0 1037     		adds	r7, r7, #16
 3424              		.cfi_def_cfa_offset 8
 3425 00a2 BD46     		mov	sp, r7
 3426              		.cfi_def_cfa_register 13
 3427              		@ sp needed
 3428 00a4 80BD     		pop	{r7, pc}
 3429              	.L267:
 3430 00a6 00BF     		.align	2
 3431              	.L266:
 3432 00a8 00000000 		.word	pxCurrentTCB
 3433 00ac 00000000 		.word	uxTopReadyPriority
 3434 00b0 00000000 		.word	pxReadyTasksLists
 3435              		.cfi_endproc
 3436              	.LFE37:
 3438              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 3439              		.align	2
 3440              		.global	uxTaskResetEventItemValue
 3441              		.thumb
 3442              		.thumb_func
 3444              	uxTaskResetEventItemValue:
 3445              	.LFB38:
3720:../src/RTOS/tasks.c **** 
3721:../src/RTOS/tasks.c **** #endif /* configUSE_MUTEXES */
3722:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3723:../src/RTOS/tasks.c **** 
3724:../src/RTOS/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3725:../src/RTOS/tasks.c **** 
3726:../src/RTOS/tasks.c **** 	void vTaskEnterCritical( void )
3727:../src/RTOS/tasks.c **** 	{
3728:../src/RTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
3729:../src/RTOS/tasks.c **** 
3730:../src/RTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3731:../src/RTOS/tasks.c **** 		{
3732:../src/RTOS/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
3733:../src/RTOS/tasks.c **** 
3734:../src/RTOS/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
3735:../src/RTOS/tasks.c **** 			function so	assert() if it is being called from an interrupt
3736:../src/RTOS/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
3737:../src/RTOS/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
3738:../src/RTOS/tasks.c **** 			protect against recursive calls if the assert function also uses a
3739:../src/RTOS/tasks.c **** 			critical section. */
3740:../src/RTOS/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
3741:../src/RTOS/tasks.c **** 			{
3742:../src/RTOS/tasks.c **** 				portASSERT_IF_IN_ISR();
3743:../src/RTOS/tasks.c **** 			}
3744:../src/RTOS/tasks.c **** 		}
3745:../src/RTOS/tasks.c **** 		else
3746:../src/RTOS/tasks.c **** 		{
3747:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3748:../src/RTOS/tasks.c **** 		}
3749:../src/RTOS/tasks.c **** 	}
3750:../src/RTOS/tasks.c **** 
3751:../src/RTOS/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3752:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3753:../src/RTOS/tasks.c **** 
3754:../src/RTOS/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3755:../src/RTOS/tasks.c **** 
3756:../src/RTOS/tasks.c **** 	void vTaskExitCritical( void )
3757:../src/RTOS/tasks.c **** 	{
3758:../src/RTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3759:../src/RTOS/tasks.c **** 		{
3760:../src/RTOS/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
3761:../src/RTOS/tasks.c **** 			{
3762:../src/RTOS/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
3763:../src/RTOS/tasks.c **** 
3764:../src/RTOS/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
3765:../src/RTOS/tasks.c **** 				{
3766:../src/RTOS/tasks.c **** 					portENABLE_INTERRUPTS();
3767:../src/RTOS/tasks.c **** 				}
3768:../src/RTOS/tasks.c **** 				else
3769:../src/RTOS/tasks.c **** 				{
3770:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3771:../src/RTOS/tasks.c **** 				}
3772:../src/RTOS/tasks.c **** 			}
3773:../src/RTOS/tasks.c **** 			else
3774:../src/RTOS/tasks.c **** 			{
3775:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3776:../src/RTOS/tasks.c **** 			}
3777:../src/RTOS/tasks.c **** 		}
3778:../src/RTOS/tasks.c **** 		else
3779:../src/RTOS/tasks.c **** 		{
3780:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3781:../src/RTOS/tasks.c **** 		}
3782:../src/RTOS/tasks.c **** 	}
3783:../src/RTOS/tasks.c **** 
3784:../src/RTOS/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3785:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3786:../src/RTOS/tasks.c **** 
3787:../src/RTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3788:../src/RTOS/tasks.c **** 
3789:../src/RTOS/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3790:../src/RTOS/tasks.c **** 	{
3791:../src/RTOS/tasks.c **** 	size_t x;
3792:../src/RTOS/tasks.c **** 
3793:../src/RTOS/tasks.c **** 		/* Start by copying the entire string. */
3794:../src/RTOS/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
3795:../src/RTOS/tasks.c **** 
3796:../src/RTOS/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
3797:../src/RTOS/tasks.c **** 		printed out. */
3798:../src/RTOS/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3799:../src/RTOS/tasks.c **** 		{
3800:../src/RTOS/tasks.c **** 			pcBuffer[ x ] = ' ';
3801:../src/RTOS/tasks.c **** 		}
3802:../src/RTOS/tasks.c **** 
3803:../src/RTOS/tasks.c **** 		/* Terminate. */
3804:../src/RTOS/tasks.c **** 		pcBuffer[ x ] = 0x00;
3805:../src/RTOS/tasks.c **** 
3806:../src/RTOS/tasks.c **** 		/* Return the new end of string. */
3807:../src/RTOS/tasks.c **** 		return &( pcBuffer[ x ] );
3808:../src/RTOS/tasks.c **** 	}
3809:../src/RTOS/tasks.c **** 
3810:../src/RTOS/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3811:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
3812:../src/RTOS/tasks.c **** 
3813:../src/RTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3814:../src/RTOS/tasks.c **** 
3815:../src/RTOS/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
3816:../src/RTOS/tasks.c **** 	{
3817:../src/RTOS/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3818:../src/RTOS/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3819:../src/RTOS/tasks.c **** 	char cStatus;
3820:../src/RTOS/tasks.c **** 
3821:../src/RTOS/tasks.c **** 		/*
3822:../src/RTOS/tasks.c **** 		 * PLEASE NOTE:
3823:../src/RTOS/tasks.c **** 		 *
3824:../src/RTOS/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3825:../src/RTOS/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3826:../src/RTOS/tasks.c **** 		 * scheduler.
3827:../src/RTOS/tasks.c **** 		 *
3828:../src/RTOS/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3829:../src/RTOS/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
3830:../src/RTOS/tasks.c **** 		 * displays task names, states and stack usage.
3831:../src/RTOS/tasks.c **** 		 *
3832:../src/RTOS/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
3833:../src/RTOS/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
3834:../src/RTOS/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
3835:../src/RTOS/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
3836:../src/RTOS/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
3837:../src/RTOS/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3838:../src/RTOS/tasks.c **** 		 * snprintf() implementation!).
3839:../src/RTOS/tasks.c **** 		 *
3840:../src/RTOS/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3841:../src/RTOS/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3842:../src/RTOS/tasks.c **** 		 * through a call to vTaskList().
3843:../src/RTOS/tasks.c **** 		 */
3844:../src/RTOS/tasks.c **** 
3845:../src/RTOS/tasks.c **** 
3846:../src/RTOS/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3847:../src/RTOS/tasks.c **** 		*pcWriteBuffer = 0x00;
3848:../src/RTOS/tasks.c **** 
3849:../src/RTOS/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3850:../src/RTOS/tasks.c **** 		function is executing. */
3851:../src/RTOS/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3852:../src/RTOS/tasks.c **** 
3853:../src/RTOS/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
3854:../src/RTOS/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
3855:../src/RTOS/tasks.c **** 		equate to NULL. */
3856:../src/RTOS/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3857:../src/RTOS/tasks.c **** 
3858:../src/RTOS/tasks.c **** 		if( pxTaskStatusArray != NULL )
3859:../src/RTOS/tasks.c **** 		{
3860:../src/RTOS/tasks.c **** 			/* Generate the (binary) data. */
3861:../src/RTOS/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3862:../src/RTOS/tasks.c **** 
3863:../src/RTOS/tasks.c **** 			/* Create a human readable table from the binary data. */
3864:../src/RTOS/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
3865:../src/RTOS/tasks.c **** 			{
3866:../src/RTOS/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
3867:../src/RTOS/tasks.c **** 				{
3868:../src/RTOS/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
3869:../src/RTOS/tasks.c **** 										break;
3870:../src/RTOS/tasks.c **** 
3871:../src/RTOS/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3872:../src/RTOS/tasks.c **** 										break;
3873:../src/RTOS/tasks.c **** 
3874:../src/RTOS/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
3875:../src/RTOS/tasks.c **** 										break;
3876:../src/RTOS/tasks.c **** 
3877:../src/RTOS/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
3878:../src/RTOS/tasks.c **** 										break;
3879:../src/RTOS/tasks.c **** 
3880:../src/RTOS/tasks.c **** 					default:			/* Should not get here, but it is included
3881:../src/RTOS/tasks.c **** 										to prevent static checking errors. */
3882:../src/RTOS/tasks.c **** 										cStatus = 0x00;
3883:../src/RTOS/tasks.c **** 										break;
3884:../src/RTOS/tasks.c **** 				}
3885:../src/RTOS/tasks.c **** 
3886:../src/RTOS/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
3887:../src/RTOS/tasks.c **** 				can be printed in tabular form more easily. */
3888:../src/RTOS/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3889:../src/RTOS/tasks.c **** 
3890:../src/RTOS/tasks.c **** 				/* Write the rest of the string. */
3891:../src/RTOS/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
3892:../src/RTOS/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
3893:../src/RTOS/tasks.c **** 			}
3894:../src/RTOS/tasks.c **** 
3895:../src/RTOS/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
3896:../src/RTOS/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
3897:../src/RTOS/tasks.c **** 			vPortFree( pxTaskStatusArray );
3898:../src/RTOS/tasks.c **** 		}
3899:../src/RTOS/tasks.c **** 		else
3900:../src/RTOS/tasks.c **** 		{
3901:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3902:../src/RTOS/tasks.c **** 		}
3903:../src/RTOS/tasks.c **** 	}
3904:../src/RTOS/tasks.c **** 
3905:../src/RTOS/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
3906:../src/RTOS/tasks.c **** /*----------------------------------------------------------*/
3907:../src/RTOS/tasks.c **** 
3908:../src/RTOS/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3909:../src/RTOS/tasks.c **** 
3910:../src/RTOS/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3911:../src/RTOS/tasks.c **** 	{
3912:../src/RTOS/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3913:../src/RTOS/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3914:../src/RTOS/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
3915:../src/RTOS/tasks.c **** 
3916:../src/RTOS/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
3917:../src/RTOS/tasks.c **** 		{
3918:../src/RTOS/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
3919:../src/RTOS/tasks.c **** 		}
3920:../src/RTOS/tasks.c **** 		#endif
3921:../src/RTOS/tasks.c **** 
3922:../src/RTOS/tasks.c **** 		/*
3923:../src/RTOS/tasks.c **** 		 * PLEASE NOTE:
3924:../src/RTOS/tasks.c **** 		 *
3925:../src/RTOS/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3926:../src/RTOS/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3927:../src/RTOS/tasks.c **** 		 * scheduler.
3928:../src/RTOS/tasks.c **** 		 *
3929:../src/RTOS/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3930:../src/RTOS/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
3931:../src/RTOS/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
3932:../src/RTOS/tasks.c **** 		 * in both absolute and percentage terms.
3933:../src/RTOS/tasks.c **** 		 *
3934:../src/RTOS/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3935:../src/RTOS/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
3936:../src/RTOS/tasks.c **** 		 * provide different results on different platforms.  An alternative,
3937:../src/RTOS/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
3938:../src/RTOS/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3939:../src/RTOS/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3940:../src/RTOS/tasks.c **** 		 * a full snprintf() implementation!).
3941:../src/RTOS/tasks.c **** 		 *
3942:../src/RTOS/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3943:../src/RTOS/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3944:../src/RTOS/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
3945:../src/RTOS/tasks.c **** 		 */
3946:../src/RTOS/tasks.c **** 
3947:../src/RTOS/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3948:../src/RTOS/tasks.c **** 		*pcWriteBuffer = 0x00;
3949:../src/RTOS/tasks.c **** 
3950:../src/RTOS/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3951:../src/RTOS/tasks.c **** 		function is executing. */
3952:../src/RTOS/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3953:../src/RTOS/tasks.c **** 
3954:../src/RTOS/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
3955:../src/RTOS/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
3956:../src/RTOS/tasks.c **** 		equate to NULL. */
3957:../src/RTOS/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3958:../src/RTOS/tasks.c **** 
3959:../src/RTOS/tasks.c **** 		if( pxTaskStatusArray != NULL )
3960:../src/RTOS/tasks.c **** 		{
3961:../src/RTOS/tasks.c **** 			/* Generate the (binary) data. */
3962:../src/RTOS/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
3963:../src/RTOS/tasks.c **** 
3964:../src/RTOS/tasks.c **** 			/* For percentage calculations. */
3965:../src/RTOS/tasks.c **** 			ulTotalTime /= 100UL;
3966:../src/RTOS/tasks.c **** 
3967:../src/RTOS/tasks.c **** 			/* Avoid divide by zero errors. */
3968:../src/RTOS/tasks.c **** 			if( ulTotalTime > 0 )
3969:../src/RTOS/tasks.c **** 			{
3970:../src/RTOS/tasks.c **** 				/* Create a human readable table from the binary data. */
3971:../src/RTOS/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
3972:../src/RTOS/tasks.c **** 				{
3973:../src/RTOS/tasks.c **** 					/* What percentage of the total run time has the task used?
3974:../src/RTOS/tasks.c **** 					This will always be rounded down to the nearest integer.
3975:../src/RTOS/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
3976:../src/RTOS/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3977:../src/RTOS/tasks.c **** 
3978:../src/RTOS/tasks.c **** 					/* Write the task name to the string, padding with
3979:../src/RTOS/tasks.c **** 					spaces so it can be printed in tabular form more
3980:../src/RTOS/tasks.c **** 					easily. */
3981:../src/RTOS/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3982:../src/RTOS/tasks.c **** 
3983:../src/RTOS/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
3984:../src/RTOS/tasks.c **** 					{
3985:../src/RTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3986:../src/RTOS/tasks.c **** 						{
3987:../src/RTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
3988:../src/RTOS/tasks.c **** 						}
3989:../src/RTOS/tasks.c **** 						#else
3990:../src/RTOS/tasks.c **** 						{
3991:../src/RTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3992:../src/RTOS/tasks.c **** 							printf() library can be used. */
3993:../src/RTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
3994:../src/RTOS/tasks.c **** 						}
3995:../src/RTOS/tasks.c **** 						#endif
3996:../src/RTOS/tasks.c **** 					}
3997:../src/RTOS/tasks.c **** 					else
3998:../src/RTOS/tasks.c **** 					{
3999:../src/RTOS/tasks.c **** 						/* If the percentage is zero here then the task has
4000:../src/RTOS/tasks.c **** 						consumed less than 1% of the total run time. */
4001:../src/RTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4002:../src/RTOS/tasks.c **** 						{
4003:../src/RTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4004:../src/RTOS/tasks.c **** 						}
4005:../src/RTOS/tasks.c **** 						#else
4006:../src/RTOS/tasks.c **** 						{
4007:../src/RTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4008:../src/RTOS/tasks.c **** 							printf() library can be used. */
4009:../src/RTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4010:../src/RTOS/tasks.c **** 						}
4011:../src/RTOS/tasks.c **** 						#endif
4012:../src/RTOS/tasks.c **** 					}
4013:../src/RTOS/tasks.c **** 
4014:../src/RTOS/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
4015:../src/RTOS/tasks.c **** 				}
4016:../src/RTOS/tasks.c **** 			}
4017:../src/RTOS/tasks.c **** 			else
4018:../src/RTOS/tasks.c **** 			{
4019:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4020:../src/RTOS/tasks.c **** 			}
4021:../src/RTOS/tasks.c **** 
4022:../src/RTOS/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4023:../src/RTOS/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4024:../src/RTOS/tasks.c **** 			vPortFree( pxTaskStatusArray );
4025:../src/RTOS/tasks.c **** 		}
4026:../src/RTOS/tasks.c **** 		else
4027:../src/RTOS/tasks.c **** 		{
4028:../src/RTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4029:../src/RTOS/tasks.c **** 		}
4030:../src/RTOS/tasks.c **** 	}
4031:../src/RTOS/tasks.c **** 
4032:../src/RTOS/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4033:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
4034:../src/RTOS/tasks.c **** 
4035:../src/RTOS/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4036:../src/RTOS/tasks.c **** {
 3446              		.loc 1 4036 0
 3447              		.cfi_startproc
 3448              		@ args = 0, pretend = 0, frame = 8
 3449              		@ frame_needed = 1, uses_anonymous_args = 0
 3450              		@ link register save eliminated.
 3451 0000 80B4     		push	{r7}
 3452              		.cfi_def_cfa_offset 4
 3453              		.cfi_offset 7, -4
 3454 0002 83B0     		sub	sp, sp, #12
 3455              		.cfi_def_cfa_offset 16
 3456 0004 00AF     		add	r7, sp, #0
 3457              		.cfi_def_cfa_register 7
4037:../src/RTOS/tasks.c **** TickType_t uxReturn;
4038:../src/RTOS/tasks.c **** 
4039:../src/RTOS/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 3458              		.loc 1 4039 0
 3459 0006 094B     		ldr	r3, .L270
 3460 0008 1B68     		ldr	r3, [r3]
 3461 000a 9B69     		ldr	r3, [r3, #24]
 3462 000c 7B60     		str	r3, [r7, #4]
4040:../src/RTOS/tasks.c **** 
4041:../src/RTOS/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4042:../src/RTOS/tasks.c **** 	queues and semaphores. */
4043:../src/RTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 3463              		.loc 1 4043 0
 3464 000e 074B     		ldr	r3, .L270
 3465 0010 1B68     		ldr	r3, [r3]
 3466 0012 064A     		ldr	r2, .L270
 3467 0014 1268     		ldr	r2, [r2]
 3468 0016 D26A     		ldr	r2, [r2, #44]
 3469 0018 C2F10A02 		rsb	r2, r2, #10
 3470 001c 9A61     		str	r2, [r3, #24]
4044:../src/RTOS/tasks.c **** 
4045:../src/RTOS/tasks.c **** 	return uxReturn;
 3471              		.loc 1 4045 0
 3472 001e 7B68     		ldr	r3, [r7, #4]
4046:../src/RTOS/tasks.c **** }
 3473              		.loc 1 4046 0
 3474 0020 1846     		mov	r0, r3
 3475 0022 0C37     		adds	r7, r7, #12
 3476              		.cfi_def_cfa_offset 4
 3477 0024 BD46     		mov	sp, r7
 3478              		.cfi_def_cfa_register 13
 3479              		@ sp needed
 3480 0026 5DF8047B 		ldr	r7, [sp], #4
 3481              		.cfi_restore 7
 3482              		.cfi_def_cfa_offset 0
 3483 002a 7047     		bx	lr
 3484              	.L271:
 3485              		.align	2
 3486              	.L270:
 3487 002c 00000000 		.word	pxCurrentTCB
 3488              		.cfi_endproc
 3489              	.LFE38:
 3491              		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 3492              		.align	2
 3493              		.global	pvTaskIncrementMutexHeldCount
 3494              		.thumb
 3495              		.thumb_func
 3497              	pvTaskIncrementMutexHeldCount:
 3498              	.LFB39:
4047:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
4048:../src/RTOS/tasks.c **** 
4049:../src/RTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4050:../src/RTOS/tasks.c **** 
4051:../src/RTOS/tasks.c **** 	void *pvTaskIncrementMutexHeldCount( void )
4052:../src/RTOS/tasks.c **** 	{
 3499              		.loc 1 4052 0
 3500              		.cfi_startproc
 3501              		@ args = 0, pretend = 0, frame = 0
 3502              		@ frame_needed = 1, uses_anonymous_args = 0
 3503              		@ link register save eliminated.
 3504 0000 80B4     		push	{r7}
 3505              		.cfi_def_cfa_offset 4
 3506              		.cfi_offset 7, -4
 3507 0002 00AF     		add	r7, sp, #0
 3508              		.cfi_def_cfa_register 7
4053:../src/RTOS/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4054:../src/RTOS/tasks.c **** 		then pxCurrentTCB will be NULL. */
4055:../src/RTOS/tasks.c **** 		if( pxCurrentTCB != NULL )
 3509              		.loc 1 4055 0
 3510 0004 074B     		ldr	r3, .L275
 3511 0006 1B68     		ldr	r3, [r3]
 3512 0008 002B     		cmp	r3, #0
 3513 000a 04D0     		beq	.L273
4056:../src/RTOS/tasks.c **** 		{
4057:../src/RTOS/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
 3514              		.loc 1 4057 0
 3515 000c 054B     		ldr	r3, .L275
 3516 000e 1B68     		ldr	r3, [r3]
 3517 0010 1A6C     		ldr	r2, [r3, #64]
 3518 0012 0132     		adds	r2, r2, #1
 3519 0014 1A64     		str	r2, [r3, #64]
 3520              	.L273:
4058:../src/RTOS/tasks.c **** 		}
4059:../src/RTOS/tasks.c **** 
4060:../src/RTOS/tasks.c **** 		return pxCurrentTCB;
 3521              		.loc 1 4060 0
 3522 0016 034B     		ldr	r3, .L275
 3523 0018 1B68     		ldr	r3, [r3]
4061:../src/RTOS/tasks.c **** 	}
 3524              		.loc 1 4061 0
 3525 001a 1846     		mov	r0, r3
 3526 001c BD46     		mov	sp, r7
 3527              		.cfi_def_cfa_register 13
 3528              		@ sp needed
 3529 001e 5DF8047B 		ldr	r7, [sp], #4
 3530              		.cfi_restore 7
 3531              		.cfi_def_cfa_offset 0
 3532 0022 7047     		bx	lr
 3533              	.L276:
 3534              		.align	2
 3535              	.L275:
 3536 0024 00000000 		.word	pxCurrentTCB
 3537              		.cfi_endproc
 3538              	.LFE39:
 3540              		.section	.text.ulTaskNotifyTake,"ax",%progbits
 3541              		.align	2
 3542              		.global	ulTaskNotifyTake
 3543              		.thumb
 3544              		.thumb_func
 3546              	ulTaskNotifyTake:
 3547              	.LFB40:
4062:../src/RTOS/tasks.c **** 
4063:../src/RTOS/tasks.c **** #endif /* configUSE_MUTEXES */
4064:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
4065:../src/RTOS/tasks.c **** 
4066:../src/RTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4067:../src/RTOS/tasks.c **** 
4068:../src/RTOS/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4069:../src/RTOS/tasks.c **** 	{
 3548              		.loc 1 4069 0
 3549              		.cfi_startproc
 3550              		@ args = 0, pretend = 0, frame = 16
 3551              		@ frame_needed = 1, uses_anonymous_args = 0
 3552 0000 80B5     		push	{r7, lr}
 3553              		.cfi_def_cfa_offset 8
 3554              		.cfi_offset 7, -8
 3555              		.cfi_offset 14, -4
 3556 0002 84B0     		sub	sp, sp, #16
 3557              		.cfi_def_cfa_offset 24
 3558 0004 00AF     		add	r7, sp, #0
 3559              		.cfi_def_cfa_register 7
 3560 0006 7860     		str	r0, [r7, #4]
 3561 0008 3960     		str	r1, [r7]
4070:../src/RTOS/tasks.c **** 	uint32_t ulReturn;
4071:../src/RTOS/tasks.c **** 
4072:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
 3562              		.loc 1 4072 0
 3563 000a FFF7FEFF 		bl	vPortEnterCritical
4073:../src/RTOS/tasks.c **** 		{
4074:../src/RTOS/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4075:../src/RTOS/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 3564              		.loc 1 4075 0
 3565 000e 1E4B     		ldr	r3, .L283
 3566 0010 1B68     		ldr	r3, [r3]
 3567 0012 5B6C     		ldr	r3, [r3, #68]
 3568 0014 002B     		cmp	r3, #0
 3569 0016 13D1     		bne	.L278
4076:../src/RTOS/tasks.c **** 			{
4077:../src/RTOS/tasks.c **** 				/* Mark this task as waiting for a notification. */
4078:../src/RTOS/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 3570              		.loc 1 4078 0
 3571 0018 1B4B     		ldr	r3, .L283
 3572 001a 1B68     		ldr	r3, [r3]
 3573 001c 0122     		movs	r2, #1
 3574 001e 83F84820 		strb	r2, [r3, #72]
4079:../src/RTOS/tasks.c **** 
4080:../src/RTOS/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 3575              		.loc 1 4080 0
 3576 0022 3B68     		ldr	r3, [r7]
 3577 0024 002B     		cmp	r3, #0
 3578 0026 0BD0     		beq	.L278
4081:../src/RTOS/tasks.c **** 				{
4082:../src/RTOS/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 3579              		.loc 1 4082 0
 3580 0028 3868     		ldr	r0, [r7]
 3581 002a 0121     		movs	r1, #1
 3582 002c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4083:../src/RTOS/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4084:../src/RTOS/tasks.c **** 
4085:../src/RTOS/tasks.c **** 					/* All ports are written to allow a yield in a critical
4086:../src/RTOS/tasks.c **** 					section (some will yield immediately, others wait until the
4087:../src/RTOS/tasks.c **** 					critical section exits) - but it is not something that
4088:../src/RTOS/tasks.c **** 					application code should ever do. */
4089:../src/RTOS/tasks.c **** 					portYIELD_WITHIN_API();
 3583              		.loc 1 4089 0
 3584 0030 164B     		ldr	r3, .L283+4
 3585 0032 4FF08052 		mov	r2, #268435456
 3586 0036 1A60     		str	r2, [r3]
 3587              	@ 4089 "../src/RTOS/tasks.c" 1
 3588 0038 BFF34F8F 		dsb
 3589              	@ 0 "" 2
 3590              	@ 4089 "../src/RTOS/tasks.c" 1
 3591 003c BFF36F8F 		isb
 3592              	@ 0 "" 2
 3593              		.thumb
 3594              	.L278:
4090:../src/RTOS/tasks.c **** 				}
4091:../src/RTOS/tasks.c **** 				else
4092:../src/RTOS/tasks.c **** 				{
4093:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4094:../src/RTOS/tasks.c **** 				}
4095:../src/RTOS/tasks.c **** 			}
4096:../src/RTOS/tasks.c **** 			else
4097:../src/RTOS/tasks.c **** 			{
4098:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4099:../src/RTOS/tasks.c **** 			}
4100:../src/RTOS/tasks.c **** 		}
4101:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
 3595              		.loc 1 4101 0
 3596 0040 FFF7FEFF 		bl	vPortExitCritical
4102:../src/RTOS/tasks.c **** 
4103:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
 3597              		.loc 1 4103 0
 3598 0044 FFF7FEFF 		bl	vPortEnterCritical
4104:../src/RTOS/tasks.c **** 		{
4105:../src/RTOS/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4106:../src/RTOS/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 3599              		.loc 1 4106 0
 3600 0048 0F4B     		ldr	r3, .L283
 3601 004a 1B68     		ldr	r3, [r3]
 3602 004c 5B6C     		ldr	r3, [r3, #68]
 3603 004e FB60     		str	r3, [r7, #12]
4107:../src/RTOS/tasks.c **** 
4108:../src/RTOS/tasks.c **** 			if( ulReturn != 0UL )
 3604              		.loc 1 4108 0
 3605 0050 FB68     		ldr	r3, [r7, #12]
 3606 0052 002B     		cmp	r3, #0
 3607 0054 0CD0     		beq	.L279
4109:../src/RTOS/tasks.c **** 			{
4110:../src/RTOS/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
 3608              		.loc 1 4110 0
 3609 0056 7B68     		ldr	r3, [r7, #4]
 3610 0058 002B     		cmp	r3, #0
 3611 005a 04D0     		beq	.L280
4111:../src/RTOS/tasks.c **** 				{
4112:../src/RTOS/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
 3612              		.loc 1 4112 0
 3613 005c 0A4B     		ldr	r3, .L283
 3614 005e 1B68     		ldr	r3, [r3]
 3615 0060 0022     		movs	r2, #0
 3616 0062 5A64     		str	r2, [r3, #68]
 3617 0064 04E0     		b	.L279
 3618              	.L280:
4113:../src/RTOS/tasks.c **** 				}
4114:../src/RTOS/tasks.c **** 				else
4115:../src/RTOS/tasks.c **** 				{
4116:../src/RTOS/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
 3619              		.loc 1 4116 0
 3620 0066 084B     		ldr	r3, .L283
 3621 0068 1B68     		ldr	r3, [r3]
 3622 006a FA68     		ldr	r2, [r7, #12]
 3623 006c 013A     		subs	r2, r2, #1
 3624 006e 5A64     		str	r2, [r3, #68]
 3625              	.L279:
4117:../src/RTOS/tasks.c **** 				}
4118:../src/RTOS/tasks.c **** 			}
4119:../src/RTOS/tasks.c **** 			else
4120:../src/RTOS/tasks.c **** 			{
4121:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4122:../src/RTOS/tasks.c **** 			}
4123:../src/RTOS/tasks.c **** 
4124:../src/RTOS/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 3626              		.loc 1 4124 0
 3627 0070 054B     		ldr	r3, .L283
 3628 0072 1B68     		ldr	r3, [r3]
 3629 0074 0022     		movs	r2, #0
 3630 0076 83F84820 		strb	r2, [r3, #72]
4125:../src/RTOS/tasks.c **** 		}
4126:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
 3631              		.loc 1 4126 0
 3632 007a FFF7FEFF 		bl	vPortExitCritical
4127:../src/RTOS/tasks.c **** 
4128:../src/RTOS/tasks.c **** 		return ulReturn;
 3633              		.loc 1 4128 0
 3634 007e FB68     		ldr	r3, [r7, #12]
4129:../src/RTOS/tasks.c **** 	}
 3635              		.loc 1 4129 0
 3636 0080 1846     		mov	r0, r3
 3637 0082 1037     		adds	r7, r7, #16
 3638              		.cfi_def_cfa_offset 8
 3639 0084 BD46     		mov	sp, r7
 3640              		.cfi_def_cfa_register 13
 3641              		@ sp needed
 3642 0086 80BD     		pop	{r7, pc}
 3643              	.L284:
 3644              		.align	2
 3645              	.L283:
 3646 0088 00000000 		.word	pxCurrentTCB
 3647 008c 04ED00E0 		.word	-536810236
 3648              		.cfi_endproc
 3649              	.LFE40:
 3651              		.section	.text.xTaskNotifyWait,"ax",%progbits
 3652              		.align	2
 3653              		.global	xTaskNotifyWait
 3654              		.thumb
 3655              		.thumb_func
 3657              	xTaskNotifyWait:
 3658              	.LFB41:
4130:../src/RTOS/tasks.c **** 
4131:../src/RTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4132:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
4133:../src/RTOS/tasks.c **** 
4134:../src/RTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4135:../src/RTOS/tasks.c **** 
4136:../src/RTOS/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4137:../src/RTOS/tasks.c **** 	{
 3659              		.loc 1 4137 0
 3660              		.cfi_startproc
 3661              		@ args = 0, pretend = 0, frame = 24
 3662              		@ frame_needed = 1, uses_anonymous_args = 0
 3663 0000 80B5     		push	{r7, lr}
 3664              		.cfi_def_cfa_offset 8
 3665              		.cfi_offset 7, -8
 3666              		.cfi_offset 14, -4
 3667 0002 86B0     		sub	sp, sp, #24
 3668              		.cfi_def_cfa_offset 32
 3669 0004 00AF     		add	r7, sp, #0
 3670              		.cfi_def_cfa_register 7
 3671 0006 F860     		str	r0, [r7, #12]
 3672 0008 B960     		str	r1, [r7, #8]
 3673 000a 7A60     		str	r2, [r7, #4]
 3674 000c 3B60     		str	r3, [r7]
4138:../src/RTOS/tasks.c **** 	BaseType_t xReturn;
4139:../src/RTOS/tasks.c **** 
4140:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
 3675              		.loc 1 4140 0
 3676 000e FFF7FEFF 		bl	vPortEnterCritical
4141:../src/RTOS/tasks.c **** 		{
4142:../src/RTOS/tasks.c **** 			/* Only block if a notification is not already pending. */
4143:../src/RTOS/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 3677              		.loc 1 4143 0
 3678 0012 264B     		ldr	r3, .L291
 3679 0014 1B68     		ldr	r3, [r3]
 3680 0016 93F84830 		ldrb	r3, [r3, #72]
 3681 001a DBB2     		uxtb	r3, r3
 3682 001c 022B     		cmp	r3, #2
 3683 001e 1AD0     		beq	.L286
4144:../src/RTOS/tasks.c **** 			{
4145:../src/RTOS/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4146:../src/RTOS/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4147:../src/RTOS/tasks.c **** 				clear the value to zero. */
4148:../src/RTOS/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 3684              		.loc 1 4148 0
 3685 0020 224B     		ldr	r3, .L291
 3686 0022 1B68     		ldr	r3, [r3]
 3687 0024 596C     		ldr	r1, [r3, #68]
 3688 0026 FA68     		ldr	r2, [r7, #12]
 3689 0028 D243     		mvns	r2, r2
 3690 002a 0A40     		ands	r2, r2, r1
 3691 002c 5A64     		str	r2, [r3, #68]
4149:../src/RTOS/tasks.c **** 
4150:../src/RTOS/tasks.c **** 				/* Mark this task as waiting for a notification. */
4151:../src/RTOS/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 3692              		.loc 1 4151 0
 3693 002e 1F4B     		ldr	r3, .L291
 3694 0030 1B68     		ldr	r3, [r3]
 3695 0032 0122     		movs	r2, #1
 3696 0034 83F84820 		strb	r2, [r3, #72]
4152:../src/RTOS/tasks.c **** 
4153:../src/RTOS/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 3697              		.loc 1 4153 0
 3698 0038 3B68     		ldr	r3, [r7]
 3699 003a 002B     		cmp	r3, #0
 3700 003c 0BD0     		beq	.L286
4154:../src/RTOS/tasks.c **** 				{
4155:../src/RTOS/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 3701              		.loc 1 4155 0
 3702 003e 3868     		ldr	r0, [r7]
 3703 0040 0121     		movs	r1, #1
 3704 0042 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4156:../src/RTOS/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4157:../src/RTOS/tasks.c **** 
4158:../src/RTOS/tasks.c **** 					/* All ports are written to allow a yield in a critical
4159:../src/RTOS/tasks.c **** 					section (some will yield immediately, others wait until the
4160:../src/RTOS/tasks.c **** 					critical section exits) - but it is not something that
4161:../src/RTOS/tasks.c **** 					application code should ever do. */
4162:../src/RTOS/tasks.c **** 					portYIELD_WITHIN_API();
 3705              		.loc 1 4162 0
 3706 0046 1A4B     		ldr	r3, .L291+4
 3707 0048 4FF08052 		mov	r2, #268435456
 3708 004c 1A60     		str	r2, [r3]
 3709              	@ 4162 "../src/RTOS/tasks.c" 1
 3710 004e BFF34F8F 		dsb
 3711              	@ 0 "" 2
 3712              	@ 4162 "../src/RTOS/tasks.c" 1
 3713 0052 BFF36F8F 		isb
 3714              	@ 0 "" 2
 3715              		.thumb
 3716              	.L286:
4163:../src/RTOS/tasks.c **** 				}
4164:../src/RTOS/tasks.c **** 				else
4165:../src/RTOS/tasks.c **** 				{
4166:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4167:../src/RTOS/tasks.c **** 				}
4168:../src/RTOS/tasks.c **** 			}
4169:../src/RTOS/tasks.c **** 			else
4170:../src/RTOS/tasks.c **** 			{
4171:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4172:../src/RTOS/tasks.c **** 			}
4173:../src/RTOS/tasks.c **** 		}
4174:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
 3717              		.loc 1 4174 0
 3718 0056 FFF7FEFF 		bl	vPortExitCritical
4175:../src/RTOS/tasks.c **** 
4176:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
 3719              		.loc 1 4176 0
 3720 005a FFF7FEFF 		bl	vPortEnterCritical
4177:../src/RTOS/tasks.c **** 		{
4178:../src/RTOS/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4179:../src/RTOS/tasks.c **** 
4180:../src/RTOS/tasks.c **** 			if( pulNotificationValue != NULL )
 3721              		.loc 1 4180 0
 3722 005e 7B68     		ldr	r3, [r7, #4]
 3723 0060 002B     		cmp	r3, #0
 3724 0062 04D0     		beq	.L287
4181:../src/RTOS/tasks.c **** 			{
4182:../src/RTOS/tasks.c **** 				/* Output the current notification value, which may or may not
4183:../src/RTOS/tasks.c **** 				have changed. */
4184:../src/RTOS/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 3725              		.loc 1 4184 0
 3726 0064 114B     		ldr	r3, .L291
 3727 0066 1B68     		ldr	r3, [r3]
 3728 0068 5A6C     		ldr	r2, [r3, #68]
 3729 006a 7B68     		ldr	r3, [r7, #4]
 3730 006c 1A60     		str	r2, [r3]
 3731              	.L287:
4185:../src/RTOS/tasks.c **** 			}
4186:../src/RTOS/tasks.c **** 
4187:../src/RTOS/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4188:../src/RTOS/tasks.c **** 			blocked state (because a notification was already pending) or the
4189:../src/RTOS/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4190:../src/RTOS/tasks.c **** 			unblocked because of a timeout. */
4191:../src/RTOS/tasks.c **** 			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 3732              		.loc 1 4191 0
 3733 006e 0F4B     		ldr	r3, .L291
 3734 0070 1B68     		ldr	r3, [r3]
 3735 0072 93F84830 		ldrb	r3, [r3, #72]
 3736 0076 DBB2     		uxtb	r3, r3
 3737 0078 012B     		cmp	r3, #1
 3738 007a 02D1     		bne	.L288
4192:../src/RTOS/tasks.c **** 			{
4193:../src/RTOS/tasks.c **** 				/* A notification was not received. */
4194:../src/RTOS/tasks.c **** 				xReturn = pdFALSE;
 3739              		.loc 1 4194 0
 3740 007c 0023     		movs	r3, #0
 3741 007e 7B61     		str	r3, [r7, #20]
 3742 0080 08E0     		b	.L289
 3743              	.L288:
4195:../src/RTOS/tasks.c **** 			}
4196:../src/RTOS/tasks.c **** 			else
4197:../src/RTOS/tasks.c **** 			{
4198:../src/RTOS/tasks.c **** 				/* A notification was already pending or a notification was
4199:../src/RTOS/tasks.c **** 				received while the task was waiting. */
4200:../src/RTOS/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 3744              		.loc 1 4200 0
 3745 0082 0A4B     		ldr	r3, .L291
 3746 0084 1B68     		ldr	r3, [r3]
 3747 0086 596C     		ldr	r1, [r3, #68]
 3748 0088 BA68     		ldr	r2, [r7, #8]
 3749 008a D243     		mvns	r2, r2
 3750 008c 0A40     		ands	r2, r2, r1
 3751 008e 5A64     		str	r2, [r3, #68]
4201:../src/RTOS/tasks.c **** 				xReturn = pdTRUE;
 3752              		.loc 1 4201 0
 3753 0090 0123     		movs	r3, #1
 3754 0092 7B61     		str	r3, [r7, #20]
 3755              	.L289:
4202:../src/RTOS/tasks.c **** 			}
4203:../src/RTOS/tasks.c **** 
4204:../src/RTOS/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 3756              		.loc 1 4204 0
 3757 0094 054B     		ldr	r3, .L291
 3758 0096 1B68     		ldr	r3, [r3]
 3759 0098 0022     		movs	r2, #0
 3760 009a 83F84820 		strb	r2, [r3, #72]
4205:../src/RTOS/tasks.c **** 		}
4206:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
 3761              		.loc 1 4206 0
 3762 009e FFF7FEFF 		bl	vPortExitCritical
4207:../src/RTOS/tasks.c **** 
4208:../src/RTOS/tasks.c **** 		return xReturn;
 3763              		.loc 1 4208 0
 3764 00a2 7B69     		ldr	r3, [r7, #20]
4209:../src/RTOS/tasks.c **** 	}
 3765              		.loc 1 4209 0
 3766 00a4 1846     		mov	r0, r3
 3767 00a6 1837     		adds	r7, r7, #24
 3768              		.cfi_def_cfa_offset 8
 3769 00a8 BD46     		mov	sp, r7
 3770              		.cfi_def_cfa_register 13
 3771              		@ sp needed
 3772 00aa 80BD     		pop	{r7, pc}
 3773              	.L292:
 3774              		.align	2
 3775              	.L291:
 3776 00ac 00000000 		.word	pxCurrentTCB
 3777 00b0 04ED00E0 		.word	-536810236
 3778              		.cfi_endproc
 3779              	.LFE41:
 3781              		.section	.text.xTaskGenericNotify,"ax",%progbits
 3782              		.align	2
 3783              		.global	xTaskGenericNotify
 3784              		.thumb
 3785              		.thumb_func
 3787              	xTaskGenericNotify:
 3788              	.LFB42:
4210:../src/RTOS/tasks.c **** 
4211:../src/RTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4212:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
4213:../src/RTOS/tasks.c **** 
4214:../src/RTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4215:../src/RTOS/tasks.c **** 
4216:../src/RTOS/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4217:../src/RTOS/tasks.c **** 	{
 3789              		.loc 1 4217 0
 3790              		.cfi_startproc
 3791              		@ args = 0, pretend = 0, frame = 32
 3792              		@ frame_needed = 1, uses_anonymous_args = 0
 3793 0000 80B5     		push	{r7, lr}
 3794              		.cfi_def_cfa_offset 8
 3795              		.cfi_offset 7, -8
 3796              		.cfi_offset 14, -4
 3797 0002 88B0     		sub	sp, sp, #32
 3798              		.cfi_def_cfa_offset 40
 3799 0004 00AF     		add	r7, sp, #0
 3800              		.cfi_def_cfa_register 7
 3801 0006 F860     		str	r0, [r7, #12]
 3802 0008 B960     		str	r1, [r7, #8]
 3803 000a 3B60     		str	r3, [r7]
 3804 000c 1346     		mov	r3, r2
 3805 000e FB71     		strb	r3, [r7, #7]
4218:../src/RTOS/tasks.c **** 	TCB_t * pxTCB;
4219:../src/RTOS/tasks.c **** 	BaseType_t xReturn = pdPASS;
 3806              		.loc 1 4219 0
 3807 0010 0123     		movs	r3, #1
 3808 0012 FB61     		str	r3, [r7, #28]
4220:../src/RTOS/tasks.c **** 	uint8_t ucOriginalNotifyState;
4221:../src/RTOS/tasks.c **** 
4222:../src/RTOS/tasks.c **** 		configASSERT( xTaskToNotify );
 3809              		.loc 1 4222 0
 3810 0014 FB68     		ldr	r3, [r7, #12]
 3811 0016 002B     		cmp	r3, #0
 3812 0018 00D1     		bne	.L294
 3813              	.L295:
 3814              		.loc 1 4222 0 is_stmt 0 discriminator 1
 3815 001a FEE7     		b	.L295
 3816              	.L294:
4223:../src/RTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 3817              		.loc 1 4223 0 is_stmt 1
 3818 001c FB68     		ldr	r3, [r7, #12]
 3819 001e BB61     		str	r3, [r7, #24]
4224:../src/RTOS/tasks.c **** 
4225:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
 3820              		.loc 1 4225 0
 3821 0020 FFF7FEFF 		bl	vPortEnterCritical
4226:../src/RTOS/tasks.c **** 		{
4227:../src/RTOS/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 3822              		.loc 1 4227 0
 3823 0024 3B68     		ldr	r3, [r7]
 3824 0026 002B     		cmp	r3, #0
 3825 0028 03D0     		beq	.L296
4228:../src/RTOS/tasks.c **** 			{
4229:../src/RTOS/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 3826              		.loc 1 4229 0
 3827 002a BB69     		ldr	r3, [r7, #24]
 3828 002c 5A6C     		ldr	r2, [r3, #68]
 3829 002e 3B68     		ldr	r3, [r7]
 3830 0030 1A60     		str	r2, [r3]
 3831              	.L296:
4230:../src/RTOS/tasks.c **** 			}
4231:../src/RTOS/tasks.c **** 
4232:../src/RTOS/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 3832              		.loc 1 4232 0
 3833 0032 BB69     		ldr	r3, [r7, #24]
 3834 0034 93F84830 		ldrb	r3, [r3, #72]
 3835 0038 FB75     		strb	r3, [r7, #23]
4233:../src/RTOS/tasks.c **** 
4234:../src/RTOS/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3836              		.loc 1 4234 0
 3837 003a BB69     		ldr	r3, [r7, #24]
 3838 003c 0222     		movs	r2, #2
 3839 003e 83F84820 		strb	r2, [r3, #72]
4235:../src/RTOS/tasks.c **** 
4236:../src/RTOS/tasks.c **** 			switch( eAction )
 3840              		.loc 1 4236 0
 3841 0042 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3842 0044 042B     		cmp	r3, #4
 3843 0046 28D8     		bhi	.L297
 3844 0048 01A2     		adr	r2, .L299
 3845 004a 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 3846 004e 00BF     		.p2align 2
 3847              	.L299:
 3848 0050 9B000000 		.word	.L297+1
 3849 0054 65000000 		.word	.L300+1
 3850 0058 73000000 		.word	.L301+1
 3851 005c 7F000000 		.word	.L302+1
 3852 0060 87000000 		.word	.L303+1
 3853              		.p2align 1
 3854              	.L300:
4237:../src/RTOS/tasks.c **** 			{
4238:../src/RTOS/tasks.c **** 				case eSetBits	:
4239:../src/RTOS/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 3855              		.loc 1 4239 0
 3856 0064 BB69     		ldr	r3, [r7, #24]
 3857 0066 5A6C     		ldr	r2, [r3, #68]
 3858 0068 BB68     		ldr	r3, [r7, #8]
 3859 006a 1A43     		orrs	r2, r2, r3
 3860 006c BB69     		ldr	r3, [r7, #24]
 3861 006e 5A64     		str	r2, [r3, #68]
4240:../src/RTOS/tasks.c **** 					break;
 3862              		.loc 1 4240 0
 3863 0070 13E0     		b	.L297
 3864              	.L301:
4241:../src/RTOS/tasks.c **** 
4242:../src/RTOS/tasks.c **** 				case eIncrement	:
4243:../src/RTOS/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 3865              		.loc 1 4243 0
 3866 0072 BB69     		ldr	r3, [r7, #24]
 3867 0074 5B6C     		ldr	r3, [r3, #68]
 3868 0076 5A1C     		adds	r2, r3, #1
 3869 0078 BB69     		ldr	r3, [r7, #24]
 3870 007a 5A64     		str	r2, [r3, #68]
4244:../src/RTOS/tasks.c **** 					break;
 3871              		.loc 1 4244 0
 3872 007c 0DE0     		b	.L297
 3873              	.L302:
4245:../src/RTOS/tasks.c **** 
4246:../src/RTOS/tasks.c **** 				case eSetValueWithOverwrite	:
4247:../src/RTOS/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 3874              		.loc 1 4247 0
 3875 007e BB69     		ldr	r3, [r7, #24]
 3876 0080 BA68     		ldr	r2, [r7, #8]
 3877 0082 5A64     		str	r2, [r3, #68]
4248:../src/RTOS/tasks.c **** 					break;
 3878              		.loc 1 4248 0
 3879 0084 09E0     		b	.L297
 3880              	.L303:
4249:../src/RTOS/tasks.c **** 
4250:../src/RTOS/tasks.c **** 				case eSetValueWithoutOverwrite :
4251:../src/RTOS/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 3881              		.loc 1 4251 0
 3882 0086 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 3883 0088 022B     		cmp	r3, #2
 3884 008a 03D0     		beq	.L304
4252:../src/RTOS/tasks.c **** 					{
4253:../src/RTOS/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 3885              		.loc 1 4253 0
 3886 008c BB69     		ldr	r3, [r7, #24]
 3887 008e BA68     		ldr	r2, [r7, #8]
 3888 0090 5A64     		str	r2, [r3, #68]
4254:../src/RTOS/tasks.c **** 					}
4255:../src/RTOS/tasks.c **** 					else
4256:../src/RTOS/tasks.c **** 					{
4257:../src/RTOS/tasks.c **** 						/* The value could not be written to the task. */
4258:../src/RTOS/tasks.c **** 						xReturn = pdFAIL;
4259:../src/RTOS/tasks.c **** 					}
4260:../src/RTOS/tasks.c **** 					break;
 3889              		.loc 1 4260 0
 3890 0092 01E0     		b	.L311
 3891              	.L304:
4258:../src/RTOS/tasks.c **** 					}
 3892              		.loc 1 4258 0
 3893 0094 0023     		movs	r3, #0
 3894 0096 FB61     		str	r3, [r7, #28]
 3895              	.L311:
 3896              		.loc 1 4260 0
 3897 0098 00BF     		nop
 3898              	.L297:
4261:../src/RTOS/tasks.c **** 
4262:../src/RTOS/tasks.c **** 				case eNoAction:
4263:../src/RTOS/tasks.c **** 					/* The task is being notified without its notify value being
4264:../src/RTOS/tasks.c **** 					updated. */
4265:../src/RTOS/tasks.c **** 					break;
4266:../src/RTOS/tasks.c **** 			}
4267:../src/RTOS/tasks.c **** 
4268:../src/RTOS/tasks.c **** 			traceTASK_NOTIFY();
4269:../src/RTOS/tasks.c **** 
4270:../src/RTOS/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4271:../src/RTOS/tasks.c **** 			notification then unblock it now. */
4272:../src/RTOS/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 3899              		.loc 1 4272 0
 3900 009a FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 3901 009c 012B     		cmp	r3, #1
 3902 009e 30D1     		bne	.L306
4273:../src/RTOS/tasks.c **** 			{
4274:../src/RTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 3903              		.loc 1 4274 0
 3904 00a0 BB69     		ldr	r3, [r7, #24]
 3905 00a2 0433     		adds	r3, r3, #4
 3906 00a4 1846     		mov	r0, r3
 3907 00a6 FFF7FEFF 		bl	uxListRemove
4275:../src/RTOS/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 3908              		.loc 1 4275 0
 3909 00aa BB69     		ldr	r3, [r7, #24]
 3910 00ac DA6A     		ldr	r2, [r3, #44]
 3911 00ae 184B     		ldr	r3, .L312
 3912 00b0 1B68     		ldr	r3, [r3]
 3913 00b2 9A42     		cmp	r2, r3
 3914 00b4 03D9     		bls	.L307
 3915              		.loc 1 4275 0 is_stmt 0 discriminator 1
 3916 00b6 BB69     		ldr	r3, [r7, #24]
 3917 00b8 DB6A     		ldr	r3, [r3, #44]
 3918 00ba 154A     		ldr	r2, .L312
 3919 00bc 1360     		str	r3, [r2]
 3920              	.L307:
 3921              		.loc 1 4275 0 discriminator 3
 3922 00be BB69     		ldr	r3, [r7, #24]
 3923 00c0 DA6A     		ldr	r2, [r3, #44]
 3924 00c2 1346     		mov	r3, r2
 3925 00c4 9B00     		lsls	r3, r3, #2
 3926 00c6 1344     		add	r3, r3, r2
 3927 00c8 9B00     		lsls	r3, r3, #2
 3928 00ca 124A     		ldr	r2, .L312+4
 3929 00cc 1A44     		add	r2, r2, r3
 3930 00ce BB69     		ldr	r3, [r7, #24]
 3931 00d0 0433     		adds	r3, r3, #4
 3932 00d2 1046     		mov	r0, r2
 3933 00d4 1946     		mov	r1, r3
 3934 00d6 FFF7FEFF 		bl	vListInsertEnd
4276:../src/RTOS/tasks.c **** 
4277:../src/RTOS/tasks.c **** 				/* The task should not have been on an event list. */
4278:../src/RTOS/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 3935              		.loc 1 4278 0 is_stmt 1 discriminator 3
 3936 00da BB69     		ldr	r3, [r7, #24]
 3937 00dc 9B6A     		ldr	r3, [r3, #40]
 3938 00de 002B     		cmp	r3, #0
 3939 00e0 00D0     		beq	.L308
 3940              	.L309:
 3941              		.loc 1 4278 0 is_stmt 0 discriminator 2
 3942 00e2 FEE7     		b	.L309
 3943              	.L308:
4279:../src/RTOS/tasks.c **** 
4280:../src/RTOS/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4281:../src/RTOS/tasks.c **** 				{
4282:../src/RTOS/tasks.c **** 					/* If a task is blocked waiting for a notification then
4283:../src/RTOS/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4284:../src/RTOS/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4285:../src/RTOS/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4286:../src/RTOS/tasks.c **** 					because it will automatically get reset to a new value when
4287:../src/RTOS/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4288:../src/RTOS/tasks.c **** 					tickless idling is used it might be more important to enter
4289:../src/RTOS/tasks.c **** 					sleep mode at the earliest possible time - so reset
4290:../src/RTOS/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4291:../src/RTOS/tasks.c **** 					earliest possible time. */
4292:../src/RTOS/tasks.c **** 					prvResetNextTaskUnblockTime();
4293:../src/RTOS/tasks.c **** 				}
4294:../src/RTOS/tasks.c **** 				#endif
4295:../src/RTOS/tasks.c **** 
4296:../src/RTOS/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 3944              		.loc 1 4296 0 is_stmt 1
 3945 00e4 BB69     		ldr	r3, [r7, #24]
 3946 00e6 DA6A     		ldr	r2, [r3, #44]
 3947 00e8 0B4B     		ldr	r3, .L312+8
 3948 00ea 1B68     		ldr	r3, [r3]
 3949 00ec DB6A     		ldr	r3, [r3, #44]
 3950 00ee 9A42     		cmp	r2, r3
 3951 00f0 07D9     		bls	.L306
4297:../src/RTOS/tasks.c **** 				{
4298:../src/RTOS/tasks.c **** 					/* The notified task has a priority above the currently
4299:../src/RTOS/tasks.c **** 					executing task so a yield is required. */
4300:../src/RTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 3952              		.loc 1 4300 0
 3953 00f2 0A4B     		ldr	r3, .L312+12
 3954 00f4 4FF08052 		mov	r2, #268435456
 3955 00f8 1A60     		str	r2, [r3]
 3956              	@ 4300 "../src/RTOS/tasks.c" 1
 3957 00fa BFF34F8F 		dsb
 3958              	@ 0 "" 2
 3959              	@ 4300 "../src/RTOS/tasks.c" 1
 3960 00fe BFF36F8F 		isb
 3961              	@ 0 "" 2
 3962              		.thumb
 3963              	.L306:
4301:../src/RTOS/tasks.c **** 				}
4302:../src/RTOS/tasks.c **** 				else
4303:../src/RTOS/tasks.c **** 				{
4304:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4305:../src/RTOS/tasks.c **** 				}
4306:../src/RTOS/tasks.c **** 			}
4307:../src/RTOS/tasks.c **** 			else
4308:../src/RTOS/tasks.c **** 			{
4309:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4310:../src/RTOS/tasks.c **** 			}
4311:../src/RTOS/tasks.c **** 		}
4312:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
 3964              		.loc 1 4312 0
 3965 0102 FFF7FEFF 		bl	vPortExitCritical
4313:../src/RTOS/tasks.c **** 
4314:../src/RTOS/tasks.c **** 		return xReturn;
 3966              		.loc 1 4314 0
 3967 0106 FB69     		ldr	r3, [r7, #28]
4315:../src/RTOS/tasks.c **** 	}
 3968              		.loc 1 4315 0
 3969 0108 1846     		mov	r0, r3
 3970 010a 2037     		adds	r7, r7, #32
 3971              		.cfi_def_cfa_offset 8
 3972 010c BD46     		mov	sp, r7
 3973              		.cfi_def_cfa_register 13
 3974              		@ sp needed
 3975 010e 80BD     		pop	{r7, pc}
 3976              	.L313:
 3977              		.align	2
 3978              	.L312:
 3979 0110 00000000 		.word	uxTopReadyPriority
 3980 0114 00000000 		.word	pxReadyTasksLists
 3981 0118 00000000 		.word	pxCurrentTCB
 3982 011c 04ED00E0 		.word	-536810236
 3983              		.cfi_endproc
 3984              	.LFE42:
 3986              		.section	.text.xTaskGenericNotifyFromISR,"ax",%progbits
 3987              		.align	2
 3988              		.global	xTaskGenericNotifyFromISR
 3989              		.thumb
 3990              		.thumb_func
 3992              	xTaskGenericNotifyFromISR:
 3993              	.LFB43:
4316:../src/RTOS/tasks.c **** 
4317:../src/RTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4318:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
4319:../src/RTOS/tasks.c **** 
4320:../src/RTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4321:../src/RTOS/tasks.c **** 
4322:../src/RTOS/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4323:../src/RTOS/tasks.c **** 	{
 3994              		.loc 1 4323 0
 3995              		.cfi_startproc
 3996              		@ args = 4, pretend = 0, frame = 48
 3997              		@ frame_needed = 1, uses_anonymous_args = 0
 3998 0000 80B5     		push	{r7, lr}
 3999              		.cfi_def_cfa_offset 8
 4000              		.cfi_offset 7, -8
 4001              		.cfi_offset 14, -4
 4002 0002 8CB0     		sub	sp, sp, #48
 4003              		.cfi_def_cfa_offset 56
 4004 0004 00AF     		add	r7, sp, #0
 4005              		.cfi_def_cfa_register 7
 4006 0006 F860     		str	r0, [r7, #12]
 4007 0008 B960     		str	r1, [r7, #8]
 4008 000a 3B60     		str	r3, [r7]
 4009 000c 1346     		mov	r3, r2
 4010 000e FB71     		strb	r3, [r7, #7]
4324:../src/RTOS/tasks.c **** 	TCB_t * pxTCB;
4325:../src/RTOS/tasks.c **** 	uint8_t ucOriginalNotifyState;
4326:../src/RTOS/tasks.c **** 	BaseType_t xReturn = pdPASS;
 4011              		.loc 1 4326 0
 4012 0010 0123     		movs	r3, #1
 4013 0012 FB62     		str	r3, [r7, #44]
4327:../src/RTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4328:../src/RTOS/tasks.c **** 
4329:../src/RTOS/tasks.c **** 		configASSERT( xTaskToNotify );
 4014              		.loc 1 4329 0
 4015 0014 FB68     		ldr	r3, [r7, #12]
 4016 0016 002B     		cmp	r3, #0
 4017 0018 00D1     		bne	.L315
 4018              	.L316:
 4019              		.loc 1 4329 0 is_stmt 0 discriminator 1
 4020 001a FEE7     		b	.L316
 4021              	.L315:
4330:../src/RTOS/tasks.c **** 
4331:../src/RTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4332:../src/RTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4333:../src/RTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4334:../src/RTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4335:../src/RTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4336:../src/RTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
4337:../src/RTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4338:../src/RTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4339:../src/RTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
4340:../src/RTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4341:../src/RTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4342:../src/RTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4343:../src/RTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4344:../src/RTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4345:../src/RTOS/tasks.c **** 		provided on the following link:
4346:../src/RTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4347:../src/RTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 4022              		.loc 1 4347 0 is_stmt 1
 4023 001c FFF7FEFF 		bl	vPortValidateInterruptPriority
4348:../src/RTOS/tasks.c **** 
4349:../src/RTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 4024              		.loc 1 4349 0
 4025 0020 FB68     		ldr	r3, [r7, #12]
 4026 0022 BB62     		str	r3, [r7, #40]
 4027              	.LBB34:
 4028              	.LBB35:
 253:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 4029              		.loc 2 253 0
 4030              	@ 253 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 4031 0024 EFF31182 			mrs r2, basepri											
 4032 0028 4FF0BF03 		mov r3, #191												
 4033 002c 83F31188 		msr basepri, r3											
 4034 0030 BFF36F8F 		isb														
 4035 0034 BFF34F8F 		dsb														
 4036              	
 4037              	@ 0 "" 2
 4038              		.thumb
 4039 0038 FA61     		str	r2, [r7, #28]
 4040 003a BB61     		str	r3, [r7, #24]
 265:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 4041              		.loc 2 265 0
 4042 003c FB69     		ldr	r3, [r7, #28]
 4043              	.LBE35:
 4044              	.LBE34:
4350:../src/RTOS/tasks.c **** 
4351:../src/RTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4045              		.loc 1 4351 0
 4046 003e 7B62     		str	r3, [r7, #36]
4352:../src/RTOS/tasks.c **** 		{
4353:../src/RTOS/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 4047              		.loc 1 4353 0
 4048 0040 3B68     		ldr	r3, [r7]
 4049 0042 002B     		cmp	r3, #0
 4050 0044 03D0     		beq	.L318
4354:../src/RTOS/tasks.c **** 			{
4355:../src/RTOS/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 4051              		.loc 1 4355 0
 4052 0046 BB6A     		ldr	r3, [r7, #40]
 4053 0048 5A6C     		ldr	r2, [r3, #68]
 4054 004a 3B68     		ldr	r3, [r7]
 4055 004c 1A60     		str	r2, [r3]
 4056              	.L318:
4356:../src/RTOS/tasks.c **** 			}
4357:../src/RTOS/tasks.c **** 
4358:../src/RTOS/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4057              		.loc 1 4358 0
 4058 004e BB6A     		ldr	r3, [r7, #40]
 4059 0050 93F84830 		ldrb	r3, [r3, #72]
 4060 0054 87F82330 		strb	r3, [r7, #35]
4359:../src/RTOS/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4061              		.loc 1 4359 0
 4062 0058 BB6A     		ldr	r3, [r7, #40]
 4063 005a 0222     		movs	r2, #2
 4064 005c 83F84820 		strb	r2, [r3, #72]
4360:../src/RTOS/tasks.c **** 
4361:../src/RTOS/tasks.c **** 			switch( eAction )
 4065              		.loc 1 4361 0
 4066 0060 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4067 0062 042B     		cmp	r3, #4
 4068 0064 28D8     		bhi	.L319
 4069 0066 01A2     		adr	r2, .L321
 4070 0068 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 4071              		.p2align 2
 4072              	.L321:
 4073 006c B9000000 		.word	.L319+1
 4074 0070 81000000 		.word	.L322+1
 4075 0074 8F000000 		.word	.L323+1
 4076 0078 9B000000 		.word	.L324+1
 4077 007c A3000000 		.word	.L325+1
 4078              		.p2align 1
 4079              	.L322:
4362:../src/RTOS/tasks.c **** 			{
4363:../src/RTOS/tasks.c **** 				case eSetBits	:
4364:../src/RTOS/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 4080              		.loc 1 4364 0
 4081 0080 BB6A     		ldr	r3, [r7, #40]
 4082 0082 5A6C     		ldr	r2, [r3, #68]
 4083 0084 BB68     		ldr	r3, [r7, #8]
 4084 0086 1A43     		orrs	r2, r2, r3
 4085 0088 BB6A     		ldr	r3, [r7, #40]
 4086 008a 5A64     		str	r2, [r3, #68]
4365:../src/RTOS/tasks.c **** 					break;
 4087              		.loc 1 4365 0
 4088 008c 14E0     		b	.L319
 4089              	.L323:
4366:../src/RTOS/tasks.c **** 
4367:../src/RTOS/tasks.c **** 				case eIncrement	:
4368:../src/RTOS/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 4090              		.loc 1 4368 0
 4091 008e BB6A     		ldr	r3, [r7, #40]
 4092 0090 5B6C     		ldr	r3, [r3, #68]
 4093 0092 5A1C     		adds	r2, r3, #1
 4094 0094 BB6A     		ldr	r3, [r7, #40]
 4095 0096 5A64     		str	r2, [r3, #68]
4369:../src/RTOS/tasks.c **** 					break;
 4096              		.loc 1 4369 0
 4097 0098 0EE0     		b	.L319
 4098              	.L324:
4370:../src/RTOS/tasks.c **** 
4371:../src/RTOS/tasks.c **** 				case eSetValueWithOverwrite	:
4372:../src/RTOS/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 4099              		.loc 1 4372 0
 4100 009a BB6A     		ldr	r3, [r7, #40]
 4101 009c BA68     		ldr	r2, [r7, #8]
 4102 009e 5A64     		str	r2, [r3, #68]
4373:../src/RTOS/tasks.c **** 					break;
 4103              		.loc 1 4373 0
 4104 00a0 0AE0     		b	.L319
 4105              	.L325:
4374:../src/RTOS/tasks.c **** 
4375:../src/RTOS/tasks.c **** 				case eSetValueWithoutOverwrite :
4376:../src/RTOS/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4106              		.loc 1 4376 0
 4107 00a2 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 4108 00a6 022B     		cmp	r3, #2
 4109 00a8 03D0     		beq	.L326
4377:../src/RTOS/tasks.c **** 					{
4378:../src/RTOS/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 4110              		.loc 1 4378 0
 4111 00aa BB6A     		ldr	r3, [r7, #40]
 4112 00ac BA68     		ldr	r2, [r7, #8]
 4113 00ae 5A64     		str	r2, [r3, #68]
4379:../src/RTOS/tasks.c **** 					}
4380:../src/RTOS/tasks.c **** 					else
4381:../src/RTOS/tasks.c **** 					{
4382:../src/RTOS/tasks.c **** 						/* The value could not be written to the task. */
4383:../src/RTOS/tasks.c **** 						xReturn = pdFAIL;
4384:../src/RTOS/tasks.c **** 					}
4385:../src/RTOS/tasks.c **** 					break;
 4114              		.loc 1 4385 0
 4115 00b0 01E0     		b	.L337
 4116              	.L326:
4383:../src/RTOS/tasks.c **** 					}
 4117              		.loc 1 4383 0
 4118 00b2 0023     		movs	r3, #0
 4119 00b4 FB62     		str	r3, [r7, #44]
 4120              	.L337:
 4121              		.loc 1 4385 0
 4122 00b6 00BF     		nop
 4123              	.L319:
4386:../src/RTOS/tasks.c **** 
4387:../src/RTOS/tasks.c **** 				case eNoAction :
4388:../src/RTOS/tasks.c **** 					/* The task is being notified without its notify value being
4389:../src/RTOS/tasks.c **** 					updated. */
4390:../src/RTOS/tasks.c **** 					break;
4391:../src/RTOS/tasks.c **** 			}
4392:../src/RTOS/tasks.c **** 
4393:../src/RTOS/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4394:../src/RTOS/tasks.c **** 
4395:../src/RTOS/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4396:../src/RTOS/tasks.c **** 			notification then unblock it now. */
4397:../src/RTOS/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4124              		.loc 1 4397 0
 4125 00b8 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 4126 00bc 012B     		cmp	r3, #1
 4127 00be 3DD1     		bne	.L328
4398:../src/RTOS/tasks.c **** 			{
4399:../src/RTOS/tasks.c **** 				/* The task should not have been on an event list. */
4400:../src/RTOS/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 4128              		.loc 1 4400 0
 4129 00c0 BB6A     		ldr	r3, [r7, #40]
 4130 00c2 9B6A     		ldr	r3, [r3, #40]
 4131 00c4 002B     		cmp	r3, #0
 4132 00c6 00D0     		beq	.L329
 4133              	.L330:
 4134              		.loc 1 4400 0 is_stmt 0 discriminator 2
 4135 00c8 FEE7     		b	.L330
 4136              	.L329:
4401:../src/RTOS/tasks.c **** 
4402:../src/RTOS/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4137              		.loc 1 4402 0 is_stmt 1
 4138 00ca 214B     		ldr	r3, .L338
 4139 00cc 1B68     		ldr	r3, [r3]
 4140 00ce 002B     		cmp	r3, #0
 4141 00d0 1DD1     		bne	.L331
4403:../src/RTOS/tasks.c **** 				{
4404:../src/RTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4142              		.loc 1 4404 0
 4143 00d2 BB6A     		ldr	r3, [r7, #40]
 4144 00d4 0433     		adds	r3, r3, #4
 4145 00d6 1846     		mov	r0, r3
 4146 00d8 FFF7FEFF 		bl	uxListRemove
4405:../src/RTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4147              		.loc 1 4405 0
 4148 00dc BB6A     		ldr	r3, [r7, #40]
 4149 00de DA6A     		ldr	r2, [r3, #44]
 4150 00e0 1C4B     		ldr	r3, .L338+4
 4151 00e2 1B68     		ldr	r3, [r3]
 4152 00e4 9A42     		cmp	r2, r3
 4153 00e6 03D9     		bls	.L332
 4154              		.loc 1 4405 0 is_stmt 0 discriminator 1
 4155 00e8 BB6A     		ldr	r3, [r7, #40]
 4156 00ea DB6A     		ldr	r3, [r3, #44]
 4157 00ec 194A     		ldr	r2, .L338+4
 4158 00ee 1360     		str	r3, [r2]
 4159              	.L332:
 4160              		.loc 1 4405 0 discriminator 3
 4161 00f0 BB6A     		ldr	r3, [r7, #40]
 4162 00f2 DA6A     		ldr	r2, [r3, #44]
 4163 00f4 1346     		mov	r3, r2
 4164 00f6 9B00     		lsls	r3, r3, #2
 4165 00f8 1344     		add	r3, r3, r2
 4166 00fa 9B00     		lsls	r3, r3, #2
 4167 00fc 164A     		ldr	r2, .L338+8
 4168 00fe 1A44     		add	r2, r2, r3
 4169 0100 BB6A     		ldr	r3, [r7, #40]
 4170 0102 0433     		adds	r3, r3, #4
 4171 0104 1046     		mov	r0, r2
 4172 0106 1946     		mov	r1, r3
 4173 0108 FFF7FEFF 		bl	vListInsertEnd
 4174 010c 05E0     		b	.L333
 4175              	.L331:
4406:../src/RTOS/tasks.c **** 				}
4407:../src/RTOS/tasks.c **** 				else
4408:../src/RTOS/tasks.c **** 				{
4409:../src/RTOS/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4410:../src/RTOS/tasks.c **** 					this task pending until the scheduler is resumed. */
4411:../src/RTOS/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4176              		.loc 1 4411 0 is_stmt 1
 4177 010e BB6A     		ldr	r3, [r7, #40]
 4178 0110 1833     		adds	r3, r3, #24
 4179 0112 1248     		ldr	r0, .L338+12
 4180 0114 1946     		mov	r1, r3
 4181 0116 FFF7FEFF 		bl	vListInsertEnd
 4182              	.L333:
4412:../src/RTOS/tasks.c **** 				}
4413:../src/RTOS/tasks.c **** 
4414:../src/RTOS/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4183              		.loc 1 4414 0
 4184 011a BB6A     		ldr	r3, [r7, #40]
 4185 011c DA6A     		ldr	r2, [r3, #44]
 4186 011e 104B     		ldr	r3, .L338+16
 4187 0120 1B68     		ldr	r3, [r3]
 4188 0122 DB6A     		ldr	r3, [r3, #44]
 4189 0124 9A42     		cmp	r2, r3
 4190 0126 09D9     		bls	.L328
4415:../src/RTOS/tasks.c **** 				{
4416:../src/RTOS/tasks.c **** 					/* The notified task has a priority above the currently
4417:../src/RTOS/tasks.c **** 					executing task so a yield is required. */
4418:../src/RTOS/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 4191              		.loc 1 4418 0
 4192 0128 BB6B     		ldr	r3, [r7, #56]
 4193 012a 002B     		cmp	r3, #0
 4194 012c 03D0     		beq	.L334
4419:../src/RTOS/tasks.c **** 					{
4420:../src/RTOS/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 4195              		.loc 1 4420 0
 4196 012e BB6B     		ldr	r3, [r7, #56]
 4197 0130 0122     		movs	r2, #1
 4198 0132 1A60     		str	r2, [r3]
 4199 0134 02E0     		b	.L328
 4200              	.L334:
4421:../src/RTOS/tasks.c **** 					}
4422:../src/RTOS/tasks.c **** 					else
4423:../src/RTOS/tasks.c **** 					{
4424:../src/RTOS/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4425:../src/RTOS/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter to an ISR
4426:../src/RTOS/tasks.c **** 						safe FreeRTOS function. */
4427:../src/RTOS/tasks.c **** 						xYieldPending = pdTRUE;
 4201              		.loc 1 4427 0
 4202 0136 0B4B     		ldr	r3, .L338+20
 4203 0138 0122     		movs	r2, #1
 4204 013a 1A60     		str	r2, [r3]
 4205              	.L328:
 4206 013c 7B6A     		ldr	r3, [r7, #36]
 4207 013e 7B61     		str	r3, [r7, #20]
 4208              	.LBB36:
 4209              	.LBB37:
 4210              		.loc 2 271 0
 4211 0140 7B69     		ldr	r3, [r7, #20]
 4212              	@ 271 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 4213 0142 83F31188 			msr basepri, r3	
 4214              	@ 0 "" 2
 4215              		.thumb
 4216              	.LBE37:
 4217              	.LBE36:
4428:../src/RTOS/tasks.c **** 					}
4429:../src/RTOS/tasks.c **** 				}
4430:../src/RTOS/tasks.c **** 				else
4431:../src/RTOS/tasks.c **** 				{
4432:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4433:../src/RTOS/tasks.c **** 				}
4434:../src/RTOS/tasks.c **** 			}
4435:../src/RTOS/tasks.c **** 		}
4436:../src/RTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4437:../src/RTOS/tasks.c **** 
4438:../src/RTOS/tasks.c **** 		return xReturn;
 4218              		.loc 1 4438 0
 4219 0146 FB6A     		ldr	r3, [r7, #44]
4439:../src/RTOS/tasks.c **** 	}
 4220              		.loc 1 4439 0
 4221 0148 1846     		mov	r0, r3
 4222 014a 3037     		adds	r7, r7, #48
 4223              		.cfi_def_cfa_offset 8
 4224 014c BD46     		mov	sp, r7
 4225              		.cfi_def_cfa_register 13
 4226              		@ sp needed
 4227 014e 80BD     		pop	{r7, pc}
 4228              	.L339:
 4229              		.align	2
 4230              	.L338:
 4231 0150 00000000 		.word	uxSchedulerSuspended
 4232 0154 00000000 		.word	uxTopReadyPriority
 4233 0158 00000000 		.word	pxReadyTasksLists
 4234 015c 00000000 		.word	xPendingReadyList
 4235 0160 00000000 		.word	pxCurrentTCB
 4236 0164 00000000 		.word	xYieldPending
 4237              		.cfi_endproc
 4238              	.LFE43:
 4240              		.section	.text.vTaskNotifyGiveFromISR,"ax",%progbits
 4241              		.align	2
 4242              		.global	vTaskNotifyGiveFromISR
 4243              		.thumb
 4244              		.thumb_func
 4246              	vTaskNotifyGiveFromISR:
 4247              	.LFB44:
4440:../src/RTOS/tasks.c **** 
4441:../src/RTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4442:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
4443:../src/RTOS/tasks.c **** 
4444:../src/RTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4445:../src/RTOS/tasks.c **** 
4446:../src/RTOS/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4447:../src/RTOS/tasks.c **** 	{
 4248              		.loc 1 4447 0
 4249              		.cfi_startproc
 4250              		@ args = 0, pretend = 0, frame = 32
 4251              		@ frame_needed = 1, uses_anonymous_args = 0
 4252 0000 80B5     		push	{r7, lr}
 4253              		.cfi_def_cfa_offset 8
 4254              		.cfi_offset 7, -8
 4255              		.cfi_offset 14, -4
 4256 0002 88B0     		sub	sp, sp, #32
 4257              		.cfi_def_cfa_offset 40
 4258 0004 00AF     		add	r7, sp, #0
 4259              		.cfi_def_cfa_register 7
 4260 0006 7860     		str	r0, [r7, #4]
 4261 0008 3960     		str	r1, [r7]
4448:../src/RTOS/tasks.c **** 	TCB_t * pxTCB;
4449:../src/RTOS/tasks.c **** 	uint8_t ucOriginalNotifyState;
4450:../src/RTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4451:../src/RTOS/tasks.c **** 
4452:../src/RTOS/tasks.c **** 		configASSERT( xTaskToNotify );
 4262              		.loc 1 4452 0
 4263 000a 7B68     		ldr	r3, [r7, #4]
 4264 000c 002B     		cmp	r3, #0
 4265 000e 00D1     		bne	.L341
 4266              	.L342:
 4267              		.loc 1 4452 0 is_stmt 0 discriminator 1
 4268 0010 FEE7     		b	.L342
 4269              	.L341:
4453:../src/RTOS/tasks.c **** 
4454:../src/RTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4455:../src/RTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4456:../src/RTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4457:../src/RTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4458:../src/RTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4459:../src/RTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
4460:../src/RTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4461:../src/RTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4462:../src/RTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
4463:../src/RTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4464:../src/RTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4465:../src/RTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4466:../src/RTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4467:../src/RTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4468:../src/RTOS/tasks.c **** 		provided on the following link:
4469:../src/RTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4470:../src/RTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 4270              		.loc 1 4470 0 is_stmt 1
 4271 0012 FFF7FEFF 		bl	vPortValidateInterruptPriority
4471:../src/RTOS/tasks.c **** 
4472:../src/RTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 4272              		.loc 1 4472 0
 4273 0016 7B68     		ldr	r3, [r7, #4]
 4274 0018 FB61     		str	r3, [r7, #28]
 4275              	.LBB38:
 4276              	.LBB39:
 253:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** 	(
 4277              		.loc 2 253 0
 4278              	@ 253 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 4279 001a EFF31182 			mrs r2, basepri											
 4280 001e 4FF0BF03 		mov r3, #191												
 4281 0022 83F31188 		msr basepri, r3											
 4282 0026 BFF36F8F 		isb														
 4283 002a BFF34F8F 		dsb														
 4284              	
 4285              	@ 0 "" 2
 4286              		.thumb
 4287 002e 3A61     		str	r2, [r7, #16]
 4288 0030 FB60     		str	r3, [r7, #12]
 265:U:/Thunderspace/EFM32LG330F128/RTOSincludes\portmacro.h **** }
 4289              		.loc 2 265 0
 4290 0032 3B69     		ldr	r3, [r7, #16]
 4291              	.LBE39:
 4292              	.LBE38:
4473:../src/RTOS/tasks.c **** 
4474:../src/RTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4293              		.loc 1 4474 0
 4294 0034 BB61     		str	r3, [r7, #24]
4475:../src/RTOS/tasks.c **** 		{
4476:../src/RTOS/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4295              		.loc 1 4476 0
 4296 0036 FB69     		ldr	r3, [r7, #28]
 4297 0038 93F84830 		ldrb	r3, [r3, #72]
 4298 003c FB75     		strb	r3, [r7, #23]
4477:../src/RTOS/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4299              		.loc 1 4477 0
 4300 003e FB69     		ldr	r3, [r7, #28]
 4301 0040 0222     		movs	r2, #2
 4302 0042 83F84820 		strb	r2, [r3, #72]
4478:../src/RTOS/tasks.c **** 
4479:../src/RTOS/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4480:../src/RTOS/tasks.c **** 			semaphore. */
4481:../src/RTOS/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
 4303              		.loc 1 4481 0
 4304 0046 FB69     		ldr	r3, [r7, #28]
 4305 0048 5B6C     		ldr	r3, [r3, #68]
 4306 004a 5A1C     		adds	r2, r3, #1
 4307 004c FB69     		ldr	r3, [r7, #28]
 4308 004e 5A64     		str	r2, [r3, #68]
4482:../src/RTOS/tasks.c **** 
4483:../src/RTOS/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4484:../src/RTOS/tasks.c **** 
4485:../src/RTOS/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4486:../src/RTOS/tasks.c **** 			notification then unblock it now. */
4487:../src/RTOS/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4309              		.loc 1 4487 0
 4310 0050 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4311 0052 012B     		cmp	r3, #1
 4312 0054 3DD1     		bne	.L344
4488:../src/RTOS/tasks.c **** 			{
4489:../src/RTOS/tasks.c **** 				/* The task should not have been on an event list. */
4490:../src/RTOS/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 4313              		.loc 1 4490 0
 4314 0056 FB69     		ldr	r3, [r7, #28]
 4315 0058 9B6A     		ldr	r3, [r3, #40]
 4316 005a 002B     		cmp	r3, #0
 4317 005c 00D0     		beq	.L345
 4318              	.L346:
 4319              		.loc 1 4490 0 is_stmt 0 discriminator 2
 4320 005e FEE7     		b	.L346
 4321              	.L345:
4491:../src/RTOS/tasks.c **** 
4492:../src/RTOS/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4322              		.loc 1 4492 0 is_stmt 1
 4323 0060 204B     		ldr	r3, .L352
 4324 0062 1B68     		ldr	r3, [r3]
 4325 0064 002B     		cmp	r3, #0
 4326 0066 1DD1     		bne	.L347
4493:../src/RTOS/tasks.c **** 				{
4494:../src/RTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4327              		.loc 1 4494 0
 4328 0068 FB69     		ldr	r3, [r7, #28]
 4329 006a 0433     		adds	r3, r3, #4
 4330 006c 1846     		mov	r0, r3
 4331 006e FFF7FEFF 		bl	uxListRemove
4495:../src/RTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4332              		.loc 1 4495 0
 4333 0072 FB69     		ldr	r3, [r7, #28]
 4334 0074 DA6A     		ldr	r2, [r3, #44]
 4335 0076 1C4B     		ldr	r3, .L352+4
 4336 0078 1B68     		ldr	r3, [r3]
 4337 007a 9A42     		cmp	r2, r3
 4338 007c 03D9     		bls	.L348
 4339              		.loc 1 4495 0 is_stmt 0 discriminator 1
 4340 007e FB69     		ldr	r3, [r7, #28]
 4341 0080 DB6A     		ldr	r3, [r3, #44]
 4342 0082 194A     		ldr	r2, .L352+4
 4343 0084 1360     		str	r3, [r2]
 4344              	.L348:
 4345              		.loc 1 4495 0 discriminator 3
 4346 0086 FB69     		ldr	r3, [r7, #28]
 4347 0088 DA6A     		ldr	r2, [r3, #44]
 4348 008a 1346     		mov	r3, r2
 4349 008c 9B00     		lsls	r3, r3, #2
 4350 008e 1344     		add	r3, r3, r2
 4351 0090 9B00     		lsls	r3, r3, #2
 4352 0092 164A     		ldr	r2, .L352+8
 4353 0094 1A44     		add	r2, r2, r3
 4354 0096 FB69     		ldr	r3, [r7, #28]
 4355 0098 0433     		adds	r3, r3, #4
 4356 009a 1046     		mov	r0, r2
 4357 009c 1946     		mov	r1, r3
 4358 009e FFF7FEFF 		bl	vListInsertEnd
 4359 00a2 05E0     		b	.L349
 4360              	.L347:
4496:../src/RTOS/tasks.c **** 				}
4497:../src/RTOS/tasks.c **** 				else
4498:../src/RTOS/tasks.c **** 				{
4499:../src/RTOS/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4500:../src/RTOS/tasks.c **** 					this task pending until the scheduler is resumed. */
4501:../src/RTOS/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4361              		.loc 1 4501 0 is_stmt 1
 4362 00a4 FB69     		ldr	r3, [r7, #28]
 4363 00a6 1833     		adds	r3, r3, #24
 4364 00a8 1148     		ldr	r0, .L352+12
 4365 00aa 1946     		mov	r1, r3
 4366 00ac FFF7FEFF 		bl	vListInsertEnd
 4367              	.L349:
4502:../src/RTOS/tasks.c **** 				}
4503:../src/RTOS/tasks.c **** 
4504:../src/RTOS/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4368              		.loc 1 4504 0
 4369 00b0 FB69     		ldr	r3, [r7, #28]
 4370 00b2 DA6A     		ldr	r2, [r3, #44]
 4371 00b4 0F4B     		ldr	r3, .L352+16
 4372 00b6 1B68     		ldr	r3, [r3]
 4373 00b8 DB6A     		ldr	r3, [r3, #44]
 4374 00ba 9A42     		cmp	r2, r3
 4375 00bc 09D9     		bls	.L344
4505:../src/RTOS/tasks.c **** 				{
4506:../src/RTOS/tasks.c **** 					/* The notified task has a priority above the currently
4507:../src/RTOS/tasks.c **** 					executing task so a yield is required. */
4508:../src/RTOS/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 4376              		.loc 1 4508 0
 4377 00be 3B68     		ldr	r3, [r7]
 4378 00c0 002B     		cmp	r3, #0
 4379 00c2 03D0     		beq	.L350
4509:../src/RTOS/tasks.c **** 					{
4510:../src/RTOS/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 4380              		.loc 1 4510 0
 4381 00c4 3B68     		ldr	r3, [r7]
 4382 00c6 0122     		movs	r2, #1
 4383 00c8 1A60     		str	r2, [r3]
 4384 00ca 02E0     		b	.L344
 4385              	.L350:
4511:../src/RTOS/tasks.c **** 					}
4512:../src/RTOS/tasks.c **** 					else
4513:../src/RTOS/tasks.c **** 					{
4514:../src/RTOS/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4515:../src/RTOS/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter in an ISR
4516:../src/RTOS/tasks.c **** 						safe FreeRTOS function. */
4517:../src/RTOS/tasks.c **** 						xYieldPending = pdTRUE;
 4386              		.loc 1 4517 0
 4387 00cc 0A4B     		ldr	r3, .L352+20
 4388 00ce 0122     		movs	r2, #1
 4389 00d0 1A60     		str	r2, [r3]
 4390              	.L344:
 4391 00d2 BB69     		ldr	r3, [r7, #24]
 4392 00d4 BB60     		str	r3, [r7, #8]
 4393              	.LBB40:
 4394              	.LBB41:
 4395              		.loc 2 271 0
 4396 00d6 BB68     		ldr	r3, [r7, #8]
 4397              	@ 271 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/portmacro.h" 1
 4398 00d8 83F31188 			msr basepri, r3	
 4399              	@ 0 "" 2
 4400              		.thumb
 4401              	.LBE41:
 4402              	.LBE40:
4518:../src/RTOS/tasks.c **** 					}
4519:../src/RTOS/tasks.c **** 				}
4520:../src/RTOS/tasks.c **** 				else
4521:../src/RTOS/tasks.c **** 				{
4522:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4523:../src/RTOS/tasks.c **** 				}
4524:../src/RTOS/tasks.c **** 			}
4525:../src/RTOS/tasks.c **** 		}
4526:../src/RTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4527:../src/RTOS/tasks.c **** 	}
 4403              		.loc 1 4527 0
 4404 00dc 2037     		adds	r7, r7, #32
 4405              		.cfi_def_cfa_offset 8
 4406 00de BD46     		mov	sp, r7
 4407              		.cfi_def_cfa_register 13
 4408              		@ sp needed
 4409 00e0 80BD     		pop	{r7, pc}
 4410              	.L353:
 4411 00e2 00BF     		.align	2
 4412              	.L352:
 4413 00e4 00000000 		.word	uxSchedulerSuspended
 4414 00e8 00000000 		.word	uxTopReadyPriority
 4415 00ec 00000000 		.word	pxReadyTasksLists
 4416 00f0 00000000 		.word	xPendingReadyList
 4417 00f4 00000000 		.word	pxCurrentTCB
 4418 00f8 00000000 		.word	xYieldPending
 4419              		.cfi_endproc
 4420              	.LFE44:
 4422              		.section	.text.xTaskNotifyStateClear,"ax",%progbits
 4423              		.align	2
 4424              		.global	xTaskNotifyStateClear
 4425              		.thumb
 4426              		.thumb_func
 4428              	xTaskNotifyStateClear:
 4429              	.LFB45:
4528:../src/RTOS/tasks.c **** 
4529:../src/RTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4530:../src/RTOS/tasks.c **** 
4531:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
4532:../src/RTOS/tasks.c **** 
4533:../src/RTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4534:../src/RTOS/tasks.c **** 
4535:../src/RTOS/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4536:../src/RTOS/tasks.c **** 	{
 4430              		.loc 1 4536 0
 4431              		.cfi_startproc
 4432              		@ args = 0, pretend = 0, frame = 16
 4433              		@ frame_needed = 1, uses_anonymous_args = 0
 4434 0000 80B5     		push	{r7, lr}
 4435              		.cfi_def_cfa_offset 8
 4436              		.cfi_offset 7, -8
 4437              		.cfi_offset 14, -4
 4438 0002 84B0     		sub	sp, sp, #16
 4439              		.cfi_def_cfa_offset 24
 4440 0004 00AF     		add	r7, sp, #0
 4441              		.cfi_def_cfa_register 7
 4442 0006 7860     		str	r0, [r7, #4]
4537:../src/RTOS/tasks.c **** 	TCB_t *pxTCB;
4538:../src/RTOS/tasks.c **** 	BaseType_t xReturn;
4539:../src/RTOS/tasks.c **** 
4540:../src/RTOS/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4541:../src/RTOS/tasks.c **** 		its notification state cleared. */
4542:../src/RTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 4443              		.loc 1 4542 0
 4444 0008 7B68     		ldr	r3, [r7, #4]
 4445 000a 002B     		cmp	r3, #0
 4446 000c 02D1     		bne	.L355
 4447              		.loc 1 4542 0 is_stmt 0 discriminator 1
 4448 000e 0E4B     		ldr	r3, .L360
 4449 0010 1B68     		ldr	r3, [r3]
 4450 0012 00E0     		b	.L356
 4451              	.L355:
 4452              		.loc 1 4542 0 discriminator 2
 4453 0014 7B68     		ldr	r3, [r7, #4]
 4454              	.L356:
 4455              		.loc 1 4542 0 discriminator 4
 4456 0016 BB60     		str	r3, [r7, #8]
4543:../src/RTOS/tasks.c **** 
4544:../src/RTOS/tasks.c **** 		taskENTER_CRITICAL();
 4457              		.loc 1 4544 0 is_stmt 1 discriminator 4
 4458 0018 FFF7FEFF 		bl	vPortEnterCritical
4545:../src/RTOS/tasks.c **** 		{
4546:../src/RTOS/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 4459              		.loc 1 4546 0 discriminator 4
 4460 001c BB68     		ldr	r3, [r7, #8]
 4461 001e 93F84830 		ldrb	r3, [r3, #72]
 4462 0022 DBB2     		uxtb	r3, r3
 4463 0024 022B     		cmp	r3, #2
 4464 0026 06D1     		bne	.L357
4547:../src/RTOS/tasks.c **** 			{
4548:../src/RTOS/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 4465              		.loc 1 4548 0
 4466 0028 BB68     		ldr	r3, [r7, #8]
 4467 002a 0022     		movs	r2, #0
 4468 002c 83F84820 		strb	r2, [r3, #72]
4549:../src/RTOS/tasks.c **** 				xReturn = pdPASS;
 4469              		.loc 1 4549 0
 4470 0030 0123     		movs	r3, #1
 4471 0032 FB60     		str	r3, [r7, #12]
 4472 0034 01E0     		b	.L358
 4473              	.L357:
4550:../src/RTOS/tasks.c **** 			}
4551:../src/RTOS/tasks.c **** 			else
4552:../src/RTOS/tasks.c **** 			{
4553:../src/RTOS/tasks.c **** 				xReturn = pdFAIL;
 4474              		.loc 1 4553 0
 4475 0036 0023     		movs	r3, #0
 4476 0038 FB60     		str	r3, [r7, #12]
 4477              	.L358:
4554:../src/RTOS/tasks.c **** 			}
4555:../src/RTOS/tasks.c **** 		}
4556:../src/RTOS/tasks.c **** 		taskEXIT_CRITICAL();
 4478              		.loc 1 4556 0
 4479 003a FFF7FEFF 		bl	vPortExitCritical
4557:../src/RTOS/tasks.c **** 
4558:../src/RTOS/tasks.c **** 		return xReturn;
 4480              		.loc 1 4558 0
 4481 003e FB68     		ldr	r3, [r7, #12]
4559:../src/RTOS/tasks.c **** 	}
 4482              		.loc 1 4559 0
 4483 0040 1846     		mov	r0, r3
 4484 0042 1037     		adds	r7, r7, #16
 4485              		.cfi_def_cfa_offset 8
 4486 0044 BD46     		mov	sp, r7
 4487              		.cfi_def_cfa_register 13
 4488              		@ sp needed
 4489 0046 80BD     		pop	{r7, pc}
 4490              	.L361:
 4491              		.align	2
 4492              	.L360:
 4493 0048 00000000 		.word	pxCurrentTCB
 4494              		.cfi_endproc
 4495              	.LFE45:
 4497              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 4498              		.align	2
 4499              		.thumb
 4500              		.thumb_func
 4502              	prvAddCurrentTaskToDelayedList:
 4503              	.LFB46:
4560:../src/RTOS/tasks.c **** 
4561:../src/RTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4562:../src/RTOS/tasks.c **** /*-----------------------------------------------------------*/
4563:../src/RTOS/tasks.c **** 
4564:../src/RTOS/tasks.c **** 
4565:../src/RTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
4566:../src/RTOS/tasks.c **** {
 4504              		.loc 1 4566 0
 4505              		.cfi_startproc
 4506              		@ args = 0, pretend = 0, frame = 16
 4507              		@ frame_needed = 1, uses_anonymous_args = 0
 4508 0000 80B5     		push	{r7, lr}
 4509              		.cfi_def_cfa_offset 8
 4510              		.cfi_offset 7, -8
 4511              		.cfi_offset 14, -4
 4512 0002 84B0     		sub	sp, sp, #16
 4513              		.cfi_def_cfa_offset 24
 4514 0004 00AF     		add	r7, sp, #0
 4515              		.cfi_def_cfa_register 7
 4516 0006 7860     		str	r0, [r7, #4]
 4517 0008 3960     		str	r1, [r7]
4567:../src/RTOS/tasks.c **** TickType_t xTimeToWake;
4568:../src/RTOS/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 4518              		.loc 1 4568 0
 4519 000a 214B     		ldr	r3, .L366
 4520 000c 1B68     		ldr	r3, [r3]
 4521 000e FB60     		str	r3, [r7, #12]
4569:../src/RTOS/tasks.c **** 
4570:../src/RTOS/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4571:../src/RTOS/tasks.c **** 	{
4572:../src/RTOS/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4573:../src/RTOS/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4574:../src/RTOS/tasks.c **** 		when the task leaves the Blocked state. */
4575:../src/RTOS/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
4576:../src/RTOS/tasks.c **** 	}
4577:../src/RTOS/tasks.c **** 	#endif
4578:../src/RTOS/tasks.c **** 
4579:../src/RTOS/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
4580:../src/RTOS/tasks.c **** 	as the same list item is used for both lists. */
4581:../src/RTOS/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4522              		.loc 1 4581 0
 4523 0010 204B     		ldr	r3, .L366+4
 4524 0012 1B68     		ldr	r3, [r3]
 4525 0014 0433     		adds	r3, r3, #4
 4526 0016 1846     		mov	r0, r3
 4527 0018 FFF7FEFF 		bl	uxListRemove
4582:../src/RTOS/tasks.c **** 	{
4583:../src/RTOS/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
4584:../src/RTOS/tasks.c **** 		check, and the port reset macro can be called directly. */
4585:../src/RTOS/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
4586:../src/RTOS/tasks.c **** 	}
4587:../src/RTOS/tasks.c **** 	else
4588:../src/RTOS/tasks.c **** 	{
4589:../src/RTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
4590:../src/RTOS/tasks.c **** 	}
4591:../src/RTOS/tasks.c **** 
4592:../src/RTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
4593:../src/RTOS/tasks.c **** 	{
4594:../src/RTOS/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 4528              		.loc 1 4594 0
 4529 001c 7B68     		ldr	r3, [r7, #4]
 4530 001e B3F1FF3F 		cmp	r3, #-1
 4531 0022 0AD1     		bne	.L363
 4532              		.loc 1 4594 0 is_stmt 0 discriminator 1
 4533 0024 3B68     		ldr	r3, [r7]
 4534 0026 002B     		cmp	r3, #0
 4535 0028 07D0     		beq	.L363
4595:../src/RTOS/tasks.c **** 		{
4596:../src/RTOS/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
4597:../src/RTOS/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
4598:../src/RTOS/tasks.c **** 			indefinitely. */
4599:../src/RTOS/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4536              		.loc 1 4599 0 is_stmt 1
 4537 002a 1A4B     		ldr	r3, .L366+4
 4538 002c 1B68     		ldr	r3, [r3]
 4539 002e 0433     		adds	r3, r3, #4
 4540 0030 1948     		ldr	r0, .L366+8
 4541 0032 1946     		mov	r1, r3
 4542 0034 FFF7FEFF 		bl	vListInsertEnd
 4543 0038 26E0     		b	.L362
 4544              	.L363:
4600:../src/RTOS/tasks.c **** 		}
4601:../src/RTOS/tasks.c **** 		else
4602:../src/RTOS/tasks.c **** 		{
4603:../src/RTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
4604:../src/RTOS/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
4605:../src/RTOS/tasks.c **** 			kernel will manage it correctly. */
4606:../src/RTOS/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
 4545              		.loc 1 4606 0
 4546 003a FA68     		ldr	r2, [r7, #12]
 4547 003c 7B68     		ldr	r3, [r7, #4]
 4548 003e 1344     		add	r3, r3, r2
 4549 0040 BB60     		str	r3, [r7, #8]
4607:../src/RTOS/tasks.c **** 
4608:../src/RTOS/tasks.c **** 			/* The list item will be inserted in wake time order. */
4609:../src/RTOS/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 4550              		.loc 1 4609 0
 4551 0042 144B     		ldr	r3, .L366+4
 4552 0044 1B68     		ldr	r3, [r3]
 4553 0046 BA68     		ldr	r2, [r7, #8]
 4554 0048 5A60     		str	r2, [r3, #4]
4610:../src/RTOS/tasks.c **** 
4611:../src/RTOS/tasks.c **** 			if( xTimeToWake < xConstTickCount )
 4555              		.loc 1 4611 0
 4556 004a BA68     		ldr	r2, [r7, #8]
 4557 004c FB68     		ldr	r3, [r7, #12]
 4558 004e 9A42     		cmp	r2, r3
 4559 0050 09D2     		bcs	.L365
4612:../src/RTOS/tasks.c **** 			{
4613:../src/RTOS/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
4614:../src/RTOS/tasks.c **** 				list. */
4615:../src/RTOS/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4560              		.loc 1 4615 0
 4561 0052 124B     		ldr	r3, .L366+12
 4562 0054 1A68     		ldr	r2, [r3]
 4563 0056 0F4B     		ldr	r3, .L366+4
 4564 0058 1B68     		ldr	r3, [r3]
 4565 005a 0433     		adds	r3, r3, #4
 4566 005c 1046     		mov	r0, r2
 4567 005e 1946     		mov	r1, r3
 4568 0060 FFF7FEFF 		bl	vListInsert
 4569 0064 10E0     		b	.L362
 4570              	.L365:
4616:../src/RTOS/tasks.c **** 			}
4617:../src/RTOS/tasks.c **** 			else
4618:../src/RTOS/tasks.c **** 			{
4619:../src/RTOS/tasks.c **** 				/* The wake time has not overflowed, so the current block list
4620:../src/RTOS/tasks.c **** 				is used. */
4621:../src/RTOS/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4571              		.loc 1 4621 0
 4572 0066 0E4B     		ldr	r3, .L366+16
 4573 0068 1A68     		ldr	r2, [r3]
 4574 006a 0A4B     		ldr	r3, .L366+4
 4575 006c 1B68     		ldr	r3, [r3]
 4576 006e 0433     		adds	r3, r3, #4
 4577 0070 1046     		mov	r0, r2
 4578 0072 1946     		mov	r1, r3
 4579 0074 FFF7FEFF 		bl	vListInsert
4622:../src/RTOS/tasks.c **** 
4623:../src/RTOS/tasks.c **** 				/* If the task entering the blocked state was placed at the
4624:../src/RTOS/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
4625:../src/RTOS/tasks.c **** 				needs to be updated too. */
4626:../src/RTOS/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
 4580              		.loc 1 4626 0
 4581 0078 0A4B     		ldr	r3, .L366+20
 4582 007a 1B68     		ldr	r3, [r3]
 4583 007c BA68     		ldr	r2, [r7, #8]
 4584 007e 9A42     		cmp	r2, r3
 4585 0080 02D2     		bcs	.L362
4627:../src/RTOS/tasks.c **** 				{
4628:../src/RTOS/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
 4586              		.loc 1 4628 0
 4587 0082 084A     		ldr	r2, .L366+20
 4588 0084 BB68     		ldr	r3, [r7, #8]
 4589 0086 1360     		str	r3, [r2]
 4590              	.L362:
4629:../src/RTOS/tasks.c **** 				}
4630:../src/RTOS/tasks.c **** 				else
4631:../src/RTOS/tasks.c **** 				{
4632:../src/RTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4633:../src/RTOS/tasks.c **** 				}
4634:../src/RTOS/tasks.c **** 			}
4635:../src/RTOS/tasks.c **** 		}
4636:../src/RTOS/tasks.c **** 	}
4637:../src/RTOS/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
4638:../src/RTOS/tasks.c **** 	{
4639:../src/RTOS/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
4640:../src/RTOS/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
4641:../src/RTOS/tasks.c **** 		will manage it correctly. */
4642:../src/RTOS/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
4643:../src/RTOS/tasks.c **** 
4644:../src/RTOS/tasks.c **** 		/* The list item will be inserted in wake time order. */
4645:../src/RTOS/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
4646:../src/RTOS/tasks.c **** 
4647:../src/RTOS/tasks.c **** 		if( xTimeToWake < xConstTickCount )
4648:../src/RTOS/tasks.c **** 		{
4649:../src/RTOS/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
4650:../src/RTOS/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4651:../src/RTOS/tasks.c **** 		}
4652:../src/RTOS/tasks.c **** 		else
4653:../src/RTOS/tasks.c **** 		{
4654:../src/RTOS/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
4655:../src/RTOS/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4656:../src/RTOS/tasks.c **** 
4657:../src/RTOS/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
4658:../src/RTOS/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
4659:../src/RTOS/tasks.c **** 			too. */
4660:../src/RTOS/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
4661:../src/RTOS/tasks.c **** 			{
4662:../src/RTOS/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
4663:../src/RTOS/tasks.c **** 			}
4664:../src/RTOS/tasks.c **** 			else
4665:../src/RTOS/tasks.c **** 			{
4666:../src/RTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4667:../src/RTOS/tasks.c **** 			}
4668:../src/RTOS/tasks.c **** 		}
4669:../src/RTOS/tasks.c **** 
4670:../src/RTOS/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
4671:../src/RTOS/tasks.c **** 		( void ) xCanBlockIndefinitely;
4672:../src/RTOS/tasks.c **** 	}
4673:../src/RTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
4674:../src/RTOS/tasks.c **** }
 4591              		.loc 1 4674 0
 4592 0088 1037     		adds	r7, r7, #16
 4593              		.cfi_def_cfa_offset 8
 4594 008a BD46     		mov	sp, r7
 4595              		.cfi_def_cfa_register 13
 4596              		@ sp needed
 4597 008c 80BD     		pop	{r7, pc}
 4598              	.L367:
 4599 008e 00BF     		.align	2
 4600              	.L366:
 4601 0090 00000000 		.word	xTickCount
 4602 0094 00000000 		.word	pxCurrentTCB
 4603 0098 00000000 		.word	xSuspendedTaskList
 4604 009c 00000000 		.word	pxOverflowDelayedTaskList
 4605 00a0 00000000 		.word	pxDelayedTaskList
 4606 00a4 00000000 		.word	xNextTaskUnblockTime
 4607              		.cfi_endproc
 4608              	.LFE46:
 4610              		.text
 4611              	.Letext0:
 4612              		.file 3 "c:\\program files (x86)\\emprog\\thunderbench-arm-v3.85\\arm\\lib\\gcc\\arm-none-eabi\\4.
 4613              		.file 4 "c:\\program files (x86)\\emprog\\thunderbench-arm-v3.85\\arm\\arm-none-eabi\\include\\mac
 4614              		.file 5 "c:\\program files (x86)\\emprog\\thunderbench-arm-v3.85\\arm\\arm-none-eabi\\include\\std
 4615              		.file 6 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/projdefs.h"
 4616              		.file 7 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/list.h"
 4617              		.file 8 "U:/Thunderspace/EFM32LG330F128/RTOSincludes/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:23     .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:20     .bss.pxCurrentTCB:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:26     .bss.pxReadyTasksLists:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:29     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:32     .bss.xDelayedTaskList1:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:35     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:38     .bss.xDelayedTaskList2:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:41     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:44     .bss.pxDelayedTaskList:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:47     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:50     .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:53     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:56     .bss.xPendingReadyList:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:59     .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:62     .bss.xSuspendedTaskList:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:65     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:68     .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:71     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:74     .bss.xTickCount:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:77     .bss.xTickCount:00000000 xTickCount
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:80     .bss.uxTopReadyPriority:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:83     .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:86     .bss.xSchedulerRunning:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:89     .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:92     .bss.uxPendedTicks:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:95     .bss.uxPendedTicks:00000000 uxPendedTicks
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:98     .bss.xYieldPending:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:101    .bss.xYieldPending:00000000 xYieldPending
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:104    .bss.xNumOfOverflows:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:107    .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:110    .bss.uxTaskNumber:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:113    .bss.uxTaskNumber:00000000 uxTaskNumber
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:116    .bss.xNextTaskUnblockTime:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:119    .bss.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:122    .bss.xIdleTaskHandle:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:125    .bss.xIdleTaskHandle:00000000 xIdleTaskHandle
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:128    .bss.uxSchedulerSuspended:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:131    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:134    .text.xTaskCreate:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:139    .text.xTaskCreate:00000000 xTaskCreate
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:240    .text.prvInitialiseNewTask:00000000 prvInitialiseNewTask
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:404    .text.prvAddNewTaskToReadyList:00000000 prvAddNewTaskToReadyList
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:236    .text.prvInitialiseNewTask:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:400    .text.prvAddNewTaskToReadyList:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2883   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:533    .text.prvAddNewTaskToReadyList:000000b8 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:544    .text.vTaskDelayUntil:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:549    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1447   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4502   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1486   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:690    .text.vTaskDelayUntil:000000b0 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:697    .text.vTaskDelay:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:702    .text.vTaskDelay:00000000 vTaskDelay
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:769    .text.vTaskDelay:0000004c $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:775    .text.vTaskSuspend:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:780    .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2994   .text.prvResetNextTaskUnblockTime:00000000 prvResetNextTaskUnblockTime
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2108   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:906    .text.vTaskSuspend:000000a8 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:916    .text.prvTaskIsTaskSuspended:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:920    .text.prvTaskIsTaskSuspended:00000000 prvTaskIsTaskSuspended
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1006   .text.prvTaskIsTaskSuspended:0000005c $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1012   .text.vTaskResume:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1017   .text.vTaskResume:00000000 vTaskResume
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1126   .text.vTaskResume:00000098 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1134   .text.xTaskResumeFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1139   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1280   .text.xTaskResumeFromISR:000000bc $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1289   .rodata:00000000 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1293   .text.vTaskStartScheduler:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1298   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1378   .text.vTaskStartScheduler:00000060 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2833   .text.prvIdleTask:00000000 prvIdleTask
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1388   .text.vTaskEndScheduler:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1393   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1437   .text.vTaskEndScheduler:00000028 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1442   .text.vTaskSuspendAll:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1476   .text.vTaskSuspendAll:00000018 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1481   .text.xTaskResumeAll:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1881   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1672   .text.xTaskResumeAll:00000104 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1685   .text.xTaskGetTickCount:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1690   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1724   .text.xTaskGetTickCount:0000001c $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1729   .text.xTaskGetTickCountFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1734   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1770   .text.xTaskGetTickCountFromISR:00000020 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1775   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1780   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1807   .text.uxTaskGetNumberOfTasks:00000014 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1812   .text.pcTaskGetName:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1817   .text.pcTaskGetName:00000000 pcTaskGetName
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1871   .text.pcTaskGetName:00000030 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:1876   .text.xTaskIncrementTick:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2088   .text.xTaskIncrementTick:00000120 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2103   .text.vTaskSwitchContext:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2221   .text.vTaskSwitchContext:00000090 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2230   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2235   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2280   .text.vTaskPlaceOnEventList:00000030 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2285   .text.vTaskPlaceOnUnorderedEventList:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2290   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2351   .text.vTaskPlaceOnUnorderedEventList:00000048 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2357   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2362   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2475   .text.xTaskRemoveFromEventList:0000009c $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2485   .text.xTaskRemoveFromUnorderedEventList:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2490   .text.xTaskRemoveFromUnorderedEventList:00000000 xTaskRemoveFromUnorderedEventList
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2601   .text.xTaskRemoveFromUnorderedEventList:00000094 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2610   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2615   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2661   .text.vTaskSetTimeOutState:0000002c $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2667   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2672   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2786   .text.xTaskCheckForTimeOut:00000090 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2792   .text.vTaskMissedYield:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2797   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2824   .text.vTaskMissedYield:00000014 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2829   .text.prvIdleTask:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2966   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2873   .text.prvIdleTask:00000028 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2879   .text.prvInitialiseTaskLists:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2951   .text.prvInitialiseTaskLists:00000058 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2962   .text.prvCheckTasksWaitingTermination:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:2990   .text.prvResetNextTaskUnblockTime:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3055   .text.prvResetNextTaskUnblockTime:00000040 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3061   .text.xTaskGetCurrentTaskHandle:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3066   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3100   .text.xTaskGetCurrentTaskHandle:0000001c $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3105   .text.xTaskGetSchedulerState:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3110   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3164   .text.xTaskGetSchedulerState:00000034 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3170   .text.vTaskPriorityInherit:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3175   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3298   .text.vTaskPriorityInherit:000000b0 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3305   .text.xTaskPriorityDisinherit:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3310   .text.xTaskPriorityDisinherit:00000000 xTaskPriorityDisinherit
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3432   .text.xTaskPriorityDisinherit:000000a8 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3439   .text.uxTaskResetEventItemValue:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3444   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3487   .text.uxTaskResetEventItemValue:0000002c $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3492   .text.pvTaskIncrementMutexHeldCount:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3497   .text.pvTaskIncrementMutexHeldCount:00000000 pvTaskIncrementMutexHeldCount
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3536   .text.pvTaskIncrementMutexHeldCount:00000024 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3541   .text.ulTaskNotifyTake:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3546   .text.ulTaskNotifyTake:00000000 ulTaskNotifyTake
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3646   .text.ulTaskNotifyTake:00000088 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3652   .text.xTaskNotifyWait:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3657   .text.xTaskNotifyWait:00000000 xTaskNotifyWait
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3776   .text.xTaskNotifyWait:000000ac $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3782   .text.xTaskGenericNotify:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3787   .text.xTaskGenericNotify:00000000 xTaskGenericNotify
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3848   .text.xTaskGenericNotify:00000050 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3853   .text.xTaskGenericNotify:00000064 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3979   .text.xTaskGenericNotify:00000110 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3987   .text.xTaskGenericNotifyFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:3992   .text.xTaskGenericNotifyFromISR:00000000 xTaskGenericNotifyFromISR
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4073   .text.xTaskGenericNotifyFromISR:0000006c $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4078   .text.xTaskGenericNotifyFromISR:00000080 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4231   .text.xTaskGenericNotifyFromISR:00000150 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4241   .text.vTaskNotifyGiveFromISR:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4246   .text.vTaskNotifyGiveFromISR:00000000 vTaskNotifyGiveFromISR
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4413   .text.vTaskNotifyGiveFromISR:000000e4 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4423   .text.xTaskNotifyStateClear:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4428   .text.xTaskNotifyStateClear:00000000 xTaskNotifyStateClear
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4493   .text.xTaskNotifyStateClear:00000048 $d
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4498   .text.prvAddCurrentTaskToDelayedList:00000000 $t
C:\Users\Riley\AppData\Local\Temp\ccTU87IM.s:4601   .text.prvAddCurrentTaskToDelayedList:00000090 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pvPortMalloc
vPortFree
vListInitialiseItem
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
uxListRemove
vPortValidateInterruptPriority
xPortStartScheduler
vPortEndScheduler
vListInsert
vListInitialise
